{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport GoTrueAdminApi from './GoTrueAdminApi';\nimport { DEFAULT_HEADERS, EXPIRY_MARGIN, GOTRUE_URL, STORAGE_KEY } from './lib/constants';\nimport { AuthImplicitGrantRedirectError, AuthPKCEGrantCodeExchangeError, AuthInvalidCredentialsError, AuthRetryableFetchError, AuthSessionMissingError, AuthUnknownError, isAuthApiError, isAuthError } from './lib/errors';\nimport { _request, _sessionResponse, _userResponse, _ssoResponse } from './lib/fetch';\nimport { decodeJWTPayload, Deferred, getItemAsync, getParameterByName, isBrowser, removeItemAsync, resolveFetch, setItemAsync, uuid, retryable, sleep, generatePKCEVerifier, generatePKCEChallenge } from './lib/helpers';\nimport localStorageAdapter from './lib/local-storage';\nimport { polyfillGlobalThis } from './lib/polyfills';\npolyfillGlobalThis(); // Make \"globalThis\" available\n\nconst DEFAULT_OPTIONS = {\n  url: GOTRUE_URL,\n  storageKey: STORAGE_KEY,\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  headers: DEFAULT_HEADERS,\n  flowType: 'implicit'\n};\n/** Current session will be checked for refresh at this interval. */\n\nconst AUTO_REFRESH_TICK_DURATION = 10 * 1000;\n/**\r\n * A token refresh will be attempted this many ticks before the current session expires. */\n\nconst AUTO_REFRESH_TICK_THRESHOLD = 3;\nexport default class GoTrueClient {\n  /**\r\n   * Create a new client for use in the browser.\r\n   */\n  constructor(options) {\n    var _a;\n\n    this.stateChangeEmitters = new Map();\n    this.autoRefreshTicker = null;\n    this.visibilityChangedCallback = null;\n    this.refreshingDeferred = null;\n    /**\r\n     * Keeps track of the async client initialization.\r\n     * When null or not yet resolved the auth state is `unknown`\r\n     * Once resolved the the auth state is known and it's save to call any further client methods.\r\n     * Keep extra care to never reject or throw uncaught errors\r\n     */\n\n    this.initializePromise = null;\n    this.detectSessionInUrl = true;\n    /**\r\n     * Used to broadcast state change events to other tabs listening.\r\n     */\n\n    this.broadcastChannel = null;\n    const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n    this.inMemorySession = null;\n    this.storageKey = settings.storageKey;\n    this.autoRefreshToken = settings.autoRefreshToken;\n    this.persistSession = settings.persistSession;\n    this.storage = settings.storage || localStorageAdapter;\n    this.admin = new GoTrueAdminApi({\n      url: settings.url,\n      headers: settings.headers,\n      fetch: settings.fetch\n    });\n    this.url = settings.url;\n    this.headers = settings.headers;\n    this.fetch = resolveFetch(settings.fetch);\n    this.detectSessionInUrl = settings.detectSessionInUrl;\n    this.flowType = settings.flowType;\n    this.mfa = {\n      verify: this._verify.bind(this),\n      enroll: this._enroll.bind(this),\n      unenroll: this._unenroll.bind(this),\n      challenge: this._challenge.bind(this),\n      listFactors: this._listFactors.bind(this),\n      challengeAndVerify: this._challengeAndVerify.bind(this),\n      getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this)\n    };\n\n    if (isBrowser() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {\n      try {\n        this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey);\n      } catch (e) {\n        console.error('Failed to create a new BroadcastChannel, multi-tab state changes will not be available', e);\n      }\n\n      (_a = this.broadcastChannel) === null || _a === void 0 ? void 0 : _a.addEventListener('message', event => {\n        this._notifyAllSubscribers(event.data.event, event.data.session, false); // broadcast = false so we don't get an endless loop of messages\n\n      });\n    }\n\n    this.initialize();\n  }\n  /**\r\n   * Initializes the client session either from the url or from storage.\r\n   * This method is automatically called when instantiating the client, but should also be called\r\n   * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).\r\n   */\n\n\n  initialize() {\n    if (!this.initializePromise) {\n      this.initializePromise = this._initialize();\n    }\n\n    return this.initializePromise;\n  }\n  /**\r\n   * IMPORTANT:\r\n   * 1. Never throw in this method, as it is called from the constructor\r\n   * 2. Never return a session from this method as it would be cached over\r\n   *    the whole lifetime of the client\r\n   */\n\n\n  _initialize() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.initializePromise) {\n        return this.initializePromise;\n      }\n\n      try {\n        const isPKCEFlow = yield this._isPKCEFlow();\n\n        if (this.detectSessionInUrl && this._isImplicitGrantFlow() || isPKCEFlow) {\n          const {\n            data,\n            error\n          } = yield this._getSessionFromUrl(isPKCEFlow);\n\n          if (error) {\n            // failed login attempt via url,\n            // remove old session as in verifyOtp, signUp and signInWith*\n            yield this._removeSession();\n            return {\n              error\n            };\n          }\n\n          const {\n            session,\n            redirectType\n          } = data;\n          yield this._saveSession(session);\n          setTimeout(() => {\n            if (redirectType === 'recovery') {\n              this._notifyAllSubscribers('PASSWORD_RECOVERY', session);\n            } else {\n              this._notifyAllSubscribers('SIGNED_IN', session);\n            }\n          }, 0);\n          return {\n            error: null\n          };\n        } // no login attempt via callback url try to recover session from storage\n\n\n        yield this._recoverAndRefresh();\n        return {\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            error\n          };\n        }\n\n        return {\n          error: new AuthUnknownError('Unexpected error during initialization', error)\n        };\n      } finally {\n        yield this._handleVisibilityChange();\n      }\n    });\n  }\n  /**\r\n   * Creates a new user.\r\n   *\r\n   * Be aware that if a user account exists in the system you may get back an\r\n   * error message that attempts to hide this information from the user.\r\n   *\r\n   * @returns A logged-in session if the server has \"autoconfirm\" ON\r\n   * @returns A user if the server has \"autoconfirm\" OFF\r\n   */\n\n\n  signUp(credentials) {\n    var _a, _b, _c;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this._removeSession();\n        let res;\n\n        if ('email' in credentials) {\n          const {\n            email,\n            password,\n            options\n          } = credentials;\n          res = yield _request(this.fetch, 'POST', `${this.url}/signup`, {\n            headers: this.headers,\n            redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n            body: {\n              email,\n              password,\n              data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n              gotrue_meta_security: {\n                captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n              }\n            },\n            xform: _sessionResponse\n          });\n        } else if ('phone' in credentials) {\n          const {\n            phone,\n            password,\n            options\n          } = credentials;\n          res = yield _request(this.fetch, 'POST', `${this.url}/signup`, {\n            headers: this.headers,\n            body: {\n              phone,\n              password,\n              data: (_b = options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : {},\n              channel: (_c = options === null || options === void 0 ? void 0 : options.channel) !== null && _c !== void 0 ? _c : 'sms',\n              gotrue_meta_security: {\n                captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n              }\n            },\n            xform: _sessionResponse\n          });\n        } else {\n          throw new AuthInvalidCredentialsError('You must provide either an email or phone number and a password');\n        }\n\n        const {\n          data,\n          error\n        } = res;\n\n        if (error || !data) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error: error\n          };\n        }\n\n        const session = data.session;\n        const user = data.user;\n\n        if (data.session) {\n          yield this._saveSession(data.session);\n\n          this._notifyAllSubscribers('SIGNED_IN', session);\n        }\n\n        return {\n          data: {\n            user,\n            session\n          },\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\r\n   * Log in an existing user with an email and password or phone and password.\r\n   *\r\n   * Be aware that you may get back an error message that will not distinguish\r\n   * between the cases where the account does not exist or that the\r\n   * email/phone and password combination is wrong or that the account can only\r\n   * be accessed via social login.\r\n   */\n\n\n  signInWithPassword(credentials) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this._removeSession();\n        let res;\n\n        if ('email' in credentials) {\n          const {\n            email,\n            password,\n            options\n          } = credentials;\n          res = yield _request(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\n            headers: this.headers,\n            body: {\n              email,\n              password,\n              gotrue_meta_security: {\n                captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n              }\n            },\n            xform: _sessionResponse\n          });\n        } else if ('phone' in credentials) {\n          const {\n            phone,\n            password,\n            options\n          } = credentials;\n          res = yield _request(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\n            headers: this.headers,\n            body: {\n              phone,\n              password,\n              gotrue_meta_security: {\n                captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n              }\n            },\n            xform: _sessionResponse\n          });\n        } else {\n          throw new AuthInvalidCredentialsError('You must provide either an email or phone number and a password');\n        }\n\n        const {\n          data,\n          error\n        } = res;\n        if (error || !data) return {\n          data: {\n            user: null,\n            session: null\n          },\n          error\n        };\n\n        if (data.session) {\n          yield this._saveSession(data.session);\n\n          this._notifyAllSubscribers('SIGNED_IN', data.session);\n        }\n\n        return {\n          data,\n          error\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\r\n   * Log in an existing user via a third-party provider.\r\n   */\n\n\n  signInWithOAuth(credentials) {\n    var _a, _b, _c, _d, _e;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this._removeSession();\n      return yield this._handleProviderSignIn(credentials.provider, {\n        redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,\n        scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,\n        queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,\n        skipBrowserRedirect: (_d = credentials.options) === null || _d === void 0 ? void 0 : _d.skipBrowserRedirect,\n        flowType: (_e = this.flowType) !== null && _e !== void 0 ? _e : 'implicit'\n      });\n    });\n  }\n  /**\r\n   * Log in an existing user via a third-party provider.\r\n   */\n\n\n  exchangeCodeForSession(authCode) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const codeVerifier = yield getItemAsync(this.storage, `${this.storageKey}-code-verifier`);\n      const {\n        data,\n        error\n      } = yield _request(this.fetch, 'POST', `${this.url}/token?grant_type=pkce`, {\n        headers: this.headers,\n        body: {\n          auth_code: authCode,\n          code_verifier: codeVerifier\n        },\n        xform: _sessionResponse\n      });\n      yield removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);\n      if (error || !data) return {\n        data: {\n          user: null,\n          session: null\n        },\n        error\n      };\n\n      if (data.session) {\n        yield this._saveSession(data.session);\n\n        this._notifyAllSubscribers('SIGNED_IN', data.session);\n      }\n\n      return {\n        data,\n        error\n      };\n    });\n  }\n  /**\r\n   * Allows signing in with an ID token issued by certain supported providers.\r\n   * The ID token is verified for validity and a new session is established.\r\n   *\r\n   * @experimental\r\n   */\n\n\n  signInWithIdToken(credentials) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this._removeSession();\n\n      try {\n        const {\n          options,\n          provider,\n          token,\n          nonce\n        } = credentials;\n        const res = yield _request(this.fetch, 'POST', `${this.url}/token?grant_type=id_token`, {\n          headers: this.headers,\n          body: {\n            provider,\n            id_token: token,\n            nonce,\n            gotrue_meta_security: {\n              captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n            }\n          },\n          xform: _sessionResponse\n        });\n        const {\n          data,\n          error\n        } = res;\n        if (error || !data) return {\n          data: {\n            user: null,\n            session: null\n          },\n          error\n        };\n\n        if (data.session) {\n          yield this._saveSession(data.session);\n\n          this._notifyAllSubscribers('SIGNED_IN', data.session);\n        }\n\n        return {\n          data,\n          error\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\r\n   * Log in a user using magiclink or a one-time password (OTP).\r\n   *\r\n   * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.\r\n   * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.\r\n   * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.\r\n   *\r\n   * Be aware that you may get back an error message that will not distinguish\r\n   * between the cases where the account does not exist or, that the account\r\n   * can only be accessed via social login.\r\n   *\r\n   * Do note that you will need to configure a Whatsapp sender on Twilio\r\n   * if you are using phone sign in with the 'whatsapp' channel. The whatsapp\r\n   * channel is not supported on other providers\r\n   * at this time.\r\n   */\n\n\n  signInWithOtp(credentials) {\n    var _a, _b, _c, _d, _e;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this._removeSession();\n\n        if ('email' in credentials) {\n          const {\n            email,\n            options\n          } = credentials;\n          const {\n            error\n          } = yield _request(this.fetch, 'POST', `${this.url}/otp`, {\n            headers: this.headers,\n            body: {\n              email,\n              data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n              create_user: (_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : true,\n              gotrue_meta_security: {\n                captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n              }\n            },\n            redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo\n          });\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n\n        if ('phone' in credentials) {\n          const {\n            phone,\n            options\n          } = credentials;\n          const {\n            error\n          } = yield _request(this.fetch, 'POST', `${this.url}/otp`, {\n            headers: this.headers,\n            body: {\n              phone,\n              data: (_c = options === null || options === void 0 ? void 0 : options.data) !== null && _c !== void 0 ? _c : {},\n              create_user: (_d = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _d !== void 0 ? _d : true,\n              gotrue_meta_security: {\n                captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n              },\n              channel: (_e = options === null || options === void 0 ? void 0 : options.channel) !== null && _e !== void 0 ? _e : 'sms'\n            }\n          });\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n\n        throw new AuthInvalidCredentialsError('You must provide either an email or phone number.');\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\r\n   * Log in a user given a User supplied OTP received via mobile.\r\n   */\n\n\n  verifyOtp(params) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this._removeSession();\n        const {\n          data,\n          error\n        } = yield _request(this.fetch, 'POST', `${this.url}/verify`, {\n          headers: this.headers,\n          body: Object.assign(Object.assign({}, params), {\n            gotrue_meta_security: {\n              captcha_token: (_a = params.options) === null || _a === void 0 ? void 0 : _a.captchaToken\n            }\n          }),\n          redirectTo: (_b = params.options) === null || _b === void 0 ? void 0 : _b.redirectTo,\n          xform: _sessionResponse\n        });\n\n        if (error) {\n          throw error;\n        }\n\n        if (!data) {\n          throw new Error('An error occurred on token verification.');\n        }\n\n        const session = data.session;\n        const user = data.user;\n\n        if (session === null || session === void 0 ? void 0 : session.access_token) {\n          yield this._saveSession(session);\n\n          this._notifyAllSubscribers('SIGNED_IN', session);\n        }\n\n        return {\n          data: {\n            user,\n            session\n          },\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\r\n   * Attempts a single-sign on using an enterprise Identity Provider. A\r\n   * successful SSO attempt will redirect the current page to the identity\r\n   * provider authorization page. The redirect URL is implementation and SSO\r\n   * protocol specific.\r\n   *\r\n   * You can use it by providing a SSO domain. Typically you can extract this\r\n   * domain by asking users for their email address. If this domain is\r\n   * registered on the Auth instance the redirect will use that organization's\r\n   * currently active SSO Identity Provider for the login.\r\n   *\r\n   * If you have built an organization-specific login page, you can use the\r\n   * organization's SSO Identity Provider UUID directly instead.\r\n   */\n\n\n  signInWithSSO(params) {\n    var _a, _b, _c;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this._removeSession();\n        return yield _request(this.fetch, 'POST', `${this.url}/sso`, {\n          body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, 'providerId' in params ? {\n            provider_id: params.providerId\n          } : null), 'domain' in params ? {\n            domain: params.domain\n          } : null), {\n            redirect_to: (_b = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo) !== null && _b !== void 0 ? _b : undefined\n          }), ((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.captchaToken) ? {\n            gotrue_meta_security: {\n              captcha_token: params.options.captchaToken\n            }\n          } : null), {\n            skip_http_redirect: true\n          }),\n          headers: this.headers,\n          xform: _ssoResponse\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\r\n   * Returns the session, refreshing it if necessary.\r\n   * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.\r\n   */\n\n\n  getSession() {\n    return __awaiter(this, void 0, void 0, function* () {\n      // make sure we've read the session from the url if there is one\n      // save to just await, as long we make sure _initialize() never throws\n      yield this.initializePromise;\n      let currentSession = null;\n\n      if (this.persistSession) {\n        const maybeSession = yield getItemAsync(this.storage, this.storageKey);\n\n        if (maybeSession !== null) {\n          if (this._isValidSession(maybeSession)) {\n            currentSession = maybeSession;\n          } else {\n            yield this._removeSession();\n          }\n        }\n      } else {\n        currentSession = this.inMemorySession;\n      }\n\n      if (!currentSession) {\n        return {\n          data: {\n            session: null\n          },\n          error: null\n        };\n      }\n\n      const hasExpired = currentSession.expires_at ? currentSession.expires_at <= Date.now() / 1000 : false;\n\n      if (!hasExpired) {\n        return {\n          data: {\n            session: currentSession\n          },\n          error: null\n        };\n      }\n\n      const {\n        session,\n        error\n      } = yield this._callRefreshToken(currentSession.refresh_token);\n\n      if (error) {\n        return {\n          data: {\n            session: null\n          },\n          error\n        };\n      }\n\n      return {\n        data: {\n          session\n        },\n        error: null\n      };\n    });\n  }\n  /**\r\n   * Gets the current user details if there is an existing session.\r\n   * @param jwt Takes in an optional access token jwt. If no jwt is provided, getUser() will attempt to get the jwt from the current session.\r\n   */\n\n\n  getUser(jwt) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!jwt) {\n          const {\n            data,\n            error\n          } = yield this.getSession();\n\n          if (error) {\n            throw error;\n          } // Default to Authorization header if there is no existing session\n\n\n          jwt = (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : undefined;\n        }\n\n        return yield _request(this.fetch, 'GET', `${this.url}/user`, {\n          headers: this.headers,\n          jwt: jwt,\n          xform: _userResponse\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null\n            },\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\r\n   * Updates user data for a logged in user.\r\n   */\n\n\n  updateUser(attributes) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          data: sessionData,\n          error: sessionError\n        } = yield this.getSession();\n\n        if (sessionError) {\n          throw sessionError;\n        }\n\n        if (!sessionData.session) {\n          throw new AuthSessionMissingError();\n        }\n\n        const session = sessionData.session;\n        const {\n          data,\n          error: userError\n        } = yield _request(this.fetch, 'PUT', `${this.url}/user`, {\n          headers: this.headers,\n          redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n          body: attributes,\n          jwt: session.access_token,\n          xform: _userResponse\n        });\n        if (userError) throw userError;\n        session.user = data.user;\n        yield this._saveSession(session);\n\n        this._notifyAllSubscribers('USER_UPDATED', session);\n\n        return {\n          data: {\n            user: session.user\n          },\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null\n            },\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\r\n   * Decodes a JWT (without performing any validation).\r\n   */\n\n\n  _decodeJWT(jwt) {\n    return decodeJWTPayload(jwt);\n  }\n  /**\r\n   * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.\r\n   * If the refresh token or access token in the current session is invalid, an error will be thrown.\r\n   * @param currentSession The current session that minimally contains an access token and refresh token.\r\n   */\n\n\n  setSession(currentSession) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!currentSession.access_token || !currentSession.refresh_token) {\n          throw new AuthSessionMissingError();\n        }\n\n        const timeNow = Date.now() / 1000;\n        let expiresAt = timeNow;\n        let hasExpired = true;\n        let session = null;\n        const payload = decodeJWTPayload(currentSession.access_token);\n\n        if (payload.exp) {\n          expiresAt = payload.exp;\n          hasExpired = expiresAt <= timeNow;\n        }\n\n        if (hasExpired) {\n          const {\n            session: refreshedSession,\n            error\n          } = yield this._callRefreshToken(currentSession.refresh_token);\n\n          if (error) {\n            return {\n              data: {\n                user: null,\n                session: null\n              },\n              error: error\n            };\n          }\n\n          if (!refreshedSession) {\n            return {\n              data: {\n                user: null,\n                session: null\n              },\n              error: null\n            };\n          }\n\n          session = refreshedSession;\n        } else {\n          const {\n            data,\n            error\n          } = yield this.getUser(currentSession.access_token);\n\n          if (error) {\n            throw error;\n          }\n\n          session = {\n            access_token: currentSession.access_token,\n            refresh_token: currentSession.refresh_token,\n            user: data.user,\n            token_type: 'bearer',\n            expires_in: expiresAt - timeNow,\n            expires_at: expiresAt\n          };\n          yield this._saveSession(session);\n\n          this._notifyAllSubscribers('SIGNED_IN', session);\n        }\n\n        return {\n          data: {\n            user: session.user,\n            session\n          },\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              session: null,\n              user: null\n            },\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\r\n   * Returns a new session, regardless of expiry status.\r\n   * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().\r\n   * If the current session's refresh token is invalid, an error will be thrown.\r\n   * @param currentSession The current session. If passed in, it must contain a refresh token.\r\n   */\n\n\n  refreshSession(currentSession) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!currentSession) {\n          const {\n            data,\n            error\n          } = yield this.getSession();\n\n          if (error) {\n            throw error;\n          }\n\n          currentSession = (_a = data.session) !== null && _a !== void 0 ? _a : undefined;\n        }\n\n        if (!(currentSession === null || currentSession === void 0 ? void 0 : currentSession.refresh_token)) {\n          throw new AuthSessionMissingError();\n        }\n\n        const {\n          session,\n          error\n        } = yield this._callRefreshToken(currentSession.refresh_token);\n\n        if (error) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error: error\n          };\n        }\n\n        if (!session) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error: null\n          };\n        }\n\n        return {\n          data: {\n            user: session.user,\n            session\n          },\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\r\n   * Gets the session data from a URL string\r\n   */\n\n\n  _getSessionFromUrl(isPKCEFlow) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!isBrowser()) throw new AuthImplicitGrantRedirectError('No browser detected.');\n\n        if (this.flowType == 'implicit' && !this._isImplicitGrantFlow()) {\n          throw new AuthImplicitGrantRedirectError('Not a valid implicit grant flow url.');\n        } else if (this.flowType == 'pkce' && !isPKCEFlow) {\n          throw new AuthPKCEGrantCodeExchangeError('Not a valid PKCE flow url.');\n        }\n\n        if (isPKCEFlow) {\n          const authCode = getParameterByName('code');\n          if (!authCode) throw new AuthPKCEGrantCodeExchangeError('No code detected.');\n          const {\n            data,\n            error\n          } = yield this.exchangeCodeForSession(authCode);\n          if (error) throw error;\n          if (!data.session) throw new AuthPKCEGrantCodeExchangeError('No session detected.');\n          return {\n            data: {\n              session: data.session,\n              redirectType: null\n            },\n            error: null\n          };\n        }\n\n        const error_description = getParameterByName('error_description');\n\n        if (error_description) {\n          const error_code = getParameterByName('error_code');\n          if (!error_code) throw new AuthImplicitGrantRedirectError('No error_code detected.');\n          const error = getParameterByName('error');\n          if (!error) throw new AuthImplicitGrantRedirectError('No error detected.');\n          throw new AuthImplicitGrantRedirectError(error_description, {\n            error,\n            code: error_code\n          });\n        }\n\n        const provider_token = getParameterByName('provider_token');\n        const provider_refresh_token = getParameterByName('provider_refresh_token');\n        const access_token = getParameterByName('access_token');\n        if (!access_token) throw new AuthImplicitGrantRedirectError('No access_token detected.');\n        const expires_in = getParameterByName('expires_in');\n        if (!expires_in) throw new AuthImplicitGrantRedirectError('No expires_in detected.');\n        const refresh_token = getParameterByName('refresh_token');\n        if (!refresh_token) throw new AuthImplicitGrantRedirectError('No refresh_token detected.');\n        const token_type = getParameterByName('token_type');\n        if (!token_type) throw new AuthImplicitGrantRedirectError('No token_type detected.');\n        const timeNow = Math.round(Date.now() / 1000);\n        const expires_at = timeNow + parseInt(expires_in);\n        const {\n          data,\n          error\n        } = yield this.getUser(access_token);\n        if (error) throw error;\n        const user = data.user;\n        const session = {\n          provider_token,\n          provider_refresh_token,\n          access_token,\n          expires_in: parseInt(expires_in),\n          expires_at,\n          refresh_token,\n          token_type,\n          user\n        };\n        const redirectType = getParameterByName('type'); // Remove tokens from URL\n\n        window.location.hash = '';\n        return {\n          data: {\n            session,\n            redirectType\n          },\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              session: null,\n              redirectType: null\n            },\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\r\n   * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)\r\n   */\n\n\n  _isImplicitGrantFlow() {\n    return isBrowser() && (Boolean(getParameterByName('access_token')) || Boolean(getParameterByName('error_description')));\n  }\n  /**\r\n   * Checks if the current URL and backing storage contain parameters given by a PKCE flow\r\n   */\n\n\n  _isPKCEFlow() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const currentStorageContent = yield getItemAsync(this.storage, `${this.storageKey}-code-verifier`);\n      return isBrowser() && Boolean(getParameterByName('code')) && Boolean(currentStorageContent);\n    });\n  }\n  /**\r\n   * Inside a browser context, `signOut()` will remove the logged in user from the browser session\r\n   * and log them out - removing all items from localstorage and then trigger a `\"SIGNED_OUT\"` event.\r\n   *\r\n   * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.\r\n   * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.\r\n   */\n\n\n  signOut() {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        data,\n        error: sessionError\n      } = yield this.getSession();\n\n      if (sessionError) {\n        return {\n          error: sessionError\n        };\n      }\n\n      const accessToken = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token;\n\n      if (accessToken) {\n        const {\n          error\n        } = yield this.admin.signOut(accessToken);\n\n        if (error) {\n          // ignore 404s since user might not exist anymore\n          // ignore 401s since an invalid or expired JWT should sign out the current session\n          if (!(isAuthApiError(error) && (error.status === 404 || error.status === 401))) {\n            return {\n              error\n            };\n          }\n        }\n      }\n\n      yield this._removeSession();\n\n      this._notifyAllSubscribers('SIGNED_OUT', null);\n\n      return {\n        error: null\n      };\n    });\n  }\n  /**\r\n   * Receive a notification every time an auth event happens.\r\n   * @param callback A callback function to be invoked when an auth event happens.\r\n   */\n\n\n  onAuthStateChange(callback) {\n    const id = uuid();\n    const subscription = {\n      id,\n      callback,\n      unsubscribe: () => {\n        this.stateChangeEmitters.delete(id);\n      }\n    };\n    this.stateChangeEmitters.set(id, subscription);\n    this.emitInitialSession(id);\n    return {\n      data: {\n        subscription\n      }\n    };\n  }\n\n  emitInitialSession(id) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          data: {\n            session\n          },\n          error\n        } = yield this.getSession();\n        if (error) throw error;\n        (_a = this.stateChangeEmitters.get(id)) === null || _a === void 0 ? void 0 : _a.callback('INITIAL_SESSION', session);\n      } catch (err) {\n        (_b = this.stateChangeEmitters.get(id)) === null || _b === void 0 ? void 0 : _b.callback('INITIAL_SESSION', null);\n        console.error(err);\n      }\n    });\n  }\n  /**\r\n   * Sends a password reset request to an email address.\r\n   * @param email The email address of the user.\r\n   * @param options.redirectTo The URL to send the user to after they click the password reset link.\r\n   * @param options.captchaToken Verification token received when the user completes the captcha on the site.\r\n   */\n\n\n  resetPasswordForEmail(email) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        return yield _request(this.fetch, 'POST', `${this.url}/recover`, {\n          body: {\n            email,\n            gotrue_meta_security: {\n              captcha_token: options.captchaToken\n            }\n          },\n          headers: this.headers,\n          redirectTo: options.redirectTo\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\r\n   * Generates a new JWT.\r\n   * @param refreshToken A valid refresh token that was returned on login.\r\n   */\n\n\n  _refreshAccessToken(refreshToken) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const startedAt = Date.now(); // will attempt to refresh the token with exponential backoff\n\n        return yield retryable(attempt => __awaiter(this, void 0, void 0, function* () {\n          yield sleep(attempt * 200); // 0, 200, 400, 800, ...\n\n          return yield _request(this.fetch, 'POST', `${this.url}/token?grant_type=refresh_token`, {\n            body: {\n              refresh_token: refreshToken\n            },\n            headers: this.headers,\n            xform: _sessionResponse\n          });\n        }), (attempt, _, result) => result && result.error && result.error instanceof AuthRetryableFetchError && // retryable only if the request can be sent before the backoff overflows the tick duration\n        Date.now() + (attempt + 1) * 200 - startedAt < AUTO_REFRESH_TICK_DURATION);\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              session: null,\n              user: null\n            },\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n\n  _isValidSession(maybeSession) {\n    const isValidSession = typeof maybeSession === 'object' && maybeSession !== null && 'access_token' in maybeSession && 'refresh_token' in maybeSession && 'expires_at' in maybeSession;\n    return isValidSession;\n  }\n\n  _handleProviderSignIn(provider, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const url = yield this._getUrlForProvider(provider, {\n        redirectTo: options.redirectTo,\n        scopes: options.scopes,\n        queryParams: options.queryParams,\n        flowType: options.flowType\n      }); // try to open on the browser\n\n      if (isBrowser() && !options.skipBrowserRedirect) {\n        window.location.assign(url);\n      }\n\n      return {\n        data: {\n          provider,\n          url\n        },\n        error: null\n      };\n    });\n  }\n  /**\r\n   * Recovers the session from LocalStorage and refreshes\r\n   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\r\n   */\n\n\n  _recoverAndRefresh() {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const currentSession = yield getItemAsync(this.storage, this.storageKey);\n\n        if (!this._isValidSession(currentSession)) {\n          if (currentSession !== null) {\n            yield this._removeSession();\n          }\n\n          return;\n        }\n\n        const timeNow = Math.round(Date.now() / 1000);\n\n        if (((_a = currentSession.expires_at) !== null && _a !== void 0 ? _a : Infinity) < timeNow + EXPIRY_MARGIN) {\n          if (this.autoRefreshToken && currentSession.refresh_token) {\n            const {\n              error\n            } = yield this._callRefreshToken(currentSession.refresh_token);\n\n            if (error) {\n              console.log(error.message);\n              yield this._removeSession();\n            }\n          } else {\n            yield this._removeSession();\n          }\n        } else {\n          if (this.persistSession) {\n            yield this._saveSession(currentSession);\n          }\n\n          this._notifyAllSubscribers('SIGNED_IN', currentSession);\n        }\n      } catch (err) {\n        console.error(err);\n        return;\n      }\n    });\n  }\n\n  _callRefreshToken(refreshToken) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      // refreshing is already in progress\n      if (this.refreshingDeferred) {\n        return this.refreshingDeferred.promise;\n      }\n\n      try {\n        this.refreshingDeferred = new Deferred();\n\n        if (!refreshToken) {\n          throw new AuthSessionMissingError();\n        }\n\n        const {\n          data,\n          error\n        } = yield this._refreshAccessToken(refreshToken);\n        if (error) throw error;\n        if (!data.session) throw new AuthSessionMissingError();\n        yield this._saveSession(data.session);\n\n        this._notifyAllSubscribers('TOKEN_REFRESHED', data.session);\n\n        const result = {\n          session: data.session,\n          error: null\n        };\n        this.refreshingDeferred.resolve(result);\n        return result;\n      } catch (error) {\n        if (isAuthError(error)) {\n          const result = {\n            session: null,\n            error\n          };\n          (_a = this.refreshingDeferred) === null || _a === void 0 ? void 0 : _a.resolve(result);\n          return result;\n        }\n\n        (_b = this.refreshingDeferred) === null || _b === void 0 ? void 0 : _b.reject(error);\n        throw error;\n      } finally {\n        this.refreshingDeferred = null;\n      }\n    });\n  }\n\n  _notifyAllSubscribers(event, session) {\n    let broadcast = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n    if (this.broadcastChannel && broadcast) {\n      this.broadcastChannel.postMessage({\n        event,\n        session\n      });\n    }\n\n    this.stateChangeEmitters.forEach(x => x.callback(event, session));\n  }\n  /**\r\n   * set currentSession and currentUser\r\n   * process to _startAutoRefreshToken if possible\r\n   */\n\n\n  _saveSession(session) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.persistSession) {\n        this.inMemorySession = session;\n      }\n\n      if (this.persistSession && session.expires_at) {\n        yield this._persistSession(session);\n      }\n    });\n  }\n\n  _persistSession(currentSession) {\n    return setItemAsync(this.storage, this.storageKey, currentSession);\n  }\n\n  _removeSession() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.persistSession) {\n        yield removeItemAsync(this.storage, this.storageKey);\n      } else {\n        this.inMemorySession = null;\n      }\n    });\n  }\n  /**\r\n   * Removes any registered visibilitychange callback.\r\n   *\r\n   * {@see #startAutoRefresh}\r\n   * {@see #stopAutoRefresh}\r\n   */\n\n\n  _removeVisibilityChangedCallback() {\n    const callback = this.visibilityChangedCallback;\n    this.visibilityChangedCallback = null;\n\n    try {\n      if (callback && isBrowser() && (window === null || window === void 0 ? void 0 : window.removeEventListener)) {\n        window.removeEventListener('visibilitychange', callback);\n      }\n    } catch (e) {\n      console.error('removing visibilitychange callback failed', e);\n    }\n  }\n  /**\r\n   * This is the private implementation of {@link #startAutoRefresh}. Use this\r\n   * within the library.\r\n   */\n\n\n  _startAutoRefresh() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this._stopAutoRefresh();\n      const ticker = setInterval(() => this._autoRefreshTokenTick(), AUTO_REFRESH_TICK_DURATION);\n      this.autoRefreshTicker = ticker;\n\n      if (ticker && typeof ticker === 'object' && typeof ticker.unref === 'function') {\n        // ticker is a NodeJS Timeout object that has an `unref` method\n        // https://nodejs.org/api/timers.html#timeoutunref\n        // When auto refresh is used in NodeJS (like for testing) the\n        // `setInterval` is preventing the process from being marked as\n        // finished and tests run endlessly. This can be prevented by calling\n        // `unref()` on the returned object.\n        ticker.unref();\n      } // run the tick immediately\n\n\n      yield this._autoRefreshTokenTick();\n    });\n  }\n  /**\r\n   * This is the private implementation of {@link #stopAutoRefresh}. Use this\r\n   * within the library.\r\n   */\n\n\n  _stopAutoRefresh() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const ticker = this.autoRefreshTicker;\n      this.autoRefreshTicker = null;\n\n      if (ticker) {\n        clearInterval(ticker);\n      }\n    });\n  }\n  /**\r\n   * Starts an auto-refresh process in the background. The session is checked\r\n   * every few seconds. Close to the time of expiration a process is started to\r\n   * refresh the session. If refreshing fails it will be retried for as long as\r\n   * necessary.\r\n   *\r\n   * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need\r\n   * to call this function, it will be called for you.\r\n   *\r\n   * On browsers the refresh process works only when the tab/window is in the\r\n   * foreground to conserve resources as well as prevent race conditions and\r\n   * flooding auth with requests. If you call this method any managed\r\n   * visibility change callback will be removed and you must manage visibility\r\n   * changes on your own.\r\n   *\r\n   * On non-browser platforms the refresh process works *continuously* in the\r\n   * background, which may not be desireable. You should hook into your\r\n   * platform's foreground indication mechanism and call these methods\r\n   * appropriately to conserve resources.\r\n   *\r\n   * {@see #stopAutoRefresh}\r\n   */\n\n\n  startAutoRefresh() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this._removeVisibilityChangedCallback();\n\n      yield this._startAutoRefresh();\n    });\n  }\n  /**\r\n   * Stops an active auto refresh process running in the background (if any).\r\n   *\r\n   * If you call this method any managed visibility change callback will be\r\n   * removed and you must manage visibility changes on your own.\r\n   *\r\n   * See {@link #startAutoRefresh} for more details.\r\n   */\n\n\n  stopAutoRefresh() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this._removeVisibilityChangedCallback();\n\n      yield this._stopAutoRefresh();\n    });\n  }\n  /**\r\n   * Runs the auto refresh token tick.\r\n   */\n\n\n  _autoRefreshTokenTick() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const now = Date.now();\n\n      try {\n        const {\n          data: {\n            session\n          }\n        } = yield this.getSession();\n\n        if (!session || !session.refresh_token || !session.expires_at) {\n          return;\n        } // session will expire in this many ticks (or has already expired if <= 0)\n\n\n        const expiresInTicks = Math.floor((session.expires_at * 1000 - now) / AUTO_REFRESH_TICK_DURATION);\n\n        if (expiresInTicks < AUTO_REFRESH_TICK_THRESHOLD) {\n          yield this._callRefreshToken(session.refresh_token);\n        }\n      } catch (e) {\n        console.error('Auto refresh tick failed with error. This is likely a transient error.', e);\n      }\n    });\n  }\n  /**\r\n   * Registers callbacks on the browser / platform, which in-turn run\r\n   * algorithms when the browser window/tab are in foreground. On non-browser\r\n   * platforms it assumes always foreground.\r\n   */\n\n\n  _handleVisibilityChange() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n        if (this.autoRefreshToken) {\n          // in non-browser environments the refresh token ticker runs always\n          this.startAutoRefresh();\n        }\n\n        return false;\n      }\n\n      try {\n        this.visibilityChangedCallback = () => __awaiter(this, void 0, void 0, function* () {\n          return yield this._onVisibilityChanged(false);\n        });\n\n        window === null || window === void 0 ? void 0 : window.addEventListener('visibilitychange', this.visibilityChangedCallback); // now immediately call the visbility changed callback to setup with the\n        // current visbility state\n\n        yield this._onVisibilityChanged(true); // initial call\n      } catch (error) {\n        console.error('_handleVisibilityChange', error);\n      }\n    });\n  }\n  /**\r\n   * Callback registered with `window.addEventListener('visibilitychange')`.\r\n   */\n\n\n  _onVisibilityChanged(isInitial) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (document.visibilityState === 'visible') {\n        if (!isInitial) {\n          // initial visibility change setup is handled in another flow under #initialize()\n          yield this.initializePromise;\n          yield this._recoverAndRefresh();\n        }\n\n        if (this.autoRefreshToken) {\n          // in browser environments the refresh token ticker runs only on focused tabs\n          // which prevents race conditions\n          this._startAutoRefresh();\n        }\n      } else if (document.visibilityState === 'hidden') {\n        if (this.autoRefreshToken) {\n          this._stopAutoRefresh();\n        }\n      }\n    });\n  }\n  /**\r\n   * Generates the relevant login URL for a third-party provider.\r\n   * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.\r\n   * @param options.scopes A space-separated list of scopes granted to the OAuth application.\r\n   * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.\r\n   * @param options.flowType OAuth flow to use - defaults to implicit flow. PKCE is recommended for mobile and server-side applications.\r\n   */\n\n\n  _getUrlForProvider(provider, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const urlParams = [`provider=${encodeURIComponent(provider)}`];\n\n      if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n        urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);\n      }\n\n      if (options === null || options === void 0 ? void 0 : options.scopes) {\n        urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);\n      }\n\n      if ((options === null || options === void 0 ? void 0 : options.flowType) === 'pkce') {\n        const codeVerifier = generatePKCEVerifier();\n        yield setItemAsync(this.storage, `${this.storageKey}-code-verifier`, codeVerifier);\n        const codeChallenge = yield generatePKCEChallenge(codeVerifier);\n        const flowParams = new URLSearchParams({\n          flow_type: `${encodeURIComponent(options.flowType)}`,\n          code_challenge: `${encodeURIComponent(codeChallenge)}`,\n          code_challenge_method: `${encodeURIComponent('s256')}`\n        });\n        urlParams.push(flowParams.toString());\n      }\n\n      if (options === null || options === void 0 ? void 0 : options.queryParams) {\n        const query = new URLSearchParams(options.queryParams);\n        urlParams.push(query.toString());\n      }\n\n      return `${this.url}/authorize?${urlParams.join('&')}`;\n    });\n  }\n\n  _unenroll(params) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          data: sessionData,\n          error: sessionError\n        } = yield this.getSession();\n\n        if (sessionError) {\n          return {\n            data: null,\n            error: sessionError\n          };\n        }\n\n        return yield _request(this.fetch, 'DELETE', `${this.url}/factors/${params.factorId}`, {\n          headers: this.headers,\n          jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\r\n   * {@see GoTrueMFAApi#enroll}\r\n   */\n\n\n  _enroll(params) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          data: sessionData,\n          error: sessionError\n        } = yield this.getSession();\n\n        if (sessionError) {\n          return {\n            data: null,\n            error: sessionError\n          };\n        }\n\n        const {\n          data,\n          error\n        } = yield _request(this.fetch, 'POST', `${this.url}/factors`, {\n          body: {\n            friendly_name: params.friendlyName,\n            factor_type: params.factorType,\n            issuer: params.issuer\n          },\n          headers: this.headers,\n          jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n        });\n\n        if (error) {\n          return {\n            data: null,\n            error\n          };\n        }\n\n        if ((_b = data === null || data === void 0 ? void 0 : data.totp) === null || _b === void 0 ? void 0 : _b.qr_code) {\n          data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`;\n        }\n\n        return {\n          data,\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\r\n   * {@see GoTrueMFAApi#verify}\r\n   */\n\n\n  _verify(params) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          data: sessionData,\n          error: sessionError\n        } = yield this.getSession();\n\n        if (sessionError) {\n          return {\n            data: null,\n            error: sessionError\n          };\n        }\n\n        const {\n          data,\n          error\n        } = yield _request(this.fetch, 'POST', `${this.url}/factors/${params.factorId}/verify`, {\n          body: {\n            code: params.code,\n            challenge_id: params.challengeId\n          },\n          headers: this.headers,\n          jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n        });\n\n        if (error) {\n          return {\n            data: null,\n            error\n          };\n        }\n\n        yield this._saveSession(Object.assign({\n          expires_at: Math.round(Date.now() / 1000) + data.expires_in\n        }, data));\n\n        this._notifyAllSubscribers('MFA_CHALLENGE_VERIFIED', data);\n\n        return {\n          data,\n          error\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\r\n   * {@see GoTrueMFAApi#challenge}\r\n   */\n\n\n  _challenge(params) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          data: sessionData,\n          error: sessionError\n        } = yield this.getSession();\n\n        if (sessionError) {\n          return {\n            data: null,\n            error: sessionError\n          };\n        }\n\n        return yield _request(this.fetch, 'POST', `${this.url}/factors/${params.factorId}/challenge`, {\n          headers: this.headers,\n          jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\r\n   * {@see GoTrueMFAApi#challengeAndVerify}\r\n   */\n\n\n  _challengeAndVerify(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        data: challengeData,\n        error: challengeError\n      } = yield this._challenge({\n        factorId: params.factorId\n      });\n\n      if (challengeError) {\n        return {\n          data: null,\n          error: challengeError\n        };\n      }\n\n      return yield this._verify({\n        factorId: params.factorId,\n        challengeId: challengeData.id,\n        code: params.code\n      });\n    });\n  }\n  /**\r\n   * {@see GoTrueMFAApi#listFactors}\r\n   */\n\n\n  _listFactors() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        data: {\n          user\n        },\n        error: userError\n      } = yield this.getUser();\n\n      if (userError) {\n        return {\n          data: null,\n          error: userError\n        };\n      }\n\n      const factors = (user === null || user === void 0 ? void 0 : user.factors) || [];\n      const totp = factors.filter(factor => factor.factor_type === 'totp' && factor.status === 'verified');\n      return {\n        data: {\n          all: factors,\n          totp\n        },\n        error: null\n      };\n    });\n  }\n  /**\r\n   * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}\r\n   */\n\n\n  _getAuthenticatorAssuranceLevel() {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        data: {\n          session\n        },\n        error: sessionError\n      } = yield this.getSession();\n\n      if (sessionError) {\n        return {\n          data: null,\n          error: sessionError\n        };\n      }\n\n      if (!session) {\n        return {\n          data: {\n            currentLevel: null,\n            nextLevel: null,\n            currentAuthenticationMethods: []\n          },\n          error: null\n        };\n      }\n\n      const payload = this._decodeJWT(session.access_token);\n\n      let currentLevel = null;\n\n      if (payload.aal) {\n        currentLevel = payload.aal;\n      }\n\n      let nextLevel = currentLevel;\n      const verifiedFactors = (_b = (_a = session.user.factors) === null || _a === void 0 ? void 0 : _a.filter(factor => factor.status === 'verified')) !== null && _b !== void 0 ? _b : [];\n\n      if (verifiedFactors.length > 0) {\n        nextLevel = 'aal2';\n      }\n\n      const currentAuthenticationMethods = payload.amr || [];\n      return {\n        data: {\n          currentLevel,\n          nextLevel,\n          currentAuthenticationMethods\n        },\n        error: null\n      };\n    });\n  }\n\n}","map":{"version":3,"mappings":"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","names":["GoTrueAdminApi","DEFAULT_HEADERS","EXPIRY_MARGIN","GOTRUE_URL","STORAGE_KEY","AuthImplicitGrantRedirectError","AuthPKCEGrantCodeExchangeError","AuthInvalidCredentialsError","AuthRetryableFetchError","AuthSessionMissingError","AuthUnknownError","isAuthApiError","isAuthError","_request","_sessionResponse","_userResponse","_ssoResponse","decodeJWTPayload","Deferred","getItemAsync","getParameterByName","isBrowser","removeItemAsync","resolveFetch","setItemAsync","uuid","retryable","sleep","generatePKCEVerifier","generatePKCEChallenge","localStorageAdapter","polyfillGlobalThis","DEFAULT_OPTIONS","url","storageKey","autoRefreshToken","persistSession","detectSessionInUrl","headers","flowType","AUTO_REFRESH_TICK_DURATION","AUTO_REFRESH_TICK_THRESHOLD","GoTrueClient","constructor","options","Map","settings","inMemorySession","storage","admin","fetch","mfa","verify","_verify","bind","enroll","_enroll","unenroll","_unenroll","challenge","_challenge","listFactors","_listFactors","challengeAndVerify","_challengeAndVerify","getAuthenticatorAssuranceLevel","_getAuthenticatorAssuranceLevel","globalThis","BroadcastChannel","broadcastChannel","e","console","error","_a","addEventListener","event","_notifyAllSubscribers","data","session","initialize","initializePromise","_initialize","isPKCEFlow","_isPKCEFlow","_isImplicitGrantFlow","_getSessionFromUrl","_removeSession","redirectType","_saveSession","setTimeout","_recoverAndRefresh","_handleVisibilityChange","signUp","credentials","res","email","password","redirectTo","emailRedirectTo","body","gotrue_meta_security","captcha_token","captchaToken","xform","phone","_b","channel","_c","user","signInWithPassword","signInWithOAuth","_handleProviderSignIn","provider","scopes","queryParams","skipBrowserRedirect","_d","_e","exchangeCodeForSession","authCode","codeVerifier","auth_code","code_verifier","signInWithIdToken","token","nonce","id_token","signInWithOtp","create_user","shouldCreateUser","verifyOtp","params","Error","access_token","signInWithSSO","provider_id","providerId","domain","redirect_to","undefined","skip_http_redirect","getSession","currentSession","maybeSession","_isValidSession","hasExpired","expires_at","Date","now","_callRefreshToken","refresh_token","getUser","jwt","updateUser","attributes","sessionData","sessionError","userError","_decodeJWT","setSession","timeNow","expiresAt","payload","exp","refreshedSession","token_type","expires_in","refreshSession","error_description","error_code","code","provider_token","provider_refresh_token","Math","round","parseInt","window","location","hash","Boolean","currentStorageContent","signOut","accessToken","status","onAuthStateChange","callback","id","subscription","unsubscribe","stateChangeEmitters","delete","set","emitInitialSession","get","err","resetPasswordForEmail","_refreshAccessToken","refreshToken","startedAt","attempt","__awaiter","_","result","isValidSession","_getUrlForProvider","assign","Infinity","log","message","refreshingDeferred","promise","resolve","reject","broadcast","postMessage","forEach","x","_persistSession","_removeVisibilityChangedCallback","visibilityChangedCallback","removeEventListener","_startAutoRefresh","_stopAutoRefresh","ticker","setInterval","_autoRefreshTokenTick","autoRefreshTicker","unref","clearInterval","startAutoRefresh","stopAutoRefresh","expiresInTicks","floor","_onVisibilityChanged","isInitial","document","visibilityState","urlParams","encodeURIComponent","push","codeChallenge","flowParams","URLSearchParams","flow_type","code_challenge","code_challenge_method","toString","query","join","factorId","friendly_name","friendlyName","factor_type","factorType","issuer","totp","qr_code","challenge_id","challengeId","Object","challengeData","challengeError","factors","filter","factor","all","currentLevel","nextLevel","currentAuthenticationMethods","aal","verifiedFactors","length","amr"],"sources":["C:\\Users\\mumta\\crewmates\\client\\node_modules\\@supabase\\gotrue-js\\src\\GoTrueClient.ts"],"sourcesContent":["import GoTrueAdminApi from './GoTrueAdminApi'\r\nimport { DEFAULT_HEADERS, EXPIRY_MARGIN, GOTRUE_URL, STORAGE_KEY } from './lib/constants'\r\nimport {\r\n  AuthError,\r\n  AuthImplicitGrantRedirectError,\r\n  AuthPKCEGrantCodeExchangeError,\r\n  AuthInvalidCredentialsError,\r\n  AuthRetryableFetchError,\r\n  AuthSessionMissingError,\r\n  AuthUnknownError,\r\n  isAuthApiError,\r\n  isAuthError,\r\n} from './lib/errors'\r\nimport { Fetch, _request, _sessionResponse, _userResponse, _ssoResponse } from './lib/fetch'\r\nimport {\r\n  decodeJWTPayload,\r\n  Deferred,\r\n  getItemAsync,\r\n  getParameterByName,\r\n  isBrowser,\r\n  removeItemAsync,\r\n  resolveFetch,\r\n  setItemAsync,\r\n  uuid,\r\n  retryable,\r\n  sleep,\r\n  generatePKCEVerifier,\r\n  generatePKCEChallenge,\r\n} from './lib/helpers'\r\nimport localStorageAdapter from './lib/local-storage'\r\nimport { polyfillGlobalThis } from './lib/polyfills'\r\n\r\nimport type {\r\n  AuthChangeEvent,\r\n  AuthResponse,\r\n  CallRefreshTokenResult,\r\n  GoTrueClientOptions,\r\n  InitializeResult,\r\n  OAuthResponse,\r\n  SSOResponse,\r\n  Provider,\r\n  Session,\r\n  SignInWithIdTokenCredentials,\r\n  SignInWithOAuthCredentials,\r\n  SignInWithPasswordCredentials,\r\n  SignInWithPasswordlessCredentials,\r\n  SignUpWithPasswordCredentials,\r\n  SignInWithSSO,\r\n  Subscription,\r\n  SupportedStorage,\r\n  User,\r\n  UserAttributes,\r\n  UserResponse,\r\n  VerifyOtpParams,\r\n  GoTrueMFAApi,\r\n  MFAEnrollParams,\r\n  AuthMFAEnrollResponse,\r\n  MFAChallengeParams,\r\n  AuthMFAChallengeResponse,\r\n  MFAUnenrollParams,\r\n  AuthMFAUnenrollResponse,\r\n  MFAVerifyParams,\r\n  AuthMFAVerifyResponse,\r\n  AuthMFAListFactorsResponse,\r\n  AMREntry,\r\n  AuthMFAGetAuthenticatorAssuranceLevelResponse,\r\n  AuthenticatorAssuranceLevels,\r\n  Factor,\r\n  MFAChallengeAndVerifyParams,\r\n  AuthFlowType,\r\n} from './lib/types'\r\n\r\npolyfillGlobalThis() // Make \"globalThis\" available\r\n\r\nconst DEFAULT_OPTIONS: Omit<Required<GoTrueClientOptions>, 'fetch' | 'storage'> = {\r\n  url: GOTRUE_URL,\r\n  storageKey: STORAGE_KEY,\r\n  autoRefreshToken: true,\r\n  persistSession: true,\r\n  detectSessionInUrl: true,\r\n  headers: DEFAULT_HEADERS,\r\n  flowType: 'implicit',\r\n}\r\n\r\n/** Current session will be checked for refresh at this interval. */\r\nconst AUTO_REFRESH_TICK_DURATION = 10 * 1000\r\n\r\n/**\r\n * A token refresh will be attempted this many ticks before the current session expires. */\r\nconst AUTO_REFRESH_TICK_THRESHOLD = 3\r\n\r\nexport default class GoTrueClient {\r\n  /**\r\n   * Namespace for the GoTrue admin methods.\r\n   * These methods should only be used in a trusted server-side environment.\r\n   */\r\n  admin: GoTrueAdminApi\r\n  /**\r\n   * Namespace for the MFA methods.\r\n   */\r\n  mfa: GoTrueMFAApi\r\n  /**\r\n   * The storage key used to identify the values saved in localStorage\r\n   */\r\n  protected storageKey: string\r\n\r\n  /**\r\n   * The session object for the currently logged in user. If null, it means there isn't a logged-in user.\r\n   * Only used if persistSession is false.\r\n   */\r\n  protected inMemorySession: Session | null\r\n\r\n  protected flowType: AuthFlowType\r\n\r\n  protected autoRefreshToken: boolean\r\n  protected persistSession: boolean\r\n  protected storage: SupportedStorage\r\n  protected stateChangeEmitters: Map<string, Subscription> = new Map()\r\n  protected autoRefreshTicker: ReturnType<typeof setInterval> | null = null\r\n  protected visibilityChangedCallback: (() => Promise<any>) | null = null\r\n  protected refreshingDeferred: Deferred<CallRefreshTokenResult> | null = null\r\n  /**\r\n   * Keeps track of the async client initialization.\r\n   * When null or not yet resolved the auth state is `unknown`\r\n   * Once resolved the the auth state is known and it's save to call any further client methods.\r\n   * Keep extra care to never reject or throw uncaught errors\r\n   */\r\n  protected initializePromise: Promise<InitializeResult> | null = null\r\n  protected detectSessionInUrl = true\r\n  protected url: string\r\n  protected headers: {\r\n    [key: string]: string\r\n  }\r\n  protected fetch: Fetch\r\n\r\n  /**\r\n   * Used to broadcast state change events to other tabs listening.\r\n   */\r\n  protected broadcastChannel: BroadcastChannel | null = null\r\n\r\n  /**\r\n   * Create a new client for use in the browser.\r\n   */\r\n  constructor(options: GoTrueClientOptions) {\r\n    const settings = { ...DEFAULT_OPTIONS, ...options }\r\n    this.inMemorySession = null\r\n    this.storageKey = settings.storageKey\r\n    this.autoRefreshToken = settings.autoRefreshToken\r\n    this.persistSession = settings.persistSession\r\n    this.storage = settings.storage || localStorageAdapter\r\n    this.admin = new GoTrueAdminApi({\r\n      url: settings.url,\r\n      headers: settings.headers,\r\n      fetch: settings.fetch,\r\n    })\r\n\r\n    this.url = settings.url\r\n    this.headers = settings.headers\r\n    this.fetch = resolveFetch(settings.fetch)\r\n    this.detectSessionInUrl = settings.detectSessionInUrl\r\n    this.flowType = settings.flowType\r\n\r\n    this.mfa = {\r\n      verify: this._verify.bind(this),\r\n      enroll: this._enroll.bind(this),\r\n      unenroll: this._unenroll.bind(this),\r\n      challenge: this._challenge.bind(this),\r\n      listFactors: this._listFactors.bind(this),\r\n      challengeAndVerify: this._challengeAndVerify.bind(this),\r\n      getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this),\r\n    }\r\n\r\n    if (isBrowser() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {\r\n      try {\r\n        this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey)\r\n      } catch (e: any) {\r\n        console.error(\r\n          'Failed to create a new BroadcastChannel, multi-tab state changes will not be available',\r\n          e\r\n        )\r\n      }\r\n\r\n      this.broadcastChannel?.addEventListener('message', (event) => {\r\n        this._notifyAllSubscribers(event.data.event, event.data.session, false) // broadcast = false so we don't get an endless loop of messages\r\n      })\r\n    }\r\n\r\n    this.initialize()\r\n  }\r\n\r\n  /**\r\n   * Initializes the client session either from the url or from storage.\r\n   * This method is automatically called when instantiating the client, but should also be called\r\n   * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).\r\n   */\r\n  initialize(): Promise<InitializeResult> {\r\n    if (!this.initializePromise) {\r\n      this.initializePromise = this._initialize()\r\n    }\r\n\r\n    return this.initializePromise\r\n  }\r\n\r\n  /**\r\n   * IMPORTANT:\r\n   * 1. Never throw in this method, as it is called from the constructor\r\n   * 2. Never return a session from this method as it would be cached over\r\n   *    the whole lifetime of the client\r\n   */\r\n  private async _initialize(): Promise<InitializeResult> {\r\n    if (this.initializePromise) {\r\n      return this.initializePromise\r\n    }\r\n\r\n    try {\r\n      const isPKCEFlow = await this._isPKCEFlow()\r\n      if ((this.detectSessionInUrl && this._isImplicitGrantFlow()) || isPKCEFlow) {\r\n        const { data, error } = await this._getSessionFromUrl(isPKCEFlow)\r\n\r\n        if (error) {\r\n          // failed login attempt via url,\r\n          // remove old session as in verifyOtp, signUp and signInWith*\r\n          await this._removeSession()\r\n\r\n          return { error }\r\n        }\r\n\r\n        const { session, redirectType } = data\r\n\r\n        await this._saveSession(session)\r\n\r\n        setTimeout(() => {\r\n          if (redirectType === 'recovery') {\r\n            this._notifyAllSubscribers('PASSWORD_RECOVERY', session)\r\n          } else {\r\n            this._notifyAllSubscribers('SIGNED_IN', session)\r\n          }\r\n        }, 0)\r\n\r\n        return { error: null }\r\n      }\r\n\r\n      // no login attempt via callback url try to recover session from storage\r\n      await this._recoverAndRefresh()\r\n      return { error: null }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { error }\r\n      }\r\n\r\n      return {\r\n        error: new AuthUnknownError('Unexpected error during initialization', error),\r\n      }\r\n    } finally {\r\n      await this._handleVisibilityChange()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a new user.\r\n   *\r\n   * Be aware that if a user account exists in the system you may get back an\r\n   * error message that attempts to hide this information from the user.\r\n   *\r\n   * @returns A logged-in session if the server has \"autoconfirm\" ON\r\n   * @returns A user if the server has \"autoconfirm\" OFF\r\n   */\r\n  async signUp(credentials: SignUpWithPasswordCredentials): Promise<AuthResponse> {\r\n    try {\r\n      await this._removeSession()\r\n\r\n      let res: AuthResponse\r\n      if ('email' in credentials) {\r\n        const { email, password, options } = credentials\r\n        res = await _request(this.fetch, 'POST', `${this.url}/signup`, {\r\n          headers: this.headers,\r\n          redirectTo: options?.emailRedirectTo,\r\n          body: {\r\n            email,\r\n            password,\r\n            data: options?.data ?? {},\r\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\r\n          },\r\n          xform: _sessionResponse,\r\n        })\r\n      } else if ('phone' in credentials) {\r\n        const { phone, password, options } = credentials\r\n        res = await _request(this.fetch, 'POST', `${this.url}/signup`, {\r\n          headers: this.headers,\r\n          body: {\r\n            phone,\r\n            password,\r\n            data: options?.data ?? {},\r\n            channel: options?.channel ?? 'sms',\r\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\r\n          },\r\n          xform: _sessionResponse,\r\n        })\r\n      } else {\r\n        throw new AuthInvalidCredentialsError(\r\n          'You must provide either an email or phone number and a password'\r\n        )\r\n      }\r\n\r\n      const { data, error } = res\r\n\r\n      if (error || !data) {\r\n        return { data: { user: null, session: null }, error: error }\r\n      }\r\n\r\n      const session: Session | null = data.session\r\n      const user: User | null = data.user\r\n\r\n      if (data.session) {\r\n        await this._saveSession(data.session)\r\n        this._notifyAllSubscribers('SIGNED_IN', session)\r\n      }\r\n\r\n      return { data: { user, session }, error: null }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { user: null, session: null }, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Log in an existing user with an email and password or phone and password.\r\n   *\r\n   * Be aware that you may get back an error message that will not distinguish\r\n   * between the cases where the account does not exist or that the\r\n   * email/phone and password combination is wrong or that the account can only\r\n   * be accessed via social login.\r\n   */\r\n  async signInWithPassword(credentials: SignInWithPasswordCredentials): Promise<AuthResponse> {\r\n    try {\r\n      await this._removeSession()\r\n\r\n      let res: AuthResponse\r\n      if ('email' in credentials) {\r\n        const { email, password, options } = credentials\r\n        res = await _request(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\r\n          headers: this.headers,\r\n          body: {\r\n            email,\r\n            password,\r\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\r\n          },\r\n          xform: _sessionResponse,\r\n        })\r\n      } else if ('phone' in credentials) {\r\n        const { phone, password, options } = credentials\r\n        res = await _request(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\r\n          headers: this.headers,\r\n          body: {\r\n            phone,\r\n            password,\r\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\r\n          },\r\n          xform: _sessionResponse,\r\n        })\r\n      } else {\r\n        throw new AuthInvalidCredentialsError(\r\n          'You must provide either an email or phone number and a password'\r\n        )\r\n      }\r\n      const { data, error } = res\r\n      if (error || !data) return { data: { user: null, session: null }, error }\r\n      if (data.session) {\r\n        await this._saveSession(data.session)\r\n        this._notifyAllSubscribers('SIGNED_IN', data.session)\r\n      }\r\n      return { data, error }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { user: null, session: null }, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Log in an existing user via a third-party provider.\r\n   */\r\n  async signInWithOAuth(credentials: SignInWithOAuthCredentials): Promise<OAuthResponse> {\r\n    await this._removeSession()\r\n\r\n    return await this._handleProviderSignIn(credentials.provider, {\r\n      redirectTo: credentials.options?.redirectTo,\r\n      scopes: credentials.options?.scopes,\r\n      queryParams: credentials.options?.queryParams,\r\n      skipBrowserRedirect: credentials.options?.skipBrowserRedirect,\r\n      flowType: this.flowType ?? 'implicit',\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Log in an existing user via a third-party provider.\r\n   */\r\n  async exchangeCodeForSession(authCode: string): Promise<AuthResponse> {\r\n    const codeVerifier = await getItemAsync(this.storage, `${this.storageKey}-code-verifier`)\r\n    const { data, error } = await _request(\r\n      this.fetch,\r\n      'POST',\r\n      `${this.url}/token?grant_type=pkce`,\r\n      {\r\n        headers: this.headers,\r\n        body: {\r\n          auth_code: authCode,\r\n          code_verifier: codeVerifier,\r\n        },\r\n        xform: _sessionResponse,\r\n      }\r\n    )\r\n    await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`)\r\n    if (error || !data) return { data: { user: null, session: null }, error }\r\n    if (data.session) {\r\n      await this._saveSession(data.session)\r\n      this._notifyAllSubscribers('SIGNED_IN', data.session)\r\n    }\r\n    return { data, error }\r\n  }\r\n\r\n  /**\r\n   * Allows signing in with an ID token issued by certain supported providers.\r\n   * The ID token is verified for validity and a new session is established.\r\n   *\r\n   * @experimental\r\n   */\r\n  async signInWithIdToken(credentials: SignInWithIdTokenCredentials): Promise<AuthResponse> {\r\n    await this._removeSession()\r\n\r\n    try {\r\n      const { options, provider, token, nonce } = credentials\r\n\r\n      const res = await _request(this.fetch, 'POST', `${this.url}/token?grant_type=id_token`, {\r\n        headers: this.headers,\r\n        body: {\r\n          provider,\r\n          id_token: token,\r\n          nonce,\r\n          gotrue_meta_security: { captcha_token: options?.captchaToken },\r\n        },\r\n        xform: _sessionResponse,\r\n      })\r\n\r\n      const { data, error } = res\r\n      if (error || !data) return { data: { user: null, session: null }, error }\r\n      if (data.session) {\r\n        await this._saveSession(data.session)\r\n        this._notifyAllSubscribers('SIGNED_IN', data.session)\r\n      }\r\n      return { data, error }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { user: null, session: null }, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Log in a user using magiclink or a one-time password (OTP).\r\n   *\r\n   * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.\r\n   * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.\r\n   * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.\r\n   *\r\n   * Be aware that you may get back an error message that will not distinguish\r\n   * between the cases where the account does not exist or, that the account\r\n   * can only be accessed via social login.\r\n   *\r\n   * Do note that you will need to configure a Whatsapp sender on Twilio\r\n   * if you are using phone sign in with the 'whatsapp' channel. The whatsapp\r\n   * channel is not supported on other providers\r\n   * at this time.\r\n   */\r\n  async signInWithOtp(credentials: SignInWithPasswordlessCredentials): Promise<AuthResponse> {\r\n    try {\r\n      await this._removeSession()\r\n\r\n      if ('email' in credentials) {\r\n        const { email, options } = credentials\r\n        const { error } = await _request(this.fetch, 'POST', `${this.url}/otp`, {\r\n          headers: this.headers,\r\n          body: {\r\n            email,\r\n            data: options?.data ?? {},\r\n            create_user: options?.shouldCreateUser ?? true,\r\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\r\n          },\r\n          redirectTo: options?.emailRedirectTo,\r\n        })\r\n        return { data: { user: null, session: null }, error }\r\n      }\r\n      if ('phone' in credentials) {\r\n        const { phone, options } = credentials\r\n        const { error } = await _request(this.fetch, 'POST', `${this.url}/otp`, {\r\n          headers: this.headers,\r\n          body: {\r\n            phone,\r\n            data: options?.data ?? {},\r\n            create_user: options?.shouldCreateUser ?? true,\r\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\r\n            channel: options?.channel ?? 'sms',\r\n          },\r\n        })\r\n        return { data: { user: null, session: null }, error }\r\n      }\r\n      throw new AuthInvalidCredentialsError('You must provide either an email or phone number.')\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { user: null, session: null }, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Log in a user given a User supplied OTP received via mobile.\r\n   */\r\n  async verifyOtp(params: VerifyOtpParams): Promise<AuthResponse> {\r\n    try {\r\n      await this._removeSession()\r\n\r\n      const { data, error } = await _request(this.fetch, 'POST', `${this.url}/verify`, {\r\n        headers: this.headers,\r\n        body: {\r\n          ...params,\r\n          gotrue_meta_security: { captcha_token: params.options?.captchaToken },\r\n        },\r\n        redirectTo: params.options?.redirectTo,\r\n        xform: _sessionResponse,\r\n      })\r\n\r\n      if (error) {\r\n        throw error\r\n      }\r\n\r\n      if (!data) {\r\n        throw new Error('An error occurred on token verification.')\r\n      }\r\n\r\n      const session: Session | null = data.session\r\n      const user: User = data.user\r\n\r\n      if (session?.access_token) {\r\n        await this._saveSession(session as Session)\r\n        this._notifyAllSubscribers('SIGNED_IN', session)\r\n      }\r\n\r\n      return { data: { user, session }, error: null }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { user: null, session: null }, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Attempts a single-sign on using an enterprise Identity Provider. A\r\n   * successful SSO attempt will redirect the current page to the identity\r\n   * provider authorization page. The redirect URL is implementation and SSO\r\n   * protocol specific.\r\n   *\r\n   * You can use it by providing a SSO domain. Typically you can extract this\r\n   * domain by asking users for their email address. If this domain is\r\n   * registered on the Auth instance the redirect will use that organization's\r\n   * currently active SSO Identity Provider for the login.\r\n   *\r\n   * If you have built an organization-specific login page, you can use the\r\n   * organization's SSO Identity Provider UUID directly instead.\r\n   */\r\n  async signInWithSSO(params: SignInWithSSO): Promise<SSOResponse> {\r\n    try {\r\n      await this._removeSession()\r\n\r\n      return await _request(this.fetch, 'POST', `${this.url}/sso`, {\r\n        body: {\r\n          ...('providerId' in params ? { provider_id: params.providerId } : null),\r\n          ...('domain' in params ? { domain: params.domain } : null),\r\n          redirect_to: params.options?.redirectTo ?? undefined,\r\n          ...(params?.options?.captchaToken\r\n            ? { gotrue_meta_security: { captcha_token: params.options.captchaToken } }\r\n            : null),\r\n          skip_http_redirect: true, // fetch does not handle redirects\r\n        },\r\n        headers: this.headers,\r\n        xform: _ssoResponse,\r\n      })\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: null, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the session, refreshing it if necessary.\r\n   * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.\r\n   */\r\n  async getSession(): Promise<\r\n    | {\r\n        data: {\r\n          session: Session\r\n        }\r\n        error: null\r\n      }\r\n    | {\r\n        data: {\r\n          session: null\r\n        }\r\n        error: AuthError\r\n      }\r\n    | {\r\n        data: {\r\n          session: null\r\n        }\r\n        error: null\r\n      }\r\n  > {\r\n    // make sure we've read the session from the url if there is one\r\n    // save to just await, as long we make sure _initialize() never throws\r\n    await this.initializePromise\r\n\r\n    let currentSession: Session | null = null\r\n\r\n    if (this.persistSession) {\r\n      const maybeSession = await getItemAsync(this.storage, this.storageKey)\r\n\r\n      if (maybeSession !== null) {\r\n        if (this._isValidSession(maybeSession)) {\r\n          currentSession = maybeSession\r\n        } else {\r\n          await this._removeSession()\r\n        }\r\n      }\r\n    } else {\r\n      currentSession = this.inMemorySession\r\n    }\r\n\r\n    if (!currentSession) {\r\n      return { data: { session: null }, error: null }\r\n    }\r\n\r\n    const hasExpired = currentSession.expires_at\r\n      ? currentSession.expires_at <= Date.now() / 1000\r\n      : false\r\n    if (!hasExpired) {\r\n      return { data: { session: currentSession }, error: null }\r\n    }\r\n\r\n    const { session, error } = await this._callRefreshToken(currentSession.refresh_token)\r\n    if (error) {\r\n      return { data: { session: null }, error }\r\n    }\r\n\r\n    return { data: { session }, error: null }\r\n  }\r\n\r\n  /**\r\n   * Gets the current user details if there is an existing session.\r\n   * @param jwt Takes in an optional access token jwt. If no jwt is provided, getUser() will attempt to get the jwt from the current session.\r\n   */\r\n  async getUser(jwt?: string): Promise<UserResponse> {\r\n    try {\r\n      if (!jwt) {\r\n        const { data, error } = await this.getSession()\r\n        if (error) {\r\n          throw error\r\n        }\r\n\r\n        // Default to Authorization header if there is no existing session\r\n        jwt = data.session?.access_token ?? undefined\r\n      }\r\n\r\n      return await _request(this.fetch, 'GET', `${this.url}/user`, {\r\n        headers: this.headers,\r\n        jwt: jwt,\r\n        xform: _userResponse,\r\n      })\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { user: null }, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates user data for a logged in user.\r\n   */\r\n  async updateUser(\r\n    attributes: UserAttributes,\r\n    options: {\r\n      emailRedirectTo?: string | undefined\r\n    } = {}\r\n  ): Promise<UserResponse> {\r\n    try {\r\n      const { data: sessionData, error: sessionError } = await this.getSession()\r\n      if (sessionError) {\r\n        throw sessionError\r\n      }\r\n      if (!sessionData.session) {\r\n        throw new AuthSessionMissingError()\r\n      }\r\n      const session: Session = sessionData.session\r\n      const { data, error: userError } = await _request(this.fetch, 'PUT', `${this.url}/user`, {\r\n        headers: this.headers,\r\n        redirectTo: options?.emailRedirectTo,\r\n        body: attributes,\r\n        jwt: session.access_token,\r\n        xform: _userResponse,\r\n      })\r\n      if (userError) throw userError\r\n      session.user = data.user as User\r\n      await this._saveSession(session)\r\n      this._notifyAllSubscribers('USER_UPDATED', session)\r\n\r\n      return { data: { user: session.user }, error: null }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { user: null }, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Decodes a JWT (without performing any validation).\r\n   */\r\n  private _decodeJWT(jwt: string): {\r\n    exp?: number\r\n    aal?: AuthenticatorAssuranceLevels | null\r\n    amr?: AMREntry[] | null\r\n  } {\r\n    return decodeJWTPayload(jwt)\r\n  }\r\n\r\n  /**\r\n   * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.\r\n   * If the refresh token or access token in the current session is invalid, an error will be thrown.\r\n   * @param currentSession The current session that minimally contains an access token and refresh token.\r\n   */\r\n  async setSession(currentSession: {\r\n    access_token: string\r\n    refresh_token: string\r\n  }): Promise<AuthResponse> {\r\n    try {\r\n      if (!currentSession.access_token || !currentSession.refresh_token) {\r\n        throw new AuthSessionMissingError()\r\n      }\r\n\r\n      const timeNow = Date.now() / 1000\r\n      let expiresAt = timeNow\r\n      let hasExpired = true\r\n      let session: Session | null = null\r\n      const payload = decodeJWTPayload(currentSession.access_token)\r\n      if (payload.exp) {\r\n        expiresAt = payload.exp\r\n        hasExpired = expiresAt <= timeNow\r\n      }\r\n\r\n      if (hasExpired) {\r\n        const { session: refreshedSession, error } = await this._callRefreshToken(\r\n          currentSession.refresh_token\r\n        )\r\n        if (error) {\r\n          return { data: { user: null, session: null }, error: error }\r\n        }\r\n\r\n        if (!refreshedSession) {\r\n          return { data: { user: null, session: null }, error: null }\r\n        }\r\n        session = refreshedSession\r\n      } else {\r\n        const { data, error } = await this.getUser(currentSession.access_token)\r\n        if (error) {\r\n          throw error\r\n        }\r\n        session = {\r\n          access_token: currentSession.access_token,\r\n          refresh_token: currentSession.refresh_token,\r\n          user: data.user,\r\n          token_type: 'bearer',\r\n          expires_in: expiresAt - timeNow,\r\n          expires_at: expiresAt,\r\n        }\r\n        await this._saveSession(session)\r\n        this._notifyAllSubscribers('SIGNED_IN', session)\r\n      }\r\n\r\n      return { data: { user: session.user, session }, error: null }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { session: null, user: null }, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns a new session, regardless of expiry status.\r\n   * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().\r\n   * If the current session's refresh token is invalid, an error will be thrown.\r\n   * @param currentSession The current session. If passed in, it must contain a refresh token.\r\n   */\r\n  async refreshSession(currentSession?: { refresh_token: string }): Promise<AuthResponse> {\r\n    try {\r\n      if (!currentSession) {\r\n        const { data, error } = await this.getSession()\r\n        if (error) {\r\n          throw error\r\n        }\r\n\r\n        currentSession = data.session ?? undefined\r\n      }\r\n\r\n      if (!currentSession?.refresh_token) {\r\n        throw new AuthSessionMissingError()\r\n      }\r\n\r\n      const { session, error } = await this._callRefreshToken(currentSession.refresh_token)\r\n      if (error) {\r\n        return { data: { user: null, session: null }, error: error }\r\n      }\r\n\r\n      if (!session) {\r\n        return { data: { user: null, session: null }, error: null }\r\n      }\r\n\r\n      return { data: { user: session.user, session }, error: null }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { user: null, session: null }, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the session data from a URL string\r\n   */\r\n  private async _getSessionFromUrl(isPKCEFlow: boolean): Promise<\r\n    | {\r\n        data: { session: Session; redirectType: string | null }\r\n        error: null\r\n      }\r\n    | { data: { session: null; redirectType: null }; error: AuthError }\r\n  > {\r\n    try {\r\n      if (!isBrowser()) throw new AuthImplicitGrantRedirectError('No browser detected.')\r\n      if (this.flowType == 'implicit' && !this._isImplicitGrantFlow()) {\r\n        throw new AuthImplicitGrantRedirectError('Not a valid implicit grant flow url.')\r\n      } else if (this.flowType == 'pkce' && !isPKCEFlow) {\r\n        throw new AuthPKCEGrantCodeExchangeError('Not a valid PKCE flow url.')\r\n      }\r\n      if (isPKCEFlow) {\r\n        const authCode = getParameterByName('code')\r\n        if (!authCode) throw new AuthPKCEGrantCodeExchangeError('No code detected.')\r\n        const { data, error } = await this.exchangeCodeForSession(authCode)\r\n        if (error) throw error\r\n        if (!data.session) throw new AuthPKCEGrantCodeExchangeError('No session detected.')\r\n        return { data: { session: data.session, redirectType: null }, error: null }\r\n      }\r\n\r\n      const error_description = getParameterByName('error_description')\r\n      if (error_description) {\r\n        const error_code = getParameterByName('error_code')\r\n        if (!error_code) throw new AuthImplicitGrantRedirectError('No error_code detected.')\r\n        const error = getParameterByName('error')\r\n        if (!error) throw new AuthImplicitGrantRedirectError('No error detected.')\r\n\r\n        throw new AuthImplicitGrantRedirectError(error_description, { error, code: error_code })\r\n      }\r\n\r\n      const provider_token = getParameterByName('provider_token')\r\n      const provider_refresh_token = getParameterByName('provider_refresh_token')\r\n      const access_token = getParameterByName('access_token')\r\n      if (!access_token) throw new AuthImplicitGrantRedirectError('No access_token detected.')\r\n      const expires_in = getParameterByName('expires_in')\r\n      if (!expires_in) throw new AuthImplicitGrantRedirectError('No expires_in detected.')\r\n      const refresh_token = getParameterByName('refresh_token')\r\n      if (!refresh_token) throw new AuthImplicitGrantRedirectError('No refresh_token detected.')\r\n      const token_type = getParameterByName('token_type')\r\n      if (!token_type) throw new AuthImplicitGrantRedirectError('No token_type detected.')\r\n\r\n      const timeNow = Math.round(Date.now() / 1000)\r\n      const expires_at = timeNow + parseInt(expires_in)\r\n\r\n      const { data, error } = await this.getUser(access_token)\r\n      if (error) throw error\r\n      const user: User = data.user\r\n      const session: Session = {\r\n        provider_token,\r\n        provider_refresh_token,\r\n        access_token,\r\n        expires_in: parseInt(expires_in),\r\n        expires_at,\r\n        refresh_token,\r\n        token_type,\r\n        user,\r\n      }\r\n      const redirectType = getParameterByName('type')\r\n\r\n      // Remove tokens from URL\r\n      window.location.hash = ''\r\n\r\n      return { data: { session, redirectType }, error: null }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { session: null, redirectType: null }, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)\r\n   */\r\n  private _isImplicitGrantFlow(): boolean {\r\n    return (\r\n      isBrowser() &&\r\n      (Boolean(getParameterByName('access_token')) ||\r\n        Boolean(getParameterByName('error_description')))\r\n    )\r\n  }\r\n  /**\r\n   * Checks if the current URL and backing storage contain parameters given by a PKCE flow\r\n   */\r\n  private async _isPKCEFlow(): Promise<boolean> {\r\n    const currentStorageContent = await getItemAsync(\r\n      this.storage,\r\n      `${this.storageKey}-code-verifier`\r\n    )\r\n    return isBrowser() && Boolean(getParameterByName('code')) && Boolean(currentStorageContent)\r\n  }\r\n\r\n  /**\r\n   * Inside a browser context, `signOut()` will remove the logged in user from the browser session\r\n   * and log them out - removing all items from localstorage and then trigger a `\"SIGNED_OUT\"` event.\r\n   *\r\n   * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.\r\n   * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.\r\n   */\r\n  async signOut(): Promise<{ error: AuthError | null }> {\r\n    const { data, error: sessionError } = await this.getSession()\r\n    if (sessionError) {\r\n      return { error: sessionError }\r\n    }\r\n    const accessToken = data.session?.access_token\r\n    if (accessToken) {\r\n      const { error } = await this.admin.signOut(accessToken)\r\n      if (error) {\r\n        // ignore 404s since user might not exist anymore\r\n        // ignore 401s since an invalid or expired JWT should sign out the current session\r\n        if (!(isAuthApiError(error) && (error.status === 404 || error.status === 401))) {\r\n          return { error }\r\n        }\r\n      }\r\n    }\r\n    await this._removeSession()\r\n    this._notifyAllSubscribers('SIGNED_OUT', null)\r\n    return { error: null }\r\n  }\r\n\r\n  /**\r\n   * Receive a notification every time an auth event happens.\r\n   * @param callback A callback function to be invoked when an auth event happens.\r\n   */\r\n  onAuthStateChange(callback: (event: AuthChangeEvent, session: Session | null) => void): {\r\n    data: { subscription: Subscription }\r\n  } {\r\n    const id: string = uuid()\r\n    const subscription: Subscription = {\r\n      id,\r\n      callback,\r\n      unsubscribe: () => {\r\n        this.stateChangeEmitters.delete(id)\r\n      },\r\n    }\r\n\r\n    this.stateChangeEmitters.set(id, subscription)\r\n\r\n    this.emitInitialSession(id)\r\n\r\n    return { data: { subscription } }\r\n  }\r\n\r\n  private async emitInitialSession(id: string): Promise<void> {\r\n    try {\r\n      const {\r\n        data: { session },\r\n        error,\r\n      } = await this.getSession()\r\n      if (error) throw error\r\n\r\n      this.stateChangeEmitters.get(id)?.callback('INITIAL_SESSION', session)\r\n    } catch (err) {\r\n      this.stateChangeEmitters.get(id)?.callback('INITIAL_SESSION', null)\r\n      console.error(err)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sends a password reset request to an email address.\r\n   * @param email The email address of the user.\r\n   * @param options.redirectTo The URL to send the user to after they click the password reset link.\r\n   * @param options.captchaToken Verification token received when the user completes the captcha on the site.\r\n   */\r\n  async resetPasswordForEmail(\r\n    email: string,\r\n    options: {\r\n      redirectTo?: string\r\n      captchaToken?: string\r\n    } = {}\r\n  ): Promise<\r\n    | {\r\n        data: {}\r\n        error: null\r\n      }\r\n    | { data: null; error: AuthError }\r\n  > {\r\n    try {\r\n      return await _request(this.fetch, 'POST', `${this.url}/recover`, {\r\n        body: { email, gotrue_meta_security: { captcha_token: options.captchaToken } },\r\n        headers: this.headers,\r\n        redirectTo: options.redirectTo,\r\n      })\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: null, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generates a new JWT.\r\n   * @param refreshToken A valid refresh token that was returned on login.\r\n   */\r\n  private async _refreshAccessToken(refreshToken: string): Promise<AuthResponse> {\r\n    try {\r\n      const startedAt = Date.now()\r\n\r\n      // will attempt to refresh the token with exponential backoff\r\n      return await retryable(\r\n        async (attempt) => {\r\n          await sleep(attempt * 200) // 0, 200, 400, 800, ...\r\n\r\n          return await _request(this.fetch, 'POST', `${this.url}/token?grant_type=refresh_token`, {\r\n            body: { refresh_token: refreshToken },\r\n            headers: this.headers,\r\n            xform: _sessionResponse,\r\n          })\r\n        },\r\n        (attempt, _, result) =>\r\n          result &&\r\n          result.error &&\r\n          result.error instanceof AuthRetryableFetchError &&\r\n          // retryable only if the request can be sent before the backoff overflows the tick duration\r\n          Date.now() + (attempt + 1) * 200 - startedAt < AUTO_REFRESH_TICK_DURATION\r\n      )\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { session: null, user: null }, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  private _isValidSession(maybeSession: unknown): maybeSession is Session {\r\n    const isValidSession =\r\n      typeof maybeSession === 'object' &&\r\n      maybeSession !== null &&\r\n      'access_token' in maybeSession &&\r\n      'refresh_token' in maybeSession &&\r\n      'expires_at' in maybeSession\r\n\r\n    return isValidSession\r\n  }\r\n\r\n  private async _handleProviderSignIn(\r\n    provider: Provider,\r\n    options: {\r\n      redirectTo?: string\r\n      scopes?: string\r\n      queryParams?: { [key: string]: string }\r\n      skipBrowserRedirect?: boolean\r\n      flowType: AuthFlowType\r\n    }\r\n  ) {\r\n    const url: string = await this._getUrlForProvider(provider, {\r\n      redirectTo: options.redirectTo,\r\n      scopes: options.scopes,\r\n      queryParams: options.queryParams,\r\n      flowType: options.flowType,\r\n    })\r\n    // try to open on the browser\r\n    if (isBrowser() && !options.skipBrowserRedirect) {\r\n      window.location.assign(url)\r\n    }\r\n\r\n    return { data: { provider, url }, error: null }\r\n  }\r\n\r\n  /**\r\n   * Recovers the session from LocalStorage and refreshes\r\n   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\r\n   */\r\n  private async _recoverAndRefresh() {\r\n    try {\r\n      const currentSession = await getItemAsync(this.storage, this.storageKey)\r\n      if (!this._isValidSession(currentSession)) {\r\n        if (currentSession !== null) {\r\n          await this._removeSession()\r\n        }\r\n\r\n        return\r\n      }\r\n\r\n      const timeNow = Math.round(Date.now() / 1000)\r\n\r\n      if ((currentSession.expires_at ?? Infinity) < timeNow + EXPIRY_MARGIN) {\r\n        if (this.autoRefreshToken && currentSession.refresh_token) {\r\n          const { error } = await this._callRefreshToken(currentSession.refresh_token)\r\n\r\n          if (error) {\r\n            console.log(error.message)\r\n            await this._removeSession()\r\n          }\r\n        } else {\r\n          await this._removeSession()\r\n        }\r\n      } else {\r\n        if (this.persistSession) {\r\n          await this._saveSession(currentSession)\r\n        }\r\n        this._notifyAllSubscribers('SIGNED_IN', currentSession)\r\n      }\r\n    } catch (err) {\r\n      console.error(err)\r\n      return\r\n    }\r\n  }\r\n\r\n  private async _callRefreshToken(refreshToken: string): Promise<CallRefreshTokenResult> {\r\n    // refreshing is already in progress\r\n    if (this.refreshingDeferred) {\r\n      return this.refreshingDeferred.promise\r\n    }\r\n\r\n    try {\r\n      this.refreshingDeferred = new Deferred<CallRefreshTokenResult>()\r\n\r\n      if (!refreshToken) {\r\n        throw new AuthSessionMissingError()\r\n      }\r\n      const { data, error } = await this._refreshAccessToken(refreshToken)\r\n      if (error) throw error\r\n      if (!data.session) throw new AuthSessionMissingError()\r\n\r\n      await this._saveSession(data.session)\r\n      this._notifyAllSubscribers('TOKEN_REFRESHED', data.session)\r\n\r\n      const result = { session: data.session, error: null }\r\n\r\n      this.refreshingDeferred.resolve(result)\r\n\r\n      return result\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        const result = { session: null, error }\r\n\r\n        this.refreshingDeferred?.resolve(result)\r\n\r\n        return result\r\n      }\r\n\r\n      this.refreshingDeferred?.reject(error)\r\n      throw error\r\n    } finally {\r\n      this.refreshingDeferred = null\r\n    }\r\n  }\r\n\r\n  private _notifyAllSubscribers(event: AuthChangeEvent, session: Session | null, broadcast = true) {\r\n    if (this.broadcastChannel && broadcast) {\r\n      this.broadcastChannel.postMessage({ event, session })\r\n    }\r\n\r\n    this.stateChangeEmitters.forEach((x) => x.callback(event, session))\r\n  }\r\n\r\n  /**\r\n   * set currentSession and currentUser\r\n   * process to _startAutoRefreshToken if possible\r\n   */\r\n  private async _saveSession(session: Session) {\r\n    if (!this.persistSession) {\r\n      this.inMemorySession = session\r\n    }\r\n\r\n    if (this.persistSession && session.expires_at) {\r\n      await this._persistSession(session)\r\n    }\r\n  }\r\n\r\n  private _persistSession(currentSession: Session) {\r\n    return setItemAsync(this.storage, this.storageKey, currentSession)\r\n  }\r\n\r\n  private async _removeSession() {\r\n    if (this.persistSession) {\r\n      await removeItemAsync(this.storage, this.storageKey)\r\n    } else {\r\n      this.inMemorySession = null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes any registered visibilitychange callback.\r\n   *\r\n   * {@see #startAutoRefresh}\r\n   * {@see #stopAutoRefresh}\r\n   */\r\n  private _removeVisibilityChangedCallback() {\r\n    const callback = this.visibilityChangedCallback\r\n    this.visibilityChangedCallback = null\r\n\r\n    try {\r\n      if (callback && isBrowser() && window?.removeEventListener) {\r\n        window.removeEventListener('visibilitychange', callback)\r\n      }\r\n    } catch (e) {\r\n      console.error('removing visibilitychange callback failed', e)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This is the private implementation of {@link #startAutoRefresh}. Use this\r\n   * within the library.\r\n   */\r\n  private async _startAutoRefresh() {\r\n    await this._stopAutoRefresh()\r\n\r\n    const ticker = setInterval(() => this._autoRefreshTokenTick(), AUTO_REFRESH_TICK_DURATION)\r\n    this.autoRefreshTicker = ticker\r\n\r\n    if (ticker && typeof ticker === 'object' && typeof ticker.unref === 'function') {\r\n      // ticker is a NodeJS Timeout object that has an `unref` method\r\n      // https://nodejs.org/api/timers.html#timeoutunref\r\n      // When auto refresh is used in NodeJS (like for testing) the\r\n      // `setInterval` is preventing the process from being marked as\r\n      // finished and tests run endlessly. This can be prevented by calling\r\n      // `unref()` on the returned object.\r\n      ticker.unref()\r\n    }\r\n\r\n    // run the tick immediately\r\n    await this._autoRefreshTokenTick()\r\n  }\r\n\r\n  /**\r\n   * This is the private implementation of {@link #stopAutoRefresh}. Use this\r\n   * within the library.\r\n   */\r\n  private async _stopAutoRefresh() {\r\n    const ticker = this.autoRefreshTicker\r\n    this.autoRefreshTicker = null\r\n\r\n    if (ticker) {\r\n      clearInterval(ticker)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Starts an auto-refresh process in the background. The session is checked\r\n   * every few seconds. Close to the time of expiration a process is started to\r\n   * refresh the session. If refreshing fails it will be retried for as long as\r\n   * necessary.\r\n   *\r\n   * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need\r\n   * to call this function, it will be called for you.\r\n   *\r\n   * On browsers the refresh process works only when the tab/window is in the\r\n   * foreground to conserve resources as well as prevent race conditions and\r\n   * flooding auth with requests. If you call this method any managed\r\n   * visibility change callback will be removed and you must manage visibility\r\n   * changes on your own.\r\n   *\r\n   * On non-browser platforms the refresh process works *continuously* in the\r\n   * background, which may not be desireable. You should hook into your\r\n   * platform's foreground indication mechanism and call these methods\r\n   * appropriately to conserve resources.\r\n   *\r\n   * {@see #stopAutoRefresh}\r\n   */\r\n  async startAutoRefresh() {\r\n    this._removeVisibilityChangedCallback()\r\n    await this._startAutoRefresh()\r\n  }\r\n\r\n  /**\r\n   * Stops an active auto refresh process running in the background (if any).\r\n   *\r\n   * If you call this method any managed visibility change callback will be\r\n   * removed and you must manage visibility changes on your own.\r\n   *\r\n   * See {@link #startAutoRefresh} for more details.\r\n   */\r\n  async stopAutoRefresh() {\r\n    this._removeVisibilityChangedCallback()\r\n    await this._stopAutoRefresh()\r\n  }\r\n\r\n  /**\r\n   * Runs the auto refresh token tick.\r\n   */\r\n  private async _autoRefreshTokenTick() {\r\n    const now = Date.now()\r\n\r\n    try {\r\n      const {\r\n        data: { session },\r\n      } = await this.getSession()\r\n\r\n      if (!session || !session.refresh_token || !session.expires_at) {\r\n        return\r\n      }\r\n\r\n      // session will expire in this many ticks (or has already expired if <= 0)\r\n      const expiresInTicks = Math.floor(\r\n        (session.expires_at * 1000 - now) / AUTO_REFRESH_TICK_DURATION\r\n      )\r\n\r\n      if (expiresInTicks < AUTO_REFRESH_TICK_THRESHOLD) {\r\n        await this._callRefreshToken(session.refresh_token)\r\n      }\r\n    } catch (e: any) {\r\n      console.error('Auto refresh tick failed with error. This is likely a transient error.', e)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Registers callbacks on the browser / platform, which in-turn run\r\n   * algorithms when the browser window/tab are in foreground. On non-browser\r\n   * platforms it assumes always foreground.\r\n   */\r\n  private async _handleVisibilityChange() {\r\n    if (!isBrowser() || !window?.addEventListener) {\r\n      if (this.autoRefreshToken) {\r\n        // in non-browser environments the refresh token ticker runs always\r\n        this.startAutoRefresh()\r\n      }\r\n\r\n      return false\r\n    }\r\n\r\n    try {\r\n      this.visibilityChangedCallback = async () => await this._onVisibilityChanged(false)\r\n\r\n      window?.addEventListener('visibilitychange', this.visibilityChangedCallback)\r\n\r\n      // now immediately call the visbility changed callback to setup with the\r\n      // current visbility state\r\n      await this._onVisibilityChanged(true) // initial call\r\n    } catch (error) {\r\n      console.error('_handleVisibilityChange', error)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Callback registered with `window.addEventListener('visibilitychange')`.\r\n   */\r\n  private async _onVisibilityChanged(isInitial: boolean) {\r\n    if (document.visibilityState === 'visible') {\r\n      if (!isInitial) {\r\n        // initial visibility change setup is handled in another flow under #initialize()\r\n        await this.initializePromise\r\n        await this._recoverAndRefresh()\r\n      }\r\n\r\n      if (this.autoRefreshToken) {\r\n        // in browser environments the refresh token ticker runs only on focused tabs\r\n        // which prevents race conditions\r\n        this._startAutoRefresh()\r\n      }\r\n    } else if (document.visibilityState === 'hidden') {\r\n      if (this.autoRefreshToken) {\r\n        this._stopAutoRefresh()\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generates the relevant login URL for a third-party provider.\r\n   * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.\r\n   * @param options.scopes A space-separated list of scopes granted to the OAuth application.\r\n   * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.\r\n   * @param options.flowType OAuth flow to use - defaults to implicit flow. PKCE is recommended for mobile and server-side applications.\r\n   */\r\n  private async _getUrlForProvider(\r\n    provider: Provider,\r\n    options: {\r\n      redirectTo?: string\r\n      scopes?: string\r\n      queryParams?: { [key: string]: string }\r\n      flowType: AuthFlowType\r\n    }\r\n  ) {\r\n    const urlParams: string[] = [`provider=${encodeURIComponent(provider)}`]\r\n    if (options?.redirectTo) {\r\n      urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`)\r\n    }\r\n    if (options?.scopes) {\r\n      urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`)\r\n    }\r\n    if (options?.flowType === 'pkce') {\r\n      const codeVerifier = generatePKCEVerifier()\r\n      await setItemAsync(this.storage, `${this.storageKey}-code-verifier`, codeVerifier)\r\n      const codeChallenge = await generatePKCEChallenge(codeVerifier)\r\n      const flowParams = new URLSearchParams({\r\n        flow_type: `${encodeURIComponent(options.flowType)}`,\r\n        code_challenge: `${encodeURIComponent(codeChallenge)}`,\r\n        code_challenge_method: `${encodeURIComponent('s256')}`,\r\n      })\r\n      urlParams.push(flowParams.toString())\r\n    }\r\n    if (options?.queryParams) {\r\n      const query = new URLSearchParams(options.queryParams)\r\n      urlParams.push(query.toString())\r\n    }\r\n\r\n    return `${this.url}/authorize?${urlParams.join('&')}`\r\n  }\r\n\r\n  private async _unenroll(params: MFAUnenrollParams): Promise<AuthMFAUnenrollResponse> {\r\n    try {\r\n      const { data: sessionData, error: sessionError } = await this.getSession()\r\n      if (sessionError) {\r\n        return { data: null, error: sessionError }\r\n      }\r\n\r\n      return await _request(this.fetch, 'DELETE', `${this.url}/factors/${params.factorId}`, {\r\n        headers: this.headers,\r\n        jwt: sessionData?.session?.access_token,\r\n      })\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: null, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * {@see GoTrueMFAApi#enroll}\r\n   */\r\n  private async _enroll(params: MFAEnrollParams): Promise<AuthMFAEnrollResponse> {\r\n    try {\r\n      const { data: sessionData, error: sessionError } = await this.getSession()\r\n      if (sessionError) {\r\n        return { data: null, error: sessionError }\r\n      }\r\n\r\n      const { data, error } = await _request(this.fetch, 'POST', `${this.url}/factors`, {\r\n        body: {\r\n          friendly_name: params.friendlyName,\r\n          factor_type: params.factorType,\r\n          issuer: params.issuer,\r\n        },\r\n        headers: this.headers,\r\n        jwt: sessionData?.session?.access_token,\r\n      })\r\n\r\n      if (error) {\r\n        return { data: null, error }\r\n      }\r\n\r\n      if (data?.totp?.qr_code) {\r\n        data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`\r\n      }\r\n\r\n      return { data, error: null }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: null, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * {@see GoTrueMFAApi#verify}\r\n   */\r\n  private async _verify(params: MFAVerifyParams): Promise<AuthMFAVerifyResponse> {\r\n    try {\r\n      const { data: sessionData, error: sessionError } = await this.getSession()\r\n      if (sessionError) {\r\n        return { data: null, error: sessionError }\r\n      }\r\n\r\n      const { data, error } = await _request(\r\n        this.fetch,\r\n        'POST',\r\n        `${this.url}/factors/${params.factorId}/verify`,\r\n        {\r\n          body: { code: params.code, challenge_id: params.challengeId },\r\n          headers: this.headers,\r\n          jwt: sessionData?.session?.access_token,\r\n        }\r\n      )\r\n      if (error) {\r\n        return { data: null, error }\r\n      }\r\n\r\n      await this._saveSession({\r\n        expires_at: Math.round(Date.now() / 1000) + data.expires_in,\r\n        ...data,\r\n      })\r\n      this._notifyAllSubscribers('MFA_CHALLENGE_VERIFIED', data)\r\n\r\n      return { data, error }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: null, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * {@see GoTrueMFAApi#challenge}\r\n   */\r\n  private async _challenge(params: MFAChallengeParams): Promise<AuthMFAChallengeResponse> {\r\n    try {\r\n      const { data: sessionData, error: sessionError } = await this.getSession()\r\n      if (sessionError) {\r\n        return { data: null, error: sessionError }\r\n      }\r\n\r\n      return await _request(\r\n        this.fetch,\r\n        'POST',\r\n        `${this.url}/factors/${params.factorId}/challenge`,\r\n        {\r\n          headers: this.headers,\r\n          jwt: sessionData?.session?.access_token,\r\n        }\r\n      )\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: null, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * {@see GoTrueMFAApi#challengeAndVerify}\r\n   */\r\n  private async _challengeAndVerify(\r\n    params: MFAChallengeAndVerifyParams\r\n  ): Promise<AuthMFAVerifyResponse> {\r\n    const { data: challengeData, error: challengeError } = await this._challenge({\r\n      factorId: params.factorId,\r\n    })\r\n    if (challengeError) {\r\n      return { data: null, error: challengeError }\r\n    }\r\n    return await this._verify({\r\n      factorId: params.factorId,\r\n      challengeId: challengeData.id,\r\n      code: params.code,\r\n    })\r\n  }\r\n\r\n  /**\r\n   * {@see GoTrueMFAApi#listFactors}\r\n   */\r\n  private async _listFactors(): Promise<AuthMFAListFactorsResponse> {\r\n    const {\r\n      data: { user },\r\n      error: userError,\r\n    } = await this.getUser()\r\n    if (userError) {\r\n      return { data: null, error: userError }\r\n    }\r\n\r\n    const factors = user?.factors || []\r\n    const totp = factors.filter(\r\n      (factor) => factor.factor_type === 'totp' && factor.status === 'verified'\r\n    )\r\n\r\n    return {\r\n      data: {\r\n        all: factors,\r\n        totp,\r\n      },\r\n      error: null,\r\n    }\r\n  }\r\n\r\n  /**\r\n   * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}\r\n   */\r\n  private async _getAuthenticatorAssuranceLevel(): Promise<AuthMFAGetAuthenticatorAssuranceLevelResponse> {\r\n    const {\r\n      data: { session },\r\n      error: sessionError,\r\n    } = await this.getSession()\r\n    if (sessionError) {\r\n      return { data: null, error: sessionError }\r\n    }\r\n    if (!session) {\r\n      return {\r\n        data: { currentLevel: null, nextLevel: null, currentAuthenticationMethods: [] },\r\n        error: null,\r\n      }\r\n    }\r\n\r\n    const payload = this._decodeJWT(session.access_token)\r\n\r\n    let currentLevel: AuthenticatorAssuranceLevels | null = null\r\n\r\n    if (payload.aal) {\r\n      currentLevel = payload.aal\r\n    }\r\n\r\n    let nextLevel: AuthenticatorAssuranceLevels | null = currentLevel\r\n\r\n    const verifiedFactors =\r\n      session.user.factors?.filter((factor: Factor) => factor.status === 'verified') ?? []\r\n\r\n    if (verifiedFactors.length > 0) {\r\n      nextLevel = 'aal2'\r\n    }\r\n\r\n    const currentAuthenticationMethods = payload.amr || []\r\n\r\n    return { data: { currentLevel, nextLevel, currentAuthenticationMethods }, error: null }\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}