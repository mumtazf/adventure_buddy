{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/mumta/crewmates/client/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"C:/Users/mumta/crewmates/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/mumta/crewmates/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport GoTrueAdminApi from './GoTrueAdminApi';\nimport { DEFAULT_HEADERS, EXPIRY_MARGIN, GOTRUE_URL, STORAGE_KEY } from './lib/constants';\nimport { AuthImplicitGrantRedirectError, AuthPKCEGrantCodeExchangeError, AuthInvalidCredentialsError, AuthRetryableFetchError, AuthSessionMissingError, AuthUnknownError, isAuthApiError, isAuthError } from './lib/errors';\nimport { _request, _sessionResponse, _userResponse, _ssoResponse } from './lib/fetch';\nimport { decodeJWTPayload, Deferred, getItemAsync, getParameterByName, isBrowser, removeItemAsync, resolveFetch, setItemAsync, uuid, retryable, sleep, generatePKCEVerifier, generatePKCEChallenge } from './lib/helpers';\nimport localStorageAdapter from './lib/local-storage';\nimport { polyfillGlobalThis } from './lib/polyfills';\npolyfillGlobalThis(); // Make \"globalThis\" available\n\nvar DEFAULT_OPTIONS = {\n  url: GOTRUE_URL,\n  storageKey: STORAGE_KEY,\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  headers: DEFAULT_HEADERS,\n  flowType: 'implicit'\n};\n/** Current session will be checked for refresh at this interval. */\n\nvar AUTO_REFRESH_TICK_DURATION = 10 * 1000;\n/**\r\n * A token refresh will be attempted this many ticks before the current session expires. */\n\nvar AUTO_REFRESH_TICK_THRESHOLD = 3;\n\nvar GoTrueClient = /*#__PURE__*/function () {\n  /**\r\n   * Create a new client for use in the browser.\r\n   */\n  function GoTrueClient(options) {\n    var _this = this;\n\n    _classCallCheck(this, GoTrueClient);\n\n    var _a;\n\n    this.stateChangeEmitters = new Map();\n    this.autoRefreshTicker = null;\n    this.visibilityChangedCallback = null;\n    this.refreshingDeferred = null;\n    /**\r\n     * Keeps track of the async client initialization.\r\n     * When null or not yet resolved the auth state is `unknown`\r\n     * Once resolved the the auth state is known and it's save to call any further client methods.\r\n     * Keep extra care to never reject or throw uncaught errors\r\n     */\n\n    this.initializePromise = null;\n    this.detectSessionInUrl = true;\n    /**\r\n     * Used to broadcast state change events to other tabs listening.\r\n     */\n\n    this.broadcastChannel = null;\n    var settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n    this.inMemorySession = null;\n    this.storageKey = settings.storageKey;\n    this.autoRefreshToken = settings.autoRefreshToken;\n    this.persistSession = settings.persistSession;\n    this.storage = settings.storage || localStorageAdapter;\n    this.admin = new GoTrueAdminApi({\n      url: settings.url,\n      headers: settings.headers,\n      fetch: settings.fetch\n    });\n    this.url = settings.url;\n    this.headers = settings.headers;\n    this.fetch = resolveFetch(settings.fetch);\n    this.detectSessionInUrl = settings.detectSessionInUrl;\n    this.flowType = settings.flowType;\n    this.mfa = {\n      verify: this._verify.bind(this),\n      enroll: this._enroll.bind(this),\n      unenroll: this._unenroll.bind(this),\n      challenge: this._challenge.bind(this),\n      listFactors: this._listFactors.bind(this),\n      challengeAndVerify: this._challengeAndVerify.bind(this),\n      getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this)\n    };\n\n    if (isBrowser() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {\n      try {\n        this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey);\n      } catch (e) {\n        console.error('Failed to create a new BroadcastChannel, multi-tab state changes will not be available', e);\n      }\n\n      (_a = this.broadcastChannel) === null || _a === void 0 ? void 0 : _a.addEventListener('message', function (event) {\n        _this._notifyAllSubscribers(event.data.event, event.data.session, false); // broadcast = false so we don't get an endless loop of messages\n\n      });\n    }\n\n    this.initialize();\n  }\n  /**\r\n   * Initializes the client session either from the url or from storage.\r\n   * This method is automatically called when instantiating the client, but should also be called\r\n   * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).\r\n   */\n\n\n  _createClass(GoTrueClient, [{\n    key: \"initialize\",\n    value: function initialize() {\n      if (!this.initializePromise) {\n        this.initializePromise = this._initialize();\n      }\n\n      return this.initializePromise;\n    }\n    /**\r\n     * IMPORTANT:\r\n     * 1. Never throw in this method, as it is called from the constructor\r\n     * 2. Never return a session from this method as it would be cached over\r\n     *    the whole lifetime of the client\r\n     */\n\n  }, {\n    key: \"_initialize\",\n    value: function _initialize() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _this2 = this;\n\n        var isPKCEFlow, _yield$this$_getSessi, data, error, session, redirectType;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this.initializePromise) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", this.initializePromise);\n\n              case 2:\n                _context.prev = 2;\n                _context.next = 5;\n                return this._isPKCEFlow();\n\n              case 5:\n                isPKCEFlow = _context.sent;\n\n                if (!(this.detectSessionInUrl && this._isImplicitGrantFlow() || isPKCEFlow)) {\n                  _context.next = 21;\n                  break;\n                }\n\n                _context.next = 9;\n                return this._getSessionFromUrl(isPKCEFlow);\n\n              case 9:\n                _yield$this$_getSessi = _context.sent;\n                data = _yield$this$_getSessi.data;\n                error = _yield$this$_getSessi.error;\n\n                if (!error) {\n                  _context.next = 16;\n                  break;\n                }\n\n                _context.next = 15;\n                return this._removeSession();\n\n              case 15:\n                return _context.abrupt(\"return\", {\n                  error: error\n                });\n\n              case 16:\n                session = data.session, redirectType = data.redirectType;\n                _context.next = 19;\n                return this._saveSession(session);\n\n              case 19:\n                setTimeout(function () {\n                  if (redirectType === 'recovery') {\n                    _this2._notifyAllSubscribers('PASSWORD_RECOVERY', session);\n                  } else {\n                    _this2._notifyAllSubscribers('SIGNED_IN', session);\n                  }\n                }, 0);\n                return _context.abrupt(\"return\", {\n                  error: null\n                });\n\n              case 21:\n                _context.next = 23;\n                return this._recoverAndRefresh();\n\n              case 23:\n                return _context.abrupt(\"return\", {\n                  error: null\n                });\n\n              case 26:\n                _context.prev = 26;\n                _context.t0 = _context[\"catch\"](2);\n\n                if (!isAuthError(_context.t0)) {\n                  _context.next = 30;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", {\n                  error: _context.t0\n                });\n\n              case 30:\n                return _context.abrupt(\"return\", {\n                  error: new AuthUnknownError('Unexpected error during initialization', _context.t0)\n                });\n\n              case 31:\n                _context.prev = 31;\n                _context.next = 34;\n                return this._handleVisibilityChange();\n\n              case 34:\n                return _context.finish(31);\n\n              case 35:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[2, 26, 31, 35]]);\n      }));\n    }\n    /**\r\n     * Creates a new user.\r\n     *\r\n     * Be aware that if a user account exists in the system you may get back an\r\n     * error message that attempts to hide this information from the user.\r\n     *\r\n     * @returns A logged-in session if the server has \"autoconfirm\" ON\r\n     * @returns A user if the server has \"autoconfirm\" OFF\r\n     */\n\n  }, {\n    key: \"signUp\",\n    value: function signUp(credentials) {\n      var _a, _b, _c;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var res, email, password, options, phone, _password, _options, _res, data, error, session, user;\n\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n                _context2.next = 3;\n                return this._removeSession();\n\n              case 3:\n                if (!('email' in credentials)) {\n                  _context2.next = 10;\n                  break;\n                }\n\n                email = credentials.email, password = credentials.password, options = credentials.options;\n                _context2.next = 7;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/signup\"), {\n                  headers: this.headers,\n                  redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n                  body: {\n                    email: email,\n                    password: password,\n                    data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n                    gotrue_meta_security: {\n                      captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                    }\n                  },\n                  xform: _sessionResponse\n                });\n\n              case 7:\n                res = _context2.sent;\n                _context2.next = 18;\n                break;\n\n              case 10:\n                if (!('phone' in credentials)) {\n                  _context2.next = 17;\n                  break;\n                }\n\n                phone = credentials.phone, _password = credentials.password, _options = credentials.options;\n                _context2.next = 14;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/signup\"), {\n                  headers: this.headers,\n                  body: {\n                    phone: phone,\n                    password: _password,\n                    data: (_b = _options === null || _options === void 0 ? void 0 : _options.data) !== null && _b !== void 0 ? _b : {},\n                    channel: (_c = _options === null || _options === void 0 ? void 0 : _options.channel) !== null && _c !== void 0 ? _c : 'sms',\n                    gotrue_meta_security: {\n                      captcha_token: _options === null || _options === void 0 ? void 0 : _options.captchaToken\n                    }\n                  },\n                  xform: _sessionResponse\n                });\n\n              case 14:\n                res = _context2.sent;\n                _context2.next = 18;\n                break;\n\n              case 17:\n                throw new AuthInvalidCredentialsError('You must provide either an email or phone number and a password');\n\n              case 18:\n                _res = res, data = _res.data, error = _res.error;\n\n                if (!(error || !data)) {\n                  _context2.next = 21;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: error\n                });\n\n              case 21:\n                session = data.session;\n                user = data.user;\n\n                if (!data.session) {\n                  _context2.next = 27;\n                  break;\n                }\n\n                _context2.next = 26;\n                return this._saveSession(data.session);\n\n              case 26:\n                this._notifyAllSubscribers('SIGNED_IN', session);\n\n              case 27:\n                return _context2.abrupt(\"return\", {\n                  data: {\n                    user: user,\n                    session: session\n                  },\n                  error: null\n                });\n\n              case 30:\n                _context2.prev = 30;\n                _context2.t0 = _context2[\"catch\"](0);\n\n                if (!isAuthError(_context2.t0)) {\n                  _context2.next = 34;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: _context2.t0\n                });\n\n              case 34:\n                throw _context2.t0;\n\n              case 35:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[0, 30]]);\n      }));\n    }\n    /**\r\n     * Log in an existing user with an email and password or phone and password.\r\n     *\r\n     * Be aware that you may get back an error message that will not distinguish\r\n     * between the cases where the account does not exist or that the\r\n     * email/phone and password combination is wrong or that the account can only\r\n     * be accessed via social login.\r\n     */\n\n  }, {\n    key: \"signInWithPassword\",\n    value: function signInWithPassword(credentials) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var res, email, password, options, phone, _password2, _options2, _res2, data, error;\n\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.prev = 0;\n                _context3.next = 3;\n                return this._removeSession();\n\n              case 3:\n                if (!('email' in credentials)) {\n                  _context3.next = 10;\n                  break;\n                }\n\n                email = credentials.email, password = credentials.password, options = credentials.options;\n                _context3.next = 7;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/token?grant_type=password\"), {\n                  headers: this.headers,\n                  body: {\n                    email: email,\n                    password: password,\n                    gotrue_meta_security: {\n                      captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                    }\n                  },\n                  xform: _sessionResponse\n                });\n\n              case 7:\n                res = _context3.sent;\n                _context3.next = 18;\n                break;\n\n              case 10:\n                if (!('phone' in credentials)) {\n                  _context3.next = 17;\n                  break;\n                }\n\n                phone = credentials.phone, _password2 = credentials.password, _options2 = credentials.options;\n                _context3.next = 14;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/token?grant_type=password\"), {\n                  headers: this.headers,\n                  body: {\n                    phone: phone,\n                    password: _password2,\n                    gotrue_meta_security: {\n                      captcha_token: _options2 === null || _options2 === void 0 ? void 0 : _options2.captchaToken\n                    }\n                  },\n                  xform: _sessionResponse\n                });\n\n              case 14:\n                res = _context3.sent;\n                _context3.next = 18;\n                break;\n\n              case 17:\n                throw new AuthInvalidCredentialsError('You must provide either an email or phone number and a password');\n\n              case 18:\n                _res2 = res, data = _res2.data, error = _res2.error;\n\n                if (!(error || !data)) {\n                  _context3.next = 21;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: error\n                });\n\n              case 21:\n                if (!data.session) {\n                  _context3.next = 25;\n                  break;\n                }\n\n                _context3.next = 24;\n                return this._saveSession(data.session);\n\n              case 24:\n                this._notifyAllSubscribers('SIGNED_IN', data.session);\n\n              case 25:\n                return _context3.abrupt(\"return\", {\n                  data: data,\n                  error: error\n                });\n\n              case 28:\n                _context3.prev = 28;\n                _context3.t0 = _context3[\"catch\"](0);\n\n                if (!isAuthError(_context3.t0)) {\n                  _context3.next = 32;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: _context3.t0\n                });\n\n              case 32:\n                throw _context3.t0;\n\n              case 33:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[0, 28]]);\n      }));\n    }\n    /**\r\n     * Log in an existing user via a third-party provider.\r\n     */\n\n  }, {\n    key: \"signInWithOAuth\",\n    value: function signInWithOAuth(credentials) {\n      var _a, _b, _c, _d, _e;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this._removeSession();\n\n              case 2:\n                _context4.next = 4;\n                return this._handleProviderSignIn(credentials.provider, {\n                  redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,\n                  scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,\n                  queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,\n                  skipBrowserRedirect: (_d = credentials.options) === null || _d === void 0 ? void 0 : _d.skipBrowserRedirect,\n                  flowType: (_e = this.flowType) !== null && _e !== void 0 ? _e : 'implicit'\n                });\n\n              case 4:\n                return _context4.abrupt(\"return\", _context4.sent);\n\n              case 5:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n    }\n    /**\r\n     * Log in an existing user via a third-party provider.\r\n     */\n\n  }, {\n    key: \"exchangeCodeForSession\",\n    value: function exchangeCodeForSession(authCode) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var codeVerifier, _yield$_request, data, error;\n\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return getItemAsync(this.storage, \"\".concat(this.storageKey, \"-code-verifier\"));\n\n              case 2:\n                codeVerifier = _context5.sent;\n                _context5.next = 5;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/token?grant_type=pkce\"), {\n                  headers: this.headers,\n                  body: {\n                    auth_code: authCode,\n                    code_verifier: codeVerifier\n                  },\n                  xform: _sessionResponse\n                });\n\n              case 5:\n                _yield$_request = _context5.sent;\n                data = _yield$_request.data;\n                error = _yield$_request.error;\n                _context5.next = 10;\n                return removeItemAsync(this.storage, \"\".concat(this.storageKey, \"-code-verifier\"));\n\n              case 10:\n                if (!(error || !data)) {\n                  _context5.next = 12;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: error\n                });\n\n              case 12:\n                if (!data.session) {\n                  _context5.next = 16;\n                  break;\n                }\n\n                _context5.next = 15;\n                return this._saveSession(data.session);\n\n              case 15:\n                this._notifyAllSubscribers('SIGNED_IN', data.session);\n\n              case 16:\n                return _context5.abrupt(\"return\", {\n                  data: data,\n                  error: error\n                });\n\n              case 17:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n    }\n    /**\r\n     * Allows signing in with an ID token issued by certain supported providers.\r\n     * The ID token is verified for validity and a new session is established.\r\n     *\r\n     * @experimental\r\n     */\n\n  }, {\n    key: \"signInWithIdToken\",\n    value: function signInWithIdToken(credentials) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var options, provider, token, nonce, res, data, error;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return this._removeSession();\n\n              case 2:\n                _context6.prev = 2;\n                options = credentials.options, provider = credentials.provider, token = credentials.token, nonce = credentials.nonce;\n                _context6.next = 6;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/token?grant_type=id_token\"), {\n                  headers: this.headers,\n                  body: {\n                    provider: provider,\n                    id_token: token,\n                    nonce: nonce,\n                    gotrue_meta_security: {\n                      captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                    }\n                  },\n                  xform: _sessionResponse\n                });\n\n              case 6:\n                res = _context6.sent;\n                data = res.data, error = res.error;\n\n                if (!(error || !data)) {\n                  _context6.next = 10;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: error\n                });\n\n              case 10:\n                if (!data.session) {\n                  _context6.next = 14;\n                  break;\n                }\n\n                _context6.next = 13;\n                return this._saveSession(data.session);\n\n              case 13:\n                this._notifyAllSubscribers('SIGNED_IN', data.session);\n\n              case 14:\n                return _context6.abrupt(\"return\", {\n                  data: data,\n                  error: error\n                });\n\n              case 17:\n                _context6.prev = 17;\n                _context6.t0 = _context6[\"catch\"](2);\n\n                if (!isAuthError(_context6.t0)) {\n                  _context6.next = 21;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: _context6.t0\n                });\n\n              case 21:\n                throw _context6.t0;\n\n              case 22:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[2, 17]]);\n      }));\n    }\n    /**\r\n     * Log in a user using magiclink or a one-time password (OTP).\r\n     *\r\n     * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.\r\n     * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.\r\n     * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.\r\n     *\r\n     * Be aware that you may get back an error message that will not distinguish\r\n     * between the cases where the account does not exist or, that the account\r\n     * can only be accessed via social login.\r\n     *\r\n     * Do note that you will need to configure a Whatsapp sender on Twilio\r\n     * if you are using phone sign in with the 'whatsapp' channel. The whatsapp\r\n     * channel is not supported on other providers\r\n     * at this time.\r\n     */\n\n  }, {\n    key: \"signInWithOtp\",\n    value: function signInWithOtp(credentials) {\n      var _a, _b, _c, _d, _e;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var email, options, _yield$_request2, error, phone, _options3, _yield$_request3, _error;\n\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.prev = 0;\n                _context7.next = 3;\n                return this._removeSession();\n\n              case 3:\n                if (!('email' in credentials)) {\n                  _context7.next = 10;\n                  break;\n                }\n\n                email = credentials.email, options = credentials.options;\n                _context7.next = 7;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/otp\"), {\n                  headers: this.headers,\n                  body: {\n                    email: email,\n                    data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n                    create_user: (_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : true,\n                    gotrue_meta_security: {\n                      captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                    }\n                  },\n                  redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo\n                });\n\n              case 7:\n                _yield$_request2 = _context7.sent;\n                error = _yield$_request2.error;\n                return _context7.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: error\n                });\n\n              case 10:\n                if (!('phone' in credentials)) {\n                  _context7.next = 17;\n                  break;\n                }\n\n                phone = credentials.phone, _options3 = credentials.options;\n                _context7.next = 14;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/otp\"), {\n                  headers: this.headers,\n                  body: {\n                    phone: phone,\n                    data: (_c = _options3 === null || _options3 === void 0 ? void 0 : _options3.data) !== null && _c !== void 0 ? _c : {},\n                    create_user: (_d = _options3 === null || _options3 === void 0 ? void 0 : _options3.shouldCreateUser) !== null && _d !== void 0 ? _d : true,\n                    gotrue_meta_security: {\n                      captcha_token: _options3 === null || _options3 === void 0 ? void 0 : _options3.captchaToken\n                    },\n                    channel: (_e = _options3 === null || _options3 === void 0 ? void 0 : _options3.channel) !== null && _e !== void 0 ? _e : 'sms'\n                  }\n                });\n\n              case 14:\n                _yield$_request3 = _context7.sent;\n                _error = _yield$_request3.error;\n                return _context7.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: _error\n                });\n\n              case 17:\n                throw new AuthInvalidCredentialsError('You must provide either an email or phone number.');\n\n              case 20:\n                _context7.prev = 20;\n                _context7.t0 = _context7[\"catch\"](0);\n\n                if (!isAuthError(_context7.t0)) {\n                  _context7.next = 24;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: _context7.t0\n                });\n\n              case 24:\n                throw _context7.t0;\n\n              case 25:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[0, 20]]);\n      }));\n    }\n    /**\r\n     * Log in a user given a User supplied OTP received via mobile.\r\n     */\n\n  }, {\n    key: \"verifyOtp\",\n    value: function verifyOtp(params) {\n      var _a, _b;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        var _yield$_request4, data, error, session, user;\n\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.prev = 0;\n                _context8.next = 3;\n                return this._removeSession();\n\n              case 3:\n                _context8.next = 5;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/verify\"), {\n                  headers: this.headers,\n                  body: Object.assign(Object.assign({}, params), {\n                    gotrue_meta_security: {\n                      captcha_token: (_a = params.options) === null || _a === void 0 ? void 0 : _a.captchaToken\n                    }\n                  }),\n                  redirectTo: (_b = params.options) === null || _b === void 0 ? void 0 : _b.redirectTo,\n                  xform: _sessionResponse\n                });\n\n              case 5:\n                _yield$_request4 = _context8.sent;\n                data = _yield$_request4.data;\n                error = _yield$_request4.error;\n\n                if (!error) {\n                  _context8.next = 10;\n                  break;\n                }\n\n                throw error;\n\n              case 10:\n                if (data) {\n                  _context8.next = 12;\n                  break;\n                }\n\n                throw new Error('An error occurred on token verification.');\n\n              case 12:\n                session = data.session;\n                user = data.user;\n\n                if (!(session === null || session === void 0 ? void 0 : session.access_token)) {\n                  _context8.next = 18;\n                  break;\n                }\n\n                _context8.next = 17;\n                return this._saveSession(session);\n\n              case 17:\n                this._notifyAllSubscribers('SIGNED_IN', session);\n\n              case 18:\n                return _context8.abrupt(\"return\", {\n                  data: {\n                    user: user,\n                    session: session\n                  },\n                  error: null\n                });\n\n              case 21:\n                _context8.prev = 21;\n                _context8.t0 = _context8[\"catch\"](0);\n\n                if (!isAuthError(_context8.t0)) {\n                  _context8.next = 25;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: _context8.t0\n                });\n\n              case 25:\n                throw _context8.t0;\n\n              case 26:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this, [[0, 21]]);\n      }));\n    }\n    /**\r\n     * Attempts a single-sign on using an enterprise Identity Provider. A\r\n     * successful SSO attempt will redirect the current page to the identity\r\n     * provider authorization page. The redirect URL is implementation and SSO\r\n     * protocol specific.\r\n     *\r\n     * You can use it by providing a SSO domain. Typically you can extract this\r\n     * domain by asking users for their email address. If this domain is\r\n     * registered on the Auth instance the redirect will use that organization's\r\n     * currently active SSO Identity Provider for the login.\r\n     *\r\n     * If you have built an organization-specific login page, you can use the\r\n     * organization's SSO Identity Provider UUID directly instead.\r\n     */\n\n  }, {\n    key: \"signInWithSSO\",\n    value: function signInWithSSO(params) {\n      var _a, _b, _c;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.prev = 0;\n                _context9.next = 3;\n                return this._removeSession();\n\n              case 3:\n                _context9.next = 5;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/sso\"), {\n                  body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, 'providerId' in params ? {\n                    provider_id: params.providerId\n                  } : null), 'domain' in params ? {\n                    domain: params.domain\n                  } : null), {\n                    redirect_to: (_b = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo) !== null && _b !== void 0 ? _b : undefined\n                  }), ((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.captchaToken) ? {\n                    gotrue_meta_security: {\n                      captcha_token: params.options.captchaToken\n                    }\n                  } : null), {\n                    skip_http_redirect: true\n                  }),\n                  headers: this.headers,\n                  xform: _ssoResponse\n                });\n\n              case 5:\n                return _context9.abrupt(\"return\", _context9.sent);\n\n              case 8:\n                _context9.prev = 8;\n                _context9.t0 = _context9[\"catch\"](0);\n\n                if (!isAuthError(_context9.t0)) {\n                  _context9.next = 12;\n                  break;\n                }\n\n                return _context9.abrupt(\"return\", {\n                  data: null,\n                  error: _context9.t0\n                });\n\n              case 12:\n                throw _context9.t0;\n\n              case 13:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this, [[0, 8]]);\n      }));\n    }\n    /**\r\n     * Returns the session, refreshing it if necessary.\r\n     * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.\r\n     */\n\n  }, {\n    key: \"getSession\",\n    value: function getSession() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n        var currentSession, maybeSession, hasExpired, _yield$this$_callRefr, session, error;\n\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _context10.next = 2;\n                return this.initializePromise;\n\n              case 2:\n                currentSession = null;\n\n                if (!this.persistSession) {\n                  _context10.next = 16;\n                  break;\n                }\n\n                _context10.next = 6;\n                return getItemAsync(this.storage, this.storageKey);\n\n              case 6:\n                maybeSession = _context10.sent;\n\n                if (!(maybeSession !== null)) {\n                  _context10.next = 14;\n                  break;\n                }\n\n                if (!this._isValidSession(maybeSession)) {\n                  _context10.next = 12;\n                  break;\n                }\n\n                currentSession = maybeSession;\n                _context10.next = 14;\n                break;\n\n              case 12:\n                _context10.next = 14;\n                return this._removeSession();\n\n              case 14:\n                _context10.next = 17;\n                break;\n\n              case 16:\n                currentSession = this.inMemorySession;\n\n              case 17:\n                if (currentSession) {\n                  _context10.next = 19;\n                  break;\n                }\n\n                return _context10.abrupt(\"return\", {\n                  data: {\n                    session: null\n                  },\n                  error: null\n                });\n\n              case 19:\n                hasExpired = currentSession.expires_at ? currentSession.expires_at <= Date.now() / 1000 : false;\n\n                if (hasExpired) {\n                  _context10.next = 22;\n                  break;\n                }\n\n                return _context10.abrupt(\"return\", {\n                  data: {\n                    session: currentSession\n                  },\n                  error: null\n                });\n\n              case 22:\n                _context10.next = 24;\n                return this._callRefreshToken(currentSession.refresh_token);\n\n              case 24:\n                _yield$this$_callRefr = _context10.sent;\n                session = _yield$this$_callRefr.session;\n                error = _yield$this$_callRefr.error;\n\n                if (!error) {\n                  _context10.next = 29;\n                  break;\n                }\n\n                return _context10.abrupt(\"return\", {\n                  data: {\n                    session: null\n                  },\n                  error: error\n                });\n\n              case 29:\n                return _context10.abrupt(\"return\", {\n                  data: {\n                    session: session\n                  },\n                  error: null\n                });\n\n              case 30:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n    }\n    /**\r\n     * Gets the current user details if there is an existing session.\r\n     * @param jwt Takes in an optional access token jwt. If no jwt is provided, getUser() will attempt to get the jwt from the current session.\r\n     */\n\n  }, {\n    key: \"getUser\",\n    value: function getUser(jwt) {\n      var _a, _b;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n        var _yield$this$getSessio, data, error;\n\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                _context11.prev = 0;\n\n                if (jwt) {\n                  _context11.next = 10;\n                  break;\n                }\n\n                _context11.next = 4;\n                return this.getSession();\n\n              case 4:\n                _yield$this$getSessio = _context11.sent;\n                data = _yield$this$getSessio.data;\n                error = _yield$this$getSessio.error;\n\n                if (!error) {\n                  _context11.next = 9;\n                  break;\n                }\n\n                throw error;\n\n              case 9:\n                // Default to Authorization header if there is no existing session\n                jwt = (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : undefined;\n\n              case 10:\n                _context11.next = 12;\n                return _request(this.fetch, 'GET', \"\".concat(this.url, \"/user\"), {\n                  headers: this.headers,\n                  jwt: jwt,\n                  xform: _userResponse\n                });\n\n              case 12:\n                return _context11.abrupt(\"return\", _context11.sent);\n\n              case 15:\n                _context11.prev = 15;\n                _context11.t0 = _context11[\"catch\"](0);\n\n                if (!isAuthError(_context11.t0)) {\n                  _context11.next = 19;\n                  break;\n                }\n\n                return _context11.abrupt(\"return\", {\n                  data: {\n                    user: null\n                  },\n                  error: _context11.t0\n                });\n\n              case 19:\n                throw _context11.t0;\n\n              case 20:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this, [[0, 15]]);\n      }));\n    }\n    /**\r\n     * Updates user data for a logged in user.\r\n     */\n\n  }, {\n    key: \"updateUser\",\n    value: function updateUser(attributes) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {\n        var _yield$this$getSessio2, sessionData, sessionError, session, _yield$_request5, data, userError;\n\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _context12.prev = 0;\n                _context12.next = 3;\n                return this.getSession();\n\n              case 3:\n                _yield$this$getSessio2 = _context12.sent;\n                sessionData = _yield$this$getSessio2.data;\n                sessionError = _yield$this$getSessio2.error;\n\n                if (!sessionError) {\n                  _context12.next = 8;\n                  break;\n                }\n\n                throw sessionError;\n\n              case 8:\n                if (sessionData.session) {\n                  _context12.next = 10;\n                  break;\n                }\n\n                throw new AuthSessionMissingError();\n\n              case 10:\n                session = sessionData.session;\n                _context12.next = 13;\n                return _request(this.fetch, 'PUT', \"\".concat(this.url, \"/user\"), {\n                  headers: this.headers,\n                  redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n                  body: attributes,\n                  jwt: session.access_token,\n                  xform: _userResponse\n                });\n\n              case 13:\n                _yield$_request5 = _context12.sent;\n                data = _yield$_request5.data;\n                userError = _yield$_request5.error;\n\n                if (!userError) {\n                  _context12.next = 18;\n                  break;\n                }\n\n                throw userError;\n\n              case 18:\n                session.user = data.user;\n                _context12.next = 21;\n                return this._saveSession(session);\n\n              case 21:\n                this._notifyAllSubscribers('USER_UPDATED', session);\n\n                return _context12.abrupt(\"return\", {\n                  data: {\n                    user: session.user\n                  },\n                  error: null\n                });\n\n              case 25:\n                _context12.prev = 25;\n                _context12.t0 = _context12[\"catch\"](0);\n\n                if (!isAuthError(_context12.t0)) {\n                  _context12.next = 29;\n                  break;\n                }\n\n                return _context12.abrupt(\"return\", {\n                  data: {\n                    user: null\n                  },\n                  error: _context12.t0\n                });\n\n              case 29:\n                throw _context12.t0;\n\n              case 30:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this, [[0, 25]]);\n      }));\n    }\n    /**\r\n     * Decodes a JWT (without performing any validation).\r\n     */\n\n  }, {\n    key: \"_decodeJWT\",\n    value: function _decodeJWT(jwt) {\n      return decodeJWTPayload(jwt);\n    }\n    /**\r\n     * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.\r\n     * If the refresh token or access token in the current session is invalid, an error will be thrown.\r\n     * @param currentSession The current session that minimally contains an access token and refresh token.\r\n     */\n\n  }, {\n    key: \"setSession\",\n    value: function setSession(currentSession) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {\n        var timeNow, expiresAt, hasExpired, session, payload, _yield$this$_callRefr2, refreshedSession, error, _yield$this$getUser, data, _error2;\n\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                _context13.prev = 0;\n\n                if (!(!currentSession.access_token || !currentSession.refresh_token)) {\n                  _context13.next = 3;\n                  break;\n                }\n\n                throw new AuthSessionMissingError();\n\n              case 3:\n                timeNow = Date.now() / 1000;\n                expiresAt = timeNow;\n                hasExpired = true;\n                session = null;\n                payload = decodeJWTPayload(currentSession.access_token);\n\n                if (payload.exp) {\n                  expiresAt = payload.exp;\n                  hasExpired = expiresAt <= timeNow;\n                }\n\n                if (!hasExpired) {\n                  _context13.next = 22;\n                  break;\n                }\n\n                _context13.next = 12;\n                return this._callRefreshToken(currentSession.refresh_token);\n\n              case 12:\n                _yield$this$_callRefr2 = _context13.sent;\n                refreshedSession = _yield$this$_callRefr2.session;\n                error = _yield$this$_callRefr2.error;\n\n                if (!error) {\n                  _context13.next = 17;\n                  break;\n                }\n\n                return _context13.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: error\n                });\n\n              case 17:\n                if (refreshedSession) {\n                  _context13.next = 19;\n                  break;\n                }\n\n                return _context13.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: null\n                });\n\n              case 19:\n                session = refreshedSession;\n                _context13.next = 33;\n                break;\n\n              case 22:\n                _context13.next = 24;\n                return this.getUser(currentSession.access_token);\n\n              case 24:\n                _yield$this$getUser = _context13.sent;\n                data = _yield$this$getUser.data;\n                _error2 = _yield$this$getUser.error;\n\n                if (!_error2) {\n                  _context13.next = 29;\n                  break;\n                }\n\n                throw _error2;\n\n              case 29:\n                session = {\n                  access_token: currentSession.access_token,\n                  refresh_token: currentSession.refresh_token,\n                  user: data.user,\n                  token_type: 'bearer',\n                  expires_in: expiresAt - timeNow,\n                  expires_at: expiresAt\n                };\n                _context13.next = 32;\n                return this._saveSession(session);\n\n              case 32:\n                this._notifyAllSubscribers('SIGNED_IN', session);\n\n              case 33:\n                return _context13.abrupt(\"return\", {\n                  data: {\n                    user: session.user,\n                    session: session\n                  },\n                  error: null\n                });\n\n              case 36:\n                _context13.prev = 36;\n                _context13.t0 = _context13[\"catch\"](0);\n\n                if (!isAuthError(_context13.t0)) {\n                  _context13.next = 40;\n                  break;\n                }\n\n                return _context13.abrupt(\"return\", {\n                  data: {\n                    session: null,\n                    user: null\n                  },\n                  error: _context13.t0\n                });\n\n              case 40:\n                throw _context13.t0;\n\n              case 41:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this, [[0, 36]]);\n      }));\n    }\n    /**\r\n     * Returns a new session, regardless of expiry status.\r\n     * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().\r\n     * If the current session's refresh token is invalid, an error will be thrown.\r\n     * @param currentSession The current session. If passed in, it must contain a refresh token.\r\n     */\n\n  }, {\n    key: \"refreshSession\",\n    value: function refreshSession(currentSession) {\n      var _a;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {\n        var _yield$this$getSessio3, data, _error3, _yield$this$_callRefr3, session, error;\n\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                _context14.prev = 0;\n\n                if (currentSession) {\n                  _context14.next = 10;\n                  break;\n                }\n\n                _context14.next = 4;\n                return this.getSession();\n\n              case 4:\n                _yield$this$getSessio3 = _context14.sent;\n                data = _yield$this$getSessio3.data;\n                _error3 = _yield$this$getSessio3.error;\n\n                if (!_error3) {\n                  _context14.next = 9;\n                  break;\n                }\n\n                throw _error3;\n\n              case 9:\n                currentSession = (_a = data.session) !== null && _a !== void 0 ? _a : undefined;\n\n              case 10:\n                if (currentSession === null || currentSession === void 0 ? void 0 : currentSession.refresh_token) {\n                  _context14.next = 12;\n                  break;\n                }\n\n                throw new AuthSessionMissingError();\n\n              case 12:\n                _context14.next = 14;\n                return this._callRefreshToken(currentSession.refresh_token);\n\n              case 14:\n                _yield$this$_callRefr3 = _context14.sent;\n                session = _yield$this$_callRefr3.session;\n                error = _yield$this$_callRefr3.error;\n\n                if (!error) {\n                  _context14.next = 19;\n                  break;\n                }\n\n                return _context14.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: error\n                });\n\n              case 19:\n                if (session) {\n                  _context14.next = 21;\n                  break;\n                }\n\n                return _context14.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: null\n                });\n\n              case 21:\n                return _context14.abrupt(\"return\", {\n                  data: {\n                    user: session.user,\n                    session: session\n                  },\n                  error: null\n                });\n\n              case 24:\n                _context14.prev = 24;\n                _context14.t0 = _context14[\"catch\"](0);\n\n                if (!isAuthError(_context14.t0)) {\n                  _context14.next = 28;\n                  break;\n                }\n\n                return _context14.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: _context14.t0\n                });\n\n              case 28:\n                throw _context14.t0;\n\n              case 29:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this, [[0, 24]]);\n      }));\n    }\n    /**\r\n     * Gets the session data from a URL string\r\n     */\n\n  }, {\n    key: \"_getSessionFromUrl\",\n    value: function _getSessionFromUrl(isPKCEFlow) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {\n        var authCode, _yield$this$exchangeC, _data, _error4, error_description, error_code, _error5, provider_token, provider_refresh_token, access_token, expires_in, refresh_token, token_type, timeNow, expires_at, _yield$this$getUser2, data, error, user, session, redirectType;\n\n        return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                _context15.prev = 0;\n\n                if (isBrowser()) {\n                  _context15.next = 3;\n                  break;\n                }\n\n                throw new AuthImplicitGrantRedirectError('No browser detected.');\n\n              case 3:\n                if (!(this.flowType == 'implicit' && !this._isImplicitGrantFlow())) {\n                  _context15.next = 7;\n                  break;\n                }\n\n                throw new AuthImplicitGrantRedirectError('Not a valid implicit grant flow url.');\n\n              case 7:\n                if (!(this.flowType == 'pkce' && !isPKCEFlow)) {\n                  _context15.next = 9;\n                  break;\n                }\n\n                throw new AuthPKCEGrantCodeExchangeError('Not a valid PKCE flow url.');\n\n              case 9:\n                if (!isPKCEFlow) {\n                  _context15.next = 23;\n                  break;\n                }\n\n                authCode = getParameterByName('code');\n\n                if (authCode) {\n                  _context15.next = 13;\n                  break;\n                }\n\n                throw new AuthPKCEGrantCodeExchangeError('No code detected.');\n\n              case 13:\n                _context15.next = 15;\n                return this.exchangeCodeForSession(authCode);\n\n              case 15:\n                _yield$this$exchangeC = _context15.sent;\n                _data = _yield$this$exchangeC.data;\n                _error4 = _yield$this$exchangeC.error;\n\n                if (!_error4) {\n                  _context15.next = 20;\n                  break;\n                }\n\n                throw _error4;\n\n              case 20:\n                if (_data.session) {\n                  _context15.next = 22;\n                  break;\n                }\n\n                throw new AuthPKCEGrantCodeExchangeError('No session detected.');\n\n              case 22:\n                return _context15.abrupt(\"return\", {\n                  data: {\n                    session: _data.session,\n                    redirectType: null\n                  },\n                  error: null\n                });\n\n              case 23:\n                error_description = getParameterByName('error_description');\n\n                if (!error_description) {\n                  _context15.next = 32;\n                  break;\n                }\n\n                error_code = getParameterByName('error_code');\n\n                if (error_code) {\n                  _context15.next = 28;\n                  break;\n                }\n\n                throw new AuthImplicitGrantRedirectError('No error_code detected.');\n\n              case 28:\n                _error5 = getParameterByName('error');\n\n                if (_error5) {\n                  _context15.next = 31;\n                  break;\n                }\n\n                throw new AuthImplicitGrantRedirectError('No error detected.');\n\n              case 31:\n                throw new AuthImplicitGrantRedirectError(error_description, {\n                  error: _error5,\n                  code: error_code\n                });\n\n              case 32:\n                provider_token = getParameterByName('provider_token');\n                provider_refresh_token = getParameterByName('provider_refresh_token');\n                access_token = getParameterByName('access_token');\n\n                if (access_token) {\n                  _context15.next = 37;\n                  break;\n                }\n\n                throw new AuthImplicitGrantRedirectError('No access_token detected.');\n\n              case 37:\n                expires_in = getParameterByName('expires_in');\n\n                if (expires_in) {\n                  _context15.next = 40;\n                  break;\n                }\n\n                throw new AuthImplicitGrantRedirectError('No expires_in detected.');\n\n              case 40:\n                refresh_token = getParameterByName('refresh_token');\n\n                if (refresh_token) {\n                  _context15.next = 43;\n                  break;\n                }\n\n                throw new AuthImplicitGrantRedirectError('No refresh_token detected.');\n\n              case 43:\n                token_type = getParameterByName('token_type');\n\n                if (token_type) {\n                  _context15.next = 46;\n                  break;\n                }\n\n                throw new AuthImplicitGrantRedirectError('No token_type detected.');\n\n              case 46:\n                timeNow = Math.round(Date.now() / 1000);\n                expires_at = timeNow + parseInt(expires_in);\n                _context15.next = 50;\n                return this.getUser(access_token);\n\n              case 50:\n                _yield$this$getUser2 = _context15.sent;\n                data = _yield$this$getUser2.data;\n                error = _yield$this$getUser2.error;\n\n                if (!error) {\n                  _context15.next = 55;\n                  break;\n                }\n\n                throw error;\n\n              case 55:\n                user = data.user;\n                session = {\n                  provider_token: provider_token,\n                  provider_refresh_token: provider_refresh_token,\n                  access_token: access_token,\n                  expires_in: parseInt(expires_in),\n                  expires_at: expires_at,\n                  refresh_token: refresh_token,\n                  token_type: token_type,\n                  user: user\n                };\n                redirectType = getParameterByName('type'); // Remove tokens from URL\n\n                window.location.hash = '';\n                return _context15.abrupt(\"return\", {\n                  data: {\n                    session: session,\n                    redirectType: redirectType\n                  },\n                  error: null\n                });\n\n              case 62:\n                _context15.prev = 62;\n                _context15.t0 = _context15[\"catch\"](0);\n\n                if (!isAuthError(_context15.t0)) {\n                  _context15.next = 66;\n                  break;\n                }\n\n                return _context15.abrupt(\"return\", {\n                  data: {\n                    session: null,\n                    redirectType: null\n                  },\n                  error: _context15.t0\n                });\n\n              case 66:\n                throw _context15.t0;\n\n              case 67:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this, [[0, 62]]);\n      }));\n    }\n    /**\r\n     * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)\r\n     */\n\n  }, {\n    key: \"_isImplicitGrantFlow\",\n    value: function _isImplicitGrantFlow() {\n      return isBrowser() && (Boolean(getParameterByName('access_token')) || Boolean(getParameterByName('error_description')));\n    }\n    /**\r\n     * Checks if the current URL and backing storage contain parameters given by a PKCE flow\r\n     */\n\n  }, {\n    key: \"_isPKCEFlow\",\n    value: function _isPKCEFlow() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {\n        var currentStorageContent;\n        return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                _context16.next = 2;\n                return getItemAsync(this.storage, \"\".concat(this.storageKey, \"-code-verifier\"));\n\n              case 2:\n                currentStorageContent = _context16.sent;\n                return _context16.abrupt(\"return\", isBrowser() && Boolean(getParameterByName('code')) && Boolean(currentStorageContent));\n\n              case 4:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n    }\n    /**\r\n     * Inside a browser context, `signOut()` will remove the logged in user from the browser session\r\n     * and log them out - removing all items from localstorage and then trigger a `\"SIGNED_OUT\"` event.\r\n     *\r\n     * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.\r\n     * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.\r\n     */\n\n  }, {\n    key: \"signOut\",\n    value: function signOut() {\n      var _a;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {\n        var _yield$this$getSessio4, data, sessionError, accessToken, _yield$this$admin$sig, error;\n\n        return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                _context17.next = 2;\n                return this.getSession();\n\n              case 2:\n                _yield$this$getSessio4 = _context17.sent;\n                data = _yield$this$getSessio4.data;\n                sessionError = _yield$this$getSessio4.error;\n\n                if (!sessionError) {\n                  _context17.next = 7;\n                  break;\n                }\n\n                return _context17.abrupt(\"return\", {\n                  error: sessionError\n                });\n\n              case 7:\n                accessToken = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token;\n\n                if (!accessToken) {\n                  _context17.next = 16;\n                  break;\n                }\n\n                _context17.next = 11;\n                return this.admin.signOut(accessToken);\n\n              case 11:\n                _yield$this$admin$sig = _context17.sent;\n                error = _yield$this$admin$sig.error;\n\n                if (!error) {\n                  _context17.next = 16;\n                  break;\n                }\n\n                if (isAuthApiError(error) && (error.status === 404 || error.status === 401)) {\n                  _context17.next = 16;\n                  break;\n                }\n\n                return _context17.abrupt(\"return\", {\n                  error: error\n                });\n\n              case 16:\n                _context17.next = 18;\n                return this._removeSession();\n\n              case 18:\n                this._notifyAllSubscribers('SIGNED_OUT', null);\n\n                return _context17.abrupt(\"return\", {\n                  error: null\n                });\n\n              case 20:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n    }\n    /**\r\n     * Receive a notification every time an auth event happens.\r\n     * @param callback A callback function to be invoked when an auth event happens.\r\n     */\n\n  }, {\n    key: \"onAuthStateChange\",\n    value: function onAuthStateChange(callback) {\n      var _this3 = this;\n\n      var id = uuid();\n      var subscription = {\n        id: id,\n        callback: callback,\n        unsubscribe: function unsubscribe() {\n          _this3.stateChangeEmitters.delete(id);\n        }\n      };\n      this.stateChangeEmitters.set(id, subscription);\n      this.emitInitialSession(id);\n      return {\n        data: {\n          subscription: subscription\n        }\n      };\n    }\n  }, {\n    key: \"emitInitialSession\",\n    value: function emitInitialSession(id) {\n      var _a, _b;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {\n        var _yield$this$getSessio5, session, error;\n\n        return _regeneratorRuntime().wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                _context18.prev = 0;\n                _context18.next = 3;\n                return this.getSession();\n\n              case 3:\n                _yield$this$getSessio5 = _context18.sent;\n                session = _yield$this$getSessio5.data.session;\n                error = _yield$this$getSessio5.error;\n\n                if (!error) {\n                  _context18.next = 8;\n                  break;\n                }\n\n                throw error;\n\n              case 8:\n                (_a = this.stateChangeEmitters.get(id)) === null || _a === void 0 ? void 0 : _a.callback('INITIAL_SESSION', session);\n                _context18.next = 15;\n                break;\n\n              case 11:\n                _context18.prev = 11;\n                _context18.t0 = _context18[\"catch\"](0);\n                (_b = this.stateChangeEmitters.get(id)) === null || _b === void 0 ? void 0 : _b.callback('INITIAL_SESSION', null);\n                console.error(_context18.t0);\n\n              case 15:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this, [[0, 11]]);\n      }));\n    }\n    /**\r\n     * Sends a password reset request to an email address.\r\n     * @param email The email address of the user.\r\n     * @param options.redirectTo The URL to send the user to after they click the password reset link.\r\n     * @param options.captchaToken Verification token received when the user completes the captcha on the site.\r\n     */\n\n  }, {\n    key: \"resetPasswordForEmail\",\n    value: function resetPasswordForEmail(email) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee19() {\n        return _regeneratorRuntime().wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                _context19.prev = 0;\n                _context19.next = 3;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/recover\"), {\n                  body: {\n                    email: email,\n                    gotrue_meta_security: {\n                      captcha_token: options.captchaToken\n                    }\n                  },\n                  headers: this.headers,\n                  redirectTo: options.redirectTo\n                });\n\n              case 3:\n                return _context19.abrupt(\"return\", _context19.sent);\n\n              case 6:\n                _context19.prev = 6;\n                _context19.t0 = _context19[\"catch\"](0);\n\n                if (!isAuthError(_context19.t0)) {\n                  _context19.next = 10;\n                  break;\n                }\n\n                return _context19.abrupt(\"return\", {\n                  data: null,\n                  error: _context19.t0\n                });\n\n              case 10:\n                throw _context19.t0;\n\n              case 11:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19, this, [[0, 6]]);\n      }));\n    }\n    /**\r\n     * Generates a new JWT.\r\n     * @param refreshToken A valid refresh token that was returned on login.\r\n     */\n\n  }, {\n    key: \"_refreshAccessToken\",\n    value: function _refreshAccessToken(refreshToken) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee21() {\n        var _this4 = this;\n\n        var startedAt;\n        return _regeneratorRuntime().wrap(function _callee21$(_context21) {\n          while (1) {\n            switch (_context21.prev = _context21.next) {\n              case 0:\n                _context21.prev = 0;\n                startedAt = Date.now(); // will attempt to refresh the token with exponential backoff\n\n                _context21.next = 4;\n                return retryable(function (attempt) {\n                  return __awaiter(_this4, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee20() {\n                    return _regeneratorRuntime().wrap(function _callee20$(_context20) {\n                      while (1) {\n                        switch (_context20.prev = _context20.next) {\n                          case 0:\n                            _context20.next = 2;\n                            return sleep(attempt * 200);\n\n                          case 2:\n                            _context20.next = 4;\n                            return _request(this.fetch, 'POST', \"\".concat(this.url, \"/token?grant_type=refresh_token\"), {\n                              body: {\n                                refresh_token: refreshToken\n                              },\n                              headers: this.headers,\n                              xform: _sessionResponse\n                            });\n\n                          case 4:\n                            return _context20.abrupt(\"return\", _context20.sent);\n\n                          case 5:\n                          case \"end\":\n                            return _context20.stop();\n                        }\n                      }\n                    }, _callee20, this);\n                  }));\n                }, function (attempt, _, result) {\n                  return result && result.error && result.error instanceof AuthRetryableFetchError && // retryable only if the request can be sent before the backoff overflows the tick duration\n                  Date.now() + (attempt + 1) * 200 - startedAt < AUTO_REFRESH_TICK_DURATION;\n                });\n\n              case 4:\n                return _context21.abrupt(\"return\", _context21.sent);\n\n              case 7:\n                _context21.prev = 7;\n                _context21.t0 = _context21[\"catch\"](0);\n\n                if (!isAuthError(_context21.t0)) {\n                  _context21.next = 11;\n                  break;\n                }\n\n                return _context21.abrupt(\"return\", {\n                  data: {\n                    session: null,\n                    user: null\n                  },\n                  error: _context21.t0\n                });\n\n              case 11:\n                throw _context21.t0;\n\n              case 12:\n              case \"end\":\n                return _context21.stop();\n            }\n          }\n        }, _callee21, null, [[0, 7]]);\n      }));\n    }\n  }, {\n    key: \"_isValidSession\",\n    value: function _isValidSession(maybeSession) {\n      var isValidSession = typeof maybeSession === 'object' && maybeSession !== null && 'access_token' in maybeSession && 'refresh_token' in maybeSession && 'expires_at' in maybeSession;\n      return isValidSession;\n    }\n  }, {\n    key: \"_handleProviderSignIn\",\n    value: function _handleProviderSignIn(provider, options) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee22() {\n        var url;\n        return _regeneratorRuntime().wrap(function _callee22$(_context22) {\n          while (1) {\n            switch (_context22.prev = _context22.next) {\n              case 0:\n                _context22.next = 2;\n                return this._getUrlForProvider(provider, {\n                  redirectTo: options.redirectTo,\n                  scopes: options.scopes,\n                  queryParams: options.queryParams,\n                  flowType: options.flowType\n                });\n\n              case 2:\n                url = _context22.sent;\n\n                // try to open on the browser\n                if (isBrowser() && !options.skipBrowserRedirect) {\n                  window.location.assign(url);\n                }\n\n                return _context22.abrupt(\"return\", {\n                  data: {\n                    provider: provider,\n                    url: url\n                  },\n                  error: null\n                });\n\n              case 5:\n              case \"end\":\n                return _context22.stop();\n            }\n          }\n        }, _callee22, this);\n      }));\n    }\n    /**\r\n     * Recovers the session from LocalStorage and refreshes\r\n     * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\r\n     */\n\n  }, {\n    key: \"_recoverAndRefresh\",\n    value: function _recoverAndRefresh() {\n      var _a;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee23() {\n        var currentSession, timeNow, _yield$this$_callRefr4, error;\n\n        return _regeneratorRuntime().wrap(function _callee23$(_context23) {\n          while (1) {\n            switch (_context23.prev = _context23.next) {\n              case 0:\n                _context23.prev = 0;\n                _context23.next = 3;\n                return getItemAsync(this.storage, this.storageKey);\n\n              case 3:\n                currentSession = _context23.sent;\n\n                if (this._isValidSession(currentSession)) {\n                  _context23.next = 9;\n                  break;\n                }\n\n                if (!(currentSession !== null)) {\n                  _context23.next = 8;\n                  break;\n                }\n\n                _context23.next = 8;\n                return this._removeSession();\n\n              case 8:\n                return _context23.abrupt(\"return\");\n\n              case 9:\n                timeNow = Math.round(Date.now() / 1000);\n\n                if (!(((_a = currentSession.expires_at) !== null && _a !== void 0 ? _a : Infinity) < timeNow + EXPIRY_MARGIN)) {\n                  _context23.next = 26;\n                  break;\n                }\n\n                if (!(this.autoRefreshToken && currentSession.refresh_token)) {\n                  _context23.next = 22;\n                  break;\n                }\n\n                _context23.next = 14;\n                return this._callRefreshToken(currentSession.refresh_token);\n\n              case 14:\n                _yield$this$_callRefr4 = _context23.sent;\n                error = _yield$this$_callRefr4.error;\n\n                if (!error) {\n                  _context23.next = 20;\n                  break;\n                }\n\n                console.log(error.message);\n                _context23.next = 20;\n                return this._removeSession();\n\n              case 20:\n                _context23.next = 24;\n                break;\n\n              case 22:\n                _context23.next = 24;\n                return this._removeSession();\n\n              case 24:\n                _context23.next = 30;\n                break;\n\n              case 26:\n                if (!this.persistSession) {\n                  _context23.next = 29;\n                  break;\n                }\n\n                _context23.next = 29;\n                return this._saveSession(currentSession);\n\n              case 29:\n                this._notifyAllSubscribers('SIGNED_IN', currentSession);\n\n              case 30:\n                _context23.next = 36;\n                break;\n\n              case 32:\n                _context23.prev = 32;\n                _context23.t0 = _context23[\"catch\"](0);\n                console.error(_context23.t0);\n                return _context23.abrupt(\"return\");\n\n              case 36:\n              case \"end\":\n                return _context23.stop();\n            }\n          }\n        }, _callee23, this, [[0, 32]]);\n      }));\n    }\n  }, {\n    key: \"_callRefreshToken\",\n    value: function _callRefreshToken(refreshToken) {\n      var _a, _b;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee24() {\n        var _yield$this$_refreshA, data, error, result, _result;\n\n        return _regeneratorRuntime().wrap(function _callee24$(_context24) {\n          while (1) {\n            switch (_context24.prev = _context24.next) {\n              case 0:\n                if (!this.refreshingDeferred) {\n                  _context24.next = 2;\n                  break;\n                }\n\n                return _context24.abrupt(\"return\", this.refreshingDeferred.promise);\n\n              case 2:\n                _context24.prev = 2;\n                this.refreshingDeferred = new Deferred();\n\n                if (refreshToken) {\n                  _context24.next = 6;\n                  break;\n                }\n\n                throw new AuthSessionMissingError();\n\n              case 6:\n                _context24.next = 8;\n                return this._refreshAccessToken(refreshToken);\n\n              case 8:\n                _yield$this$_refreshA = _context24.sent;\n                data = _yield$this$_refreshA.data;\n                error = _yield$this$_refreshA.error;\n\n                if (!error) {\n                  _context24.next = 13;\n                  break;\n                }\n\n                throw error;\n\n              case 13:\n                if (data.session) {\n                  _context24.next = 15;\n                  break;\n                }\n\n                throw new AuthSessionMissingError();\n\n              case 15:\n                _context24.next = 17;\n                return this._saveSession(data.session);\n\n              case 17:\n                this._notifyAllSubscribers('TOKEN_REFRESHED', data.session);\n\n                result = {\n                  session: data.session,\n                  error: null\n                };\n                this.refreshingDeferred.resolve(result);\n                return _context24.abrupt(\"return\", result);\n\n              case 23:\n                _context24.prev = 23;\n                _context24.t0 = _context24[\"catch\"](2);\n\n                if (!isAuthError(_context24.t0)) {\n                  _context24.next = 29;\n                  break;\n                }\n\n                _result = {\n                  session: null,\n                  error: _context24.t0\n                };\n                (_a = this.refreshingDeferred) === null || _a === void 0 ? void 0 : _a.resolve(_result);\n                return _context24.abrupt(\"return\", _result);\n\n              case 29:\n                (_b = this.refreshingDeferred) === null || _b === void 0 ? void 0 : _b.reject(_context24.t0);\n                throw _context24.t0;\n\n              case 31:\n                _context24.prev = 31;\n                this.refreshingDeferred = null;\n                return _context24.finish(31);\n\n              case 34:\n              case \"end\":\n                return _context24.stop();\n            }\n          }\n        }, _callee24, this, [[2, 23, 31, 34]]);\n      }));\n    }\n  }, {\n    key: \"_notifyAllSubscribers\",\n    value: function _notifyAllSubscribers(event, session) {\n      var broadcast = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n      if (this.broadcastChannel && broadcast) {\n        this.broadcastChannel.postMessage({\n          event: event,\n          session: session\n        });\n      }\n\n      this.stateChangeEmitters.forEach(function (x) {\n        return x.callback(event, session);\n      });\n    }\n    /**\r\n     * set currentSession and currentUser\r\n     * process to _startAutoRefreshToken if possible\r\n     */\n\n  }, {\n    key: \"_saveSession\",\n    value: function _saveSession(session) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee25() {\n        return _regeneratorRuntime().wrap(function _callee25$(_context25) {\n          while (1) {\n            switch (_context25.prev = _context25.next) {\n              case 0:\n                if (!this.persistSession) {\n                  this.inMemorySession = session;\n                }\n\n                if (!(this.persistSession && session.expires_at)) {\n                  _context25.next = 4;\n                  break;\n                }\n\n                _context25.next = 4;\n                return this._persistSession(session);\n\n              case 4:\n              case \"end\":\n                return _context25.stop();\n            }\n          }\n        }, _callee25, this);\n      }));\n    }\n  }, {\n    key: \"_persistSession\",\n    value: function _persistSession(currentSession) {\n      return setItemAsync(this.storage, this.storageKey, currentSession);\n    }\n  }, {\n    key: \"_removeSession\",\n    value: function _removeSession() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee26() {\n        return _regeneratorRuntime().wrap(function _callee26$(_context26) {\n          while (1) {\n            switch (_context26.prev = _context26.next) {\n              case 0:\n                if (!this.persistSession) {\n                  _context26.next = 5;\n                  break;\n                }\n\n                _context26.next = 3;\n                return removeItemAsync(this.storage, this.storageKey);\n\n              case 3:\n                _context26.next = 6;\n                break;\n\n              case 5:\n                this.inMemorySession = null;\n\n              case 6:\n              case \"end\":\n                return _context26.stop();\n            }\n          }\n        }, _callee26, this);\n      }));\n    }\n    /**\r\n     * Removes any registered visibilitychange callback.\r\n     *\r\n     * {@see #startAutoRefresh}\r\n     * {@see #stopAutoRefresh}\r\n     */\n\n  }, {\n    key: \"_removeVisibilityChangedCallback\",\n    value: function _removeVisibilityChangedCallback() {\n      var callback = this.visibilityChangedCallback;\n      this.visibilityChangedCallback = null;\n\n      try {\n        if (callback && isBrowser() && (window === null || window === void 0 ? void 0 : window.removeEventListener)) {\n          window.removeEventListener('visibilitychange', callback);\n        }\n      } catch (e) {\n        console.error('removing visibilitychange callback failed', e);\n      }\n    }\n    /**\r\n     * This is the private implementation of {@link #startAutoRefresh}. Use this\r\n     * within the library.\r\n     */\n\n  }, {\n    key: \"_startAutoRefresh\",\n    value: function _startAutoRefresh() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee27() {\n        var _this5 = this;\n\n        var ticker;\n        return _regeneratorRuntime().wrap(function _callee27$(_context27) {\n          while (1) {\n            switch (_context27.prev = _context27.next) {\n              case 0:\n                _context27.next = 2;\n                return this._stopAutoRefresh();\n\n              case 2:\n                ticker = setInterval(function () {\n                  return _this5._autoRefreshTokenTick();\n                }, AUTO_REFRESH_TICK_DURATION);\n                this.autoRefreshTicker = ticker;\n\n                if (ticker && typeof ticker === 'object' && typeof ticker.unref === 'function') {\n                  // ticker is a NodeJS Timeout object that has an `unref` method\n                  // https://nodejs.org/api/timers.html#timeoutunref\n                  // When auto refresh is used in NodeJS (like for testing) the\n                  // `setInterval` is preventing the process from being marked as\n                  // finished and tests run endlessly. This can be prevented by calling\n                  // `unref()` on the returned object.\n                  ticker.unref();\n                } // run the tick immediately\n\n\n                _context27.next = 7;\n                return this._autoRefreshTokenTick();\n\n              case 7:\n              case \"end\":\n                return _context27.stop();\n            }\n          }\n        }, _callee27, this);\n      }));\n    }\n    /**\r\n     * This is the private implementation of {@link #stopAutoRefresh}. Use this\r\n     * within the library.\r\n     */\n\n  }, {\n    key: \"_stopAutoRefresh\",\n    value: function _stopAutoRefresh() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee28() {\n        var ticker;\n        return _regeneratorRuntime().wrap(function _callee28$(_context28) {\n          while (1) {\n            switch (_context28.prev = _context28.next) {\n              case 0:\n                ticker = this.autoRefreshTicker;\n                this.autoRefreshTicker = null;\n\n                if (ticker) {\n                  clearInterval(ticker);\n                }\n\n              case 3:\n              case \"end\":\n                return _context28.stop();\n            }\n          }\n        }, _callee28, this);\n      }));\n    }\n    /**\r\n     * Starts an auto-refresh process in the background. The session is checked\r\n     * every few seconds. Close to the time of expiration a process is started to\r\n     * refresh the session. If refreshing fails it will be retried for as long as\r\n     * necessary.\r\n     *\r\n     * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need\r\n     * to call this function, it will be called for you.\r\n     *\r\n     * On browsers the refresh process works only when the tab/window is in the\r\n     * foreground to conserve resources as well as prevent race conditions and\r\n     * flooding auth with requests. If you call this method any managed\r\n     * visibility change callback will be removed and you must manage visibility\r\n     * changes on your own.\r\n     *\r\n     * On non-browser platforms the refresh process works *continuously* in the\r\n     * background, which may not be desireable. You should hook into your\r\n     * platform's foreground indication mechanism and call these methods\r\n     * appropriately to conserve resources.\r\n     *\r\n     * {@see #stopAutoRefresh}\r\n     */\n\n  }, {\n    key: \"startAutoRefresh\",\n    value: function startAutoRefresh() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee29() {\n        return _regeneratorRuntime().wrap(function _callee29$(_context29) {\n          while (1) {\n            switch (_context29.prev = _context29.next) {\n              case 0:\n                this._removeVisibilityChangedCallback();\n\n                _context29.next = 3;\n                return this._startAutoRefresh();\n\n              case 3:\n              case \"end\":\n                return _context29.stop();\n            }\n          }\n        }, _callee29, this);\n      }));\n    }\n    /**\r\n     * Stops an active auto refresh process running in the background (if any).\r\n     *\r\n     * If you call this method any managed visibility change callback will be\r\n     * removed and you must manage visibility changes on your own.\r\n     *\r\n     * See {@link #startAutoRefresh} for more details.\r\n     */\n\n  }, {\n    key: \"stopAutoRefresh\",\n    value: function stopAutoRefresh() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee30() {\n        return _regeneratorRuntime().wrap(function _callee30$(_context30) {\n          while (1) {\n            switch (_context30.prev = _context30.next) {\n              case 0:\n                this._removeVisibilityChangedCallback();\n\n                _context30.next = 3;\n                return this._stopAutoRefresh();\n\n              case 3:\n              case \"end\":\n                return _context30.stop();\n            }\n          }\n        }, _callee30, this);\n      }));\n    }\n    /**\r\n     * Runs the auto refresh token tick.\r\n     */\n\n  }, {\n    key: \"_autoRefreshTokenTick\",\n    value: function _autoRefreshTokenTick() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee31() {\n        var now, _yield$this$getSessio6, session, expiresInTicks;\n\n        return _regeneratorRuntime().wrap(function _callee31$(_context31) {\n          while (1) {\n            switch (_context31.prev = _context31.next) {\n              case 0:\n                now = Date.now();\n                _context31.prev = 1;\n                _context31.next = 4;\n                return this.getSession();\n\n              case 4:\n                _yield$this$getSessio6 = _context31.sent;\n                session = _yield$this$getSessio6.data.session;\n\n                if (!(!session || !session.refresh_token || !session.expires_at)) {\n                  _context31.next = 8;\n                  break;\n                }\n\n                return _context31.abrupt(\"return\");\n\n              case 8:\n                // session will expire in this many ticks (or has already expired if <= 0)\n                expiresInTicks = Math.floor((session.expires_at * 1000 - now) / AUTO_REFRESH_TICK_DURATION);\n\n                if (!(expiresInTicks < AUTO_REFRESH_TICK_THRESHOLD)) {\n                  _context31.next = 12;\n                  break;\n                }\n\n                _context31.next = 12;\n                return this._callRefreshToken(session.refresh_token);\n\n              case 12:\n                _context31.next = 17;\n                break;\n\n              case 14:\n                _context31.prev = 14;\n                _context31.t0 = _context31[\"catch\"](1);\n                console.error('Auto refresh tick failed with error. This is likely a transient error.', _context31.t0);\n\n              case 17:\n              case \"end\":\n                return _context31.stop();\n            }\n          }\n        }, _callee31, this, [[1, 14]]);\n      }));\n    }\n    /**\r\n     * Registers callbacks on the browser / platform, which in-turn run\r\n     * algorithms when the browser window/tab are in foreground. On non-browser\r\n     * platforms it assumes always foreground.\r\n     */\n\n  }, {\n    key: \"_handleVisibilityChange\",\n    value: function _handleVisibilityChange() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee33() {\n        var _this6 = this;\n\n        return _regeneratorRuntime().wrap(function _callee33$(_context33) {\n          while (1) {\n            switch (_context33.prev = _context33.next) {\n              case 0:\n                if (!(!isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener))) {\n                  _context33.next = 3;\n                  break;\n                }\n\n                if (this.autoRefreshToken) {\n                  // in non-browser environments the refresh token ticker runs always\n                  this.startAutoRefresh();\n                }\n\n                return _context33.abrupt(\"return\", false);\n\n              case 3:\n                _context33.prev = 3;\n\n                this.visibilityChangedCallback = function () {\n                  return __awaiter(_this6, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee32() {\n                    return _regeneratorRuntime().wrap(function _callee32$(_context32) {\n                      while (1) {\n                        switch (_context32.prev = _context32.next) {\n                          case 0:\n                            _context32.next = 2;\n                            return this._onVisibilityChanged(false);\n\n                          case 2:\n                            return _context32.abrupt(\"return\", _context32.sent);\n\n                          case 3:\n                          case \"end\":\n                            return _context32.stop();\n                        }\n                      }\n                    }, _callee32, this);\n                  }));\n                };\n\n                window === null || window === void 0 ? void 0 : window.addEventListener('visibilitychange', this.visibilityChangedCallback); // now immediately call the visbility changed callback to setup with the\n                // current visbility state\n\n                _context33.next = 8;\n                return this._onVisibilityChanged(true);\n\n              case 8:\n                _context33.next = 13;\n                break;\n\n              case 10:\n                _context33.prev = 10;\n                _context33.t0 = _context33[\"catch\"](3);\n                console.error('_handleVisibilityChange', _context33.t0);\n\n              case 13:\n              case \"end\":\n                return _context33.stop();\n            }\n          }\n        }, _callee33, this, [[3, 10]]);\n      }));\n    }\n    /**\r\n     * Callback registered with `window.addEventListener('visibilitychange')`.\r\n     */\n\n  }, {\n    key: \"_onVisibilityChanged\",\n    value: function _onVisibilityChanged(isInitial) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee34() {\n        return _regeneratorRuntime().wrap(function _callee34$(_context34) {\n          while (1) {\n            switch (_context34.prev = _context34.next) {\n              case 0:\n                if (!(document.visibilityState === 'visible')) {\n                  _context34.next = 9;\n                  break;\n                }\n\n                if (isInitial) {\n                  _context34.next = 6;\n                  break;\n                }\n\n                _context34.next = 4;\n                return this.initializePromise;\n\n              case 4:\n                _context34.next = 6;\n                return this._recoverAndRefresh();\n\n              case 6:\n                if (this.autoRefreshToken) {\n                  // in browser environments the refresh token ticker runs only on focused tabs\n                  // which prevents race conditions\n                  this._startAutoRefresh();\n                }\n\n                _context34.next = 10;\n                break;\n\n              case 9:\n                if (document.visibilityState === 'hidden') {\n                  if (this.autoRefreshToken) {\n                    this._stopAutoRefresh();\n                  }\n                }\n\n              case 10:\n              case \"end\":\n                return _context34.stop();\n            }\n          }\n        }, _callee34, this);\n      }));\n    }\n    /**\r\n     * Generates the relevant login URL for a third-party provider.\r\n     * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.\r\n     * @param options.scopes A space-separated list of scopes granted to the OAuth application.\r\n     * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.\r\n     * @param options.flowType OAuth flow to use - defaults to implicit flow. PKCE is recommended for mobile and server-side applications.\r\n     */\n\n  }, {\n    key: \"_getUrlForProvider\",\n    value: function _getUrlForProvider(provider, options) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee35() {\n        var urlParams, codeVerifier, codeChallenge, flowParams, query;\n        return _regeneratorRuntime().wrap(function _callee35$(_context35) {\n          while (1) {\n            switch (_context35.prev = _context35.next) {\n              case 0:\n                urlParams = [\"provider=\".concat(encodeURIComponent(provider))];\n\n                if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n                  urlParams.push(\"redirect_to=\".concat(encodeURIComponent(options.redirectTo)));\n                }\n\n                if (options === null || options === void 0 ? void 0 : options.scopes) {\n                  urlParams.push(\"scopes=\".concat(encodeURIComponent(options.scopes)));\n                }\n\n                if (!((options === null || options === void 0 ? void 0 : options.flowType) === 'pkce')) {\n                  _context35.next = 12;\n                  break;\n                }\n\n                codeVerifier = generatePKCEVerifier();\n                _context35.next = 7;\n                return setItemAsync(this.storage, \"\".concat(this.storageKey, \"-code-verifier\"), codeVerifier);\n\n              case 7:\n                _context35.next = 9;\n                return generatePKCEChallenge(codeVerifier);\n\n              case 9:\n                codeChallenge = _context35.sent;\n                flowParams = new URLSearchParams({\n                  flow_type: \"\".concat(encodeURIComponent(options.flowType)),\n                  code_challenge: \"\".concat(encodeURIComponent(codeChallenge)),\n                  code_challenge_method: \"\".concat(encodeURIComponent('s256'))\n                });\n                urlParams.push(flowParams.toString());\n\n              case 12:\n                if (options === null || options === void 0 ? void 0 : options.queryParams) {\n                  query = new URLSearchParams(options.queryParams);\n                  urlParams.push(query.toString());\n                }\n\n                return _context35.abrupt(\"return\", \"\".concat(this.url, \"/authorize?\").concat(urlParams.join('&')));\n\n              case 14:\n              case \"end\":\n                return _context35.stop();\n            }\n          }\n        }, _callee35, this);\n      }));\n    }\n  }, {\n    key: \"_unenroll\",\n    value: function _unenroll(params) {\n      var _a;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee36() {\n        var _yield$this$getSessio7, sessionData, sessionError;\n\n        return _regeneratorRuntime().wrap(function _callee36$(_context36) {\n          while (1) {\n            switch (_context36.prev = _context36.next) {\n              case 0:\n                _context36.prev = 0;\n                _context36.next = 3;\n                return this.getSession();\n\n              case 3:\n                _yield$this$getSessio7 = _context36.sent;\n                sessionData = _yield$this$getSessio7.data;\n                sessionError = _yield$this$getSessio7.error;\n\n                if (!sessionError) {\n                  _context36.next = 8;\n                  break;\n                }\n\n                return _context36.abrupt(\"return\", {\n                  data: null,\n                  error: sessionError\n                });\n\n              case 8:\n                _context36.next = 10;\n                return _request(this.fetch, 'DELETE', \"\".concat(this.url, \"/factors/\").concat(params.factorId), {\n                  headers: this.headers,\n                  jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                });\n\n              case 10:\n                return _context36.abrupt(\"return\", _context36.sent);\n\n              case 13:\n                _context36.prev = 13;\n                _context36.t0 = _context36[\"catch\"](0);\n\n                if (!isAuthError(_context36.t0)) {\n                  _context36.next = 17;\n                  break;\n                }\n\n                return _context36.abrupt(\"return\", {\n                  data: null,\n                  error: _context36.t0\n                });\n\n              case 17:\n                throw _context36.t0;\n\n              case 18:\n              case \"end\":\n                return _context36.stop();\n            }\n          }\n        }, _callee36, this, [[0, 13]]);\n      }));\n    }\n    /**\r\n     * {@see GoTrueMFAApi#enroll}\r\n     */\n\n  }, {\n    key: \"_enroll\",\n    value: function _enroll(params) {\n      var _a, _b;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee37() {\n        var _yield$this$getSessio8, sessionData, sessionError, _yield$_request6, data, error;\n\n        return _regeneratorRuntime().wrap(function _callee37$(_context37) {\n          while (1) {\n            switch (_context37.prev = _context37.next) {\n              case 0:\n                _context37.prev = 0;\n                _context37.next = 3;\n                return this.getSession();\n\n              case 3:\n                _yield$this$getSessio8 = _context37.sent;\n                sessionData = _yield$this$getSessio8.data;\n                sessionError = _yield$this$getSessio8.error;\n\n                if (!sessionError) {\n                  _context37.next = 8;\n                  break;\n                }\n\n                return _context37.abrupt(\"return\", {\n                  data: null,\n                  error: sessionError\n                });\n\n              case 8:\n                _context37.next = 10;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/factors\"), {\n                  body: {\n                    friendly_name: params.friendlyName,\n                    factor_type: params.factorType,\n                    issuer: params.issuer\n                  },\n                  headers: this.headers,\n                  jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                });\n\n              case 10:\n                _yield$_request6 = _context37.sent;\n                data = _yield$_request6.data;\n                error = _yield$_request6.error;\n\n                if (!error) {\n                  _context37.next = 15;\n                  break;\n                }\n\n                return _context37.abrupt(\"return\", {\n                  data: null,\n                  error: error\n                });\n\n              case 15:\n                if ((_b = data === null || data === void 0 ? void 0 : data.totp) === null || _b === void 0 ? void 0 : _b.qr_code) {\n                  data.totp.qr_code = \"data:image/svg+xml;utf-8,\".concat(data.totp.qr_code);\n                }\n\n                return _context37.abrupt(\"return\", {\n                  data: data,\n                  error: null\n                });\n\n              case 19:\n                _context37.prev = 19;\n                _context37.t0 = _context37[\"catch\"](0);\n\n                if (!isAuthError(_context37.t0)) {\n                  _context37.next = 23;\n                  break;\n                }\n\n                return _context37.abrupt(\"return\", {\n                  data: null,\n                  error: _context37.t0\n                });\n\n              case 23:\n                throw _context37.t0;\n\n              case 24:\n              case \"end\":\n                return _context37.stop();\n            }\n          }\n        }, _callee37, this, [[0, 19]]);\n      }));\n    }\n    /**\r\n     * {@see GoTrueMFAApi#verify}\r\n     */\n\n  }, {\n    key: \"_verify\",\n    value: function _verify(params) {\n      var _a;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee38() {\n        var _yield$this$getSessio9, sessionData, sessionError, _yield$_request7, data, error;\n\n        return _regeneratorRuntime().wrap(function _callee38$(_context38) {\n          while (1) {\n            switch (_context38.prev = _context38.next) {\n              case 0:\n                _context38.prev = 0;\n                _context38.next = 3;\n                return this.getSession();\n\n              case 3:\n                _yield$this$getSessio9 = _context38.sent;\n                sessionData = _yield$this$getSessio9.data;\n                sessionError = _yield$this$getSessio9.error;\n\n                if (!sessionError) {\n                  _context38.next = 8;\n                  break;\n                }\n\n                return _context38.abrupt(\"return\", {\n                  data: null,\n                  error: sessionError\n                });\n\n              case 8:\n                _context38.next = 10;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/factors/\").concat(params.factorId, \"/verify\"), {\n                  body: {\n                    code: params.code,\n                    challenge_id: params.challengeId\n                  },\n                  headers: this.headers,\n                  jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                });\n\n              case 10:\n                _yield$_request7 = _context38.sent;\n                data = _yield$_request7.data;\n                error = _yield$_request7.error;\n\n                if (!error) {\n                  _context38.next = 15;\n                  break;\n                }\n\n                return _context38.abrupt(\"return\", {\n                  data: null,\n                  error: error\n                });\n\n              case 15:\n                _context38.next = 17;\n                return this._saveSession(Object.assign({\n                  expires_at: Math.round(Date.now() / 1000) + data.expires_in\n                }, data));\n\n              case 17:\n                this._notifyAllSubscribers('MFA_CHALLENGE_VERIFIED', data);\n\n                return _context38.abrupt(\"return\", {\n                  data: data,\n                  error: error\n                });\n\n              case 21:\n                _context38.prev = 21;\n                _context38.t0 = _context38[\"catch\"](0);\n\n                if (!isAuthError(_context38.t0)) {\n                  _context38.next = 25;\n                  break;\n                }\n\n                return _context38.abrupt(\"return\", {\n                  data: null,\n                  error: _context38.t0\n                });\n\n              case 25:\n                throw _context38.t0;\n\n              case 26:\n              case \"end\":\n                return _context38.stop();\n            }\n          }\n        }, _callee38, this, [[0, 21]]);\n      }));\n    }\n    /**\r\n     * {@see GoTrueMFAApi#challenge}\r\n     */\n\n  }, {\n    key: \"_challenge\",\n    value: function _challenge(params) {\n      var _a;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee39() {\n        var _yield$this$getSessio10, sessionData, sessionError;\n\n        return _regeneratorRuntime().wrap(function _callee39$(_context39) {\n          while (1) {\n            switch (_context39.prev = _context39.next) {\n              case 0:\n                _context39.prev = 0;\n                _context39.next = 3;\n                return this.getSession();\n\n              case 3:\n                _yield$this$getSessio10 = _context39.sent;\n                sessionData = _yield$this$getSessio10.data;\n                sessionError = _yield$this$getSessio10.error;\n\n                if (!sessionError) {\n                  _context39.next = 8;\n                  break;\n                }\n\n                return _context39.abrupt(\"return\", {\n                  data: null,\n                  error: sessionError\n                });\n\n              case 8:\n                _context39.next = 10;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/factors/\").concat(params.factorId, \"/challenge\"), {\n                  headers: this.headers,\n                  jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                });\n\n              case 10:\n                return _context39.abrupt(\"return\", _context39.sent);\n\n              case 13:\n                _context39.prev = 13;\n                _context39.t0 = _context39[\"catch\"](0);\n\n                if (!isAuthError(_context39.t0)) {\n                  _context39.next = 17;\n                  break;\n                }\n\n                return _context39.abrupt(\"return\", {\n                  data: null,\n                  error: _context39.t0\n                });\n\n              case 17:\n                throw _context39.t0;\n\n              case 18:\n              case \"end\":\n                return _context39.stop();\n            }\n          }\n        }, _callee39, this, [[0, 13]]);\n      }));\n    }\n    /**\r\n     * {@see GoTrueMFAApi#challengeAndVerify}\r\n     */\n\n  }, {\n    key: \"_challengeAndVerify\",\n    value: function _challengeAndVerify(params) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee40() {\n        var _yield$this$_challeng, challengeData, challengeError;\n\n        return _regeneratorRuntime().wrap(function _callee40$(_context40) {\n          while (1) {\n            switch (_context40.prev = _context40.next) {\n              case 0:\n                _context40.next = 2;\n                return this._challenge({\n                  factorId: params.factorId\n                });\n\n              case 2:\n                _yield$this$_challeng = _context40.sent;\n                challengeData = _yield$this$_challeng.data;\n                challengeError = _yield$this$_challeng.error;\n\n                if (!challengeError) {\n                  _context40.next = 7;\n                  break;\n                }\n\n                return _context40.abrupt(\"return\", {\n                  data: null,\n                  error: challengeError\n                });\n\n              case 7:\n                _context40.next = 9;\n                return this._verify({\n                  factorId: params.factorId,\n                  challengeId: challengeData.id,\n                  code: params.code\n                });\n\n              case 9:\n                return _context40.abrupt(\"return\", _context40.sent);\n\n              case 10:\n              case \"end\":\n                return _context40.stop();\n            }\n          }\n        }, _callee40, this);\n      }));\n    }\n    /**\r\n     * {@see GoTrueMFAApi#listFactors}\r\n     */\n\n  }, {\n    key: \"_listFactors\",\n    value: function _listFactors() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee41() {\n        var _yield$this$getUser3, user, userError, factors, totp;\n\n        return _regeneratorRuntime().wrap(function _callee41$(_context41) {\n          while (1) {\n            switch (_context41.prev = _context41.next) {\n              case 0:\n                _context41.next = 2;\n                return this.getUser();\n\n              case 2:\n                _yield$this$getUser3 = _context41.sent;\n                user = _yield$this$getUser3.data.user;\n                userError = _yield$this$getUser3.error;\n\n                if (!userError) {\n                  _context41.next = 7;\n                  break;\n                }\n\n                return _context41.abrupt(\"return\", {\n                  data: null,\n                  error: userError\n                });\n\n              case 7:\n                factors = (user === null || user === void 0 ? void 0 : user.factors) || [];\n                totp = factors.filter(function (factor) {\n                  return factor.factor_type === 'totp' && factor.status === 'verified';\n                });\n                return _context41.abrupt(\"return\", {\n                  data: {\n                    all: factors,\n                    totp: totp\n                  },\n                  error: null\n                });\n\n              case 10:\n              case \"end\":\n                return _context41.stop();\n            }\n          }\n        }, _callee41, this);\n      }));\n    }\n    /**\r\n     * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}\r\n     */\n\n  }, {\n    key: \"_getAuthenticatorAssuranceLevel\",\n    value: function _getAuthenticatorAssuranceLevel() {\n      var _a, _b;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee42() {\n        var _yield$this$getSessio11, session, sessionError, payload, currentLevel, nextLevel, verifiedFactors, currentAuthenticationMethods;\n\n        return _regeneratorRuntime().wrap(function _callee42$(_context42) {\n          while (1) {\n            switch (_context42.prev = _context42.next) {\n              case 0:\n                _context42.next = 2;\n                return this.getSession();\n\n              case 2:\n                _yield$this$getSessio11 = _context42.sent;\n                session = _yield$this$getSessio11.data.session;\n                sessionError = _yield$this$getSessio11.error;\n\n                if (!sessionError) {\n                  _context42.next = 7;\n                  break;\n                }\n\n                return _context42.abrupt(\"return\", {\n                  data: null,\n                  error: sessionError\n                });\n\n              case 7:\n                if (session) {\n                  _context42.next = 9;\n                  break;\n                }\n\n                return _context42.abrupt(\"return\", {\n                  data: {\n                    currentLevel: null,\n                    nextLevel: null,\n                    currentAuthenticationMethods: []\n                  },\n                  error: null\n                });\n\n              case 9:\n                payload = this._decodeJWT(session.access_token);\n                currentLevel = null;\n\n                if (payload.aal) {\n                  currentLevel = payload.aal;\n                }\n\n                nextLevel = currentLevel;\n                verifiedFactors = (_b = (_a = session.user.factors) === null || _a === void 0 ? void 0 : _a.filter(function (factor) {\n                  return factor.status === 'verified';\n                })) !== null && _b !== void 0 ? _b : [];\n\n                if (verifiedFactors.length > 0) {\n                  nextLevel = 'aal2';\n                }\n\n                currentAuthenticationMethods = payload.amr || [];\n                return _context42.abrupt(\"return\", {\n                  data: {\n                    currentLevel: currentLevel,\n                    nextLevel: nextLevel,\n                    currentAuthenticationMethods: currentAuthenticationMethods\n                  },\n                  error: null\n                });\n\n              case 17:\n              case \"end\":\n                return _context42.stop();\n            }\n          }\n        }, _callee42, this);\n      }));\n    }\n  }]);\n\n  return GoTrueClient;\n}();\n\nexport { GoTrueClient as default };","map":{"version":3,"mappings":"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","names":["GoTrueAdminApi","DEFAULT_HEADERS","EXPIRY_MARGIN","GOTRUE_URL","STORAGE_KEY","AuthImplicitGrantRedirectError","AuthPKCEGrantCodeExchangeError","AuthInvalidCredentialsError","AuthRetryableFetchError","AuthSessionMissingError","AuthUnknownError","isAuthApiError","isAuthError","_request","_sessionResponse","_userResponse","_ssoResponse","decodeJWTPayload","Deferred","getItemAsync","getParameterByName","isBrowser","removeItemAsync","resolveFetch","setItemAsync","uuid","retryable","sleep","generatePKCEVerifier","generatePKCEChallenge","localStorageAdapter","polyfillGlobalThis","DEFAULT_OPTIONS","url","storageKey","autoRefreshToken","persistSession","detectSessionInUrl","headers","flowType","AUTO_REFRESH_TICK_DURATION","AUTO_REFRESH_TICK_THRESHOLD","GoTrueClient","options","Map","settings","inMemorySession","storage","admin","fetch","mfa","verify","_verify","bind","enroll","_enroll","unenroll","_unenroll","challenge","_challenge","listFactors","_listFactors","challengeAndVerify","_challengeAndVerify","getAuthenticatorAssuranceLevel","_getAuthenticatorAssuranceLevel","globalThis","BroadcastChannel","broadcastChannel","e","console","error","_a","addEventListener","event","_notifyAllSubscribers","data","session","initialize","initializePromise","_initialize","_isPKCEFlow","isPKCEFlow","_isImplicitGrantFlow","_getSessionFromUrl","_removeSession","redirectType","_saveSession","setTimeout","_recoverAndRefresh","_handleVisibilityChange","credentials","email","password","redirectTo","emailRedirectTo","body","gotrue_meta_security","captcha_token","captchaToken","xform","res","phone","_b","channel","_c","user","_handleProviderSignIn","provider","scopes","queryParams","skipBrowserRedirect","_d","_e","authCode","codeVerifier","auth_code","code_verifier","token","nonce","id_token","create_user","shouldCreateUser","params","Error","access_token","provider_id","providerId","domain","redirect_to","undefined","skip_http_redirect","currentSession","maybeSession","_isValidSession","hasExpired","expires_at","Date","now","_callRefreshToken","refresh_token","jwt","getSession","attributes","sessionData","sessionError","userError","timeNow","expiresAt","payload","exp","refreshedSession","getUser","token_type","expires_in","exchangeCodeForSession","error_description","error_code","code","provider_token","provider_refresh_token","Math","round","parseInt","window","location","hash","Boolean","currentStorageContent","accessToken","signOut","status","callback","id","subscription","unsubscribe","stateChangeEmitters","delete","set","emitInitialSession","get","refreshToken","startedAt","attempt","__awaiter","_","result","isValidSession","_getUrlForProvider","assign","Infinity","log","message","refreshingDeferred","promise","_refreshAccessToken","resolve","reject","broadcast","postMessage","forEach","x","_persistSession","visibilityChangedCallback","removeEventListener","_stopAutoRefresh","ticker","setInterval","_autoRefreshTokenTick","autoRefreshTicker","unref","clearInterval","_removeVisibilityChangedCallback","_startAutoRefresh","expiresInTicks","floor","startAutoRefresh","_onVisibilityChanged","isInitial","document","visibilityState","urlParams","encodeURIComponent","push","codeChallenge","flowParams","URLSearchParams","flow_type","code_challenge","code_challenge_method","toString","query","join","factorId","friendly_name","friendlyName","factor_type","factorType","issuer","totp","qr_code","challenge_id","challengeId","Object","challengeData","challengeError","factors","filter","factor","all","currentLevel","nextLevel","currentAuthenticationMethods","_decodeJWT","aal","verifiedFactors","length","amr"],"sources":["C:\\Users\\mumta\\crewmates\\client\\node_modules\\@supabase\\gotrue-js\\src\\GoTrueClient.ts"],"sourcesContent":["import GoTrueAdminApi from './GoTrueAdminApi'\r\nimport { DEFAULT_HEADERS, EXPIRY_MARGIN, GOTRUE_URL, STORAGE_KEY } from './lib/constants'\r\nimport {\r\n  AuthError,\r\n  AuthImplicitGrantRedirectError,\r\n  AuthPKCEGrantCodeExchangeError,\r\n  AuthInvalidCredentialsError,\r\n  AuthRetryableFetchError,\r\n  AuthSessionMissingError,\r\n  AuthUnknownError,\r\n  isAuthApiError,\r\n  isAuthError,\r\n} from './lib/errors'\r\nimport { Fetch, _request, _sessionResponse, _userResponse, _ssoResponse } from './lib/fetch'\r\nimport {\r\n  decodeJWTPayload,\r\n  Deferred,\r\n  getItemAsync,\r\n  getParameterByName,\r\n  isBrowser,\r\n  removeItemAsync,\r\n  resolveFetch,\r\n  setItemAsync,\r\n  uuid,\r\n  retryable,\r\n  sleep,\r\n  generatePKCEVerifier,\r\n  generatePKCEChallenge,\r\n} from './lib/helpers'\r\nimport localStorageAdapter from './lib/local-storage'\r\nimport { polyfillGlobalThis } from './lib/polyfills'\r\n\r\nimport type {\r\n  AuthChangeEvent,\r\n  AuthResponse,\r\n  CallRefreshTokenResult,\r\n  GoTrueClientOptions,\r\n  InitializeResult,\r\n  OAuthResponse,\r\n  SSOResponse,\r\n  Provider,\r\n  Session,\r\n  SignInWithIdTokenCredentials,\r\n  SignInWithOAuthCredentials,\r\n  SignInWithPasswordCredentials,\r\n  SignInWithPasswordlessCredentials,\r\n  SignUpWithPasswordCredentials,\r\n  SignInWithSSO,\r\n  Subscription,\r\n  SupportedStorage,\r\n  User,\r\n  UserAttributes,\r\n  UserResponse,\r\n  VerifyOtpParams,\r\n  GoTrueMFAApi,\r\n  MFAEnrollParams,\r\n  AuthMFAEnrollResponse,\r\n  MFAChallengeParams,\r\n  AuthMFAChallengeResponse,\r\n  MFAUnenrollParams,\r\n  AuthMFAUnenrollResponse,\r\n  MFAVerifyParams,\r\n  AuthMFAVerifyResponse,\r\n  AuthMFAListFactorsResponse,\r\n  AMREntry,\r\n  AuthMFAGetAuthenticatorAssuranceLevelResponse,\r\n  AuthenticatorAssuranceLevels,\r\n  Factor,\r\n  MFAChallengeAndVerifyParams,\r\n  AuthFlowType,\r\n} from './lib/types'\r\n\r\npolyfillGlobalThis() // Make \"globalThis\" available\r\n\r\nconst DEFAULT_OPTIONS: Omit<Required<GoTrueClientOptions>, 'fetch' | 'storage'> = {\r\n  url: GOTRUE_URL,\r\n  storageKey: STORAGE_KEY,\r\n  autoRefreshToken: true,\r\n  persistSession: true,\r\n  detectSessionInUrl: true,\r\n  headers: DEFAULT_HEADERS,\r\n  flowType: 'implicit',\r\n}\r\n\r\n/** Current session will be checked for refresh at this interval. */\r\nconst AUTO_REFRESH_TICK_DURATION = 10 * 1000\r\n\r\n/**\r\n * A token refresh will be attempted this many ticks before the current session expires. */\r\nconst AUTO_REFRESH_TICK_THRESHOLD = 3\r\n\r\nexport default class GoTrueClient {\r\n  /**\r\n   * Namespace for the GoTrue admin methods.\r\n   * These methods should only be used in a trusted server-side environment.\r\n   */\r\n  admin: GoTrueAdminApi\r\n  /**\r\n   * Namespace for the MFA methods.\r\n   */\r\n  mfa: GoTrueMFAApi\r\n  /**\r\n   * The storage key used to identify the values saved in localStorage\r\n   */\r\n  protected storageKey: string\r\n\r\n  /**\r\n   * The session object for the currently logged in user. If null, it means there isn't a logged-in user.\r\n   * Only used if persistSession is false.\r\n   */\r\n  protected inMemorySession: Session | null\r\n\r\n  protected flowType: AuthFlowType\r\n\r\n  protected autoRefreshToken: boolean\r\n  protected persistSession: boolean\r\n  protected storage: SupportedStorage\r\n  protected stateChangeEmitters: Map<string, Subscription> = new Map()\r\n  protected autoRefreshTicker: ReturnType<typeof setInterval> | null = null\r\n  protected visibilityChangedCallback: (() => Promise<any>) | null = null\r\n  protected refreshingDeferred: Deferred<CallRefreshTokenResult> | null = null\r\n  /**\r\n   * Keeps track of the async client initialization.\r\n   * When null or not yet resolved the auth state is `unknown`\r\n   * Once resolved the the auth state is known and it's save to call any further client methods.\r\n   * Keep extra care to never reject or throw uncaught errors\r\n   */\r\n  protected initializePromise: Promise<InitializeResult> | null = null\r\n  protected detectSessionInUrl = true\r\n  protected url: string\r\n  protected headers: {\r\n    [key: string]: string\r\n  }\r\n  protected fetch: Fetch\r\n\r\n  /**\r\n   * Used to broadcast state change events to other tabs listening.\r\n   */\r\n  protected broadcastChannel: BroadcastChannel | null = null\r\n\r\n  /**\r\n   * Create a new client for use in the browser.\r\n   */\r\n  constructor(options: GoTrueClientOptions) {\r\n    const settings = { ...DEFAULT_OPTIONS, ...options }\r\n    this.inMemorySession = null\r\n    this.storageKey = settings.storageKey\r\n    this.autoRefreshToken = settings.autoRefreshToken\r\n    this.persistSession = settings.persistSession\r\n    this.storage = settings.storage || localStorageAdapter\r\n    this.admin = new GoTrueAdminApi({\r\n      url: settings.url,\r\n      headers: settings.headers,\r\n      fetch: settings.fetch,\r\n    })\r\n\r\n    this.url = settings.url\r\n    this.headers = settings.headers\r\n    this.fetch = resolveFetch(settings.fetch)\r\n    this.detectSessionInUrl = settings.detectSessionInUrl\r\n    this.flowType = settings.flowType\r\n\r\n    this.mfa = {\r\n      verify: this._verify.bind(this),\r\n      enroll: this._enroll.bind(this),\r\n      unenroll: this._unenroll.bind(this),\r\n      challenge: this._challenge.bind(this),\r\n      listFactors: this._listFactors.bind(this),\r\n      challengeAndVerify: this._challengeAndVerify.bind(this),\r\n      getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this),\r\n    }\r\n\r\n    if (isBrowser() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {\r\n      try {\r\n        this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey)\r\n      } catch (e: any) {\r\n        console.error(\r\n          'Failed to create a new BroadcastChannel, multi-tab state changes will not be available',\r\n          e\r\n        )\r\n      }\r\n\r\n      this.broadcastChannel?.addEventListener('message', (event) => {\r\n        this._notifyAllSubscribers(event.data.event, event.data.session, false) // broadcast = false so we don't get an endless loop of messages\r\n      })\r\n    }\r\n\r\n    this.initialize()\r\n  }\r\n\r\n  /**\r\n   * Initializes the client session either from the url or from storage.\r\n   * This method is automatically called when instantiating the client, but should also be called\r\n   * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).\r\n   */\r\n  initialize(): Promise<InitializeResult> {\r\n    if (!this.initializePromise) {\r\n      this.initializePromise = this._initialize()\r\n    }\r\n\r\n    return this.initializePromise\r\n  }\r\n\r\n  /**\r\n   * IMPORTANT:\r\n   * 1. Never throw in this method, as it is called from the constructor\r\n   * 2. Never return a session from this method as it would be cached over\r\n   *    the whole lifetime of the client\r\n   */\r\n  private async _initialize(): Promise<InitializeResult> {\r\n    if (this.initializePromise) {\r\n      return this.initializePromise\r\n    }\r\n\r\n    try {\r\n      const isPKCEFlow = await this._isPKCEFlow()\r\n      if ((this.detectSessionInUrl && this._isImplicitGrantFlow()) || isPKCEFlow) {\r\n        const { data, error } = await this._getSessionFromUrl(isPKCEFlow)\r\n\r\n        if (error) {\r\n          // failed login attempt via url,\r\n          // remove old session as in verifyOtp, signUp and signInWith*\r\n          await this._removeSession()\r\n\r\n          return { error }\r\n        }\r\n\r\n        const { session, redirectType } = data\r\n\r\n        await this._saveSession(session)\r\n\r\n        setTimeout(() => {\r\n          if (redirectType === 'recovery') {\r\n            this._notifyAllSubscribers('PASSWORD_RECOVERY', session)\r\n          } else {\r\n            this._notifyAllSubscribers('SIGNED_IN', session)\r\n          }\r\n        }, 0)\r\n\r\n        return { error: null }\r\n      }\r\n\r\n      // no login attempt via callback url try to recover session from storage\r\n      await this._recoverAndRefresh()\r\n      return { error: null }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { error }\r\n      }\r\n\r\n      return {\r\n        error: new AuthUnknownError('Unexpected error during initialization', error),\r\n      }\r\n    } finally {\r\n      await this._handleVisibilityChange()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a new user.\r\n   *\r\n   * Be aware that if a user account exists in the system you may get back an\r\n   * error message that attempts to hide this information from the user.\r\n   *\r\n   * @returns A logged-in session if the server has \"autoconfirm\" ON\r\n   * @returns A user if the server has \"autoconfirm\" OFF\r\n   */\r\n  async signUp(credentials: SignUpWithPasswordCredentials): Promise<AuthResponse> {\r\n    try {\r\n      await this._removeSession()\r\n\r\n      let res: AuthResponse\r\n      if ('email' in credentials) {\r\n        const { email, password, options } = credentials\r\n        res = await _request(this.fetch, 'POST', `${this.url}/signup`, {\r\n          headers: this.headers,\r\n          redirectTo: options?.emailRedirectTo,\r\n          body: {\r\n            email,\r\n            password,\r\n            data: options?.data ?? {},\r\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\r\n          },\r\n          xform: _sessionResponse,\r\n        })\r\n      } else if ('phone' in credentials) {\r\n        const { phone, password, options } = credentials\r\n        res = await _request(this.fetch, 'POST', `${this.url}/signup`, {\r\n          headers: this.headers,\r\n          body: {\r\n            phone,\r\n            password,\r\n            data: options?.data ?? {},\r\n            channel: options?.channel ?? 'sms',\r\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\r\n          },\r\n          xform: _sessionResponse,\r\n        })\r\n      } else {\r\n        throw new AuthInvalidCredentialsError(\r\n          'You must provide either an email or phone number and a password'\r\n        )\r\n      }\r\n\r\n      const { data, error } = res\r\n\r\n      if (error || !data) {\r\n        return { data: { user: null, session: null }, error: error }\r\n      }\r\n\r\n      const session: Session | null = data.session\r\n      const user: User | null = data.user\r\n\r\n      if (data.session) {\r\n        await this._saveSession(data.session)\r\n        this._notifyAllSubscribers('SIGNED_IN', session)\r\n      }\r\n\r\n      return { data: { user, session }, error: null }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { user: null, session: null }, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Log in an existing user with an email and password or phone and password.\r\n   *\r\n   * Be aware that you may get back an error message that will not distinguish\r\n   * between the cases where the account does not exist or that the\r\n   * email/phone and password combination is wrong or that the account can only\r\n   * be accessed via social login.\r\n   */\r\n  async signInWithPassword(credentials: SignInWithPasswordCredentials): Promise<AuthResponse> {\r\n    try {\r\n      await this._removeSession()\r\n\r\n      let res: AuthResponse\r\n      if ('email' in credentials) {\r\n        const { email, password, options } = credentials\r\n        res = await _request(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\r\n          headers: this.headers,\r\n          body: {\r\n            email,\r\n            password,\r\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\r\n          },\r\n          xform: _sessionResponse,\r\n        })\r\n      } else if ('phone' in credentials) {\r\n        const { phone, password, options } = credentials\r\n        res = await _request(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\r\n          headers: this.headers,\r\n          body: {\r\n            phone,\r\n            password,\r\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\r\n          },\r\n          xform: _sessionResponse,\r\n        })\r\n      } else {\r\n        throw new AuthInvalidCredentialsError(\r\n          'You must provide either an email or phone number and a password'\r\n        )\r\n      }\r\n      const { data, error } = res\r\n      if (error || !data) return { data: { user: null, session: null }, error }\r\n      if (data.session) {\r\n        await this._saveSession(data.session)\r\n        this._notifyAllSubscribers('SIGNED_IN', data.session)\r\n      }\r\n      return { data, error }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { user: null, session: null }, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Log in an existing user via a third-party provider.\r\n   */\r\n  async signInWithOAuth(credentials: SignInWithOAuthCredentials): Promise<OAuthResponse> {\r\n    await this._removeSession()\r\n\r\n    return await this._handleProviderSignIn(credentials.provider, {\r\n      redirectTo: credentials.options?.redirectTo,\r\n      scopes: credentials.options?.scopes,\r\n      queryParams: credentials.options?.queryParams,\r\n      skipBrowserRedirect: credentials.options?.skipBrowserRedirect,\r\n      flowType: this.flowType ?? 'implicit',\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Log in an existing user via a third-party provider.\r\n   */\r\n  async exchangeCodeForSession(authCode: string): Promise<AuthResponse> {\r\n    const codeVerifier = await getItemAsync(this.storage, `${this.storageKey}-code-verifier`)\r\n    const { data, error } = await _request(\r\n      this.fetch,\r\n      'POST',\r\n      `${this.url}/token?grant_type=pkce`,\r\n      {\r\n        headers: this.headers,\r\n        body: {\r\n          auth_code: authCode,\r\n          code_verifier: codeVerifier,\r\n        },\r\n        xform: _sessionResponse,\r\n      }\r\n    )\r\n    await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`)\r\n    if (error || !data) return { data: { user: null, session: null }, error }\r\n    if (data.session) {\r\n      await this._saveSession(data.session)\r\n      this._notifyAllSubscribers('SIGNED_IN', data.session)\r\n    }\r\n    return { data, error }\r\n  }\r\n\r\n  /**\r\n   * Allows signing in with an ID token issued by certain supported providers.\r\n   * The ID token is verified for validity and a new session is established.\r\n   *\r\n   * @experimental\r\n   */\r\n  async signInWithIdToken(credentials: SignInWithIdTokenCredentials): Promise<AuthResponse> {\r\n    await this._removeSession()\r\n\r\n    try {\r\n      const { options, provider, token, nonce } = credentials\r\n\r\n      const res = await _request(this.fetch, 'POST', `${this.url}/token?grant_type=id_token`, {\r\n        headers: this.headers,\r\n        body: {\r\n          provider,\r\n          id_token: token,\r\n          nonce,\r\n          gotrue_meta_security: { captcha_token: options?.captchaToken },\r\n        },\r\n        xform: _sessionResponse,\r\n      })\r\n\r\n      const { data, error } = res\r\n      if (error || !data) return { data: { user: null, session: null }, error }\r\n      if (data.session) {\r\n        await this._saveSession(data.session)\r\n        this._notifyAllSubscribers('SIGNED_IN', data.session)\r\n      }\r\n      return { data, error }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { user: null, session: null }, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Log in a user using magiclink or a one-time password (OTP).\r\n   *\r\n   * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.\r\n   * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.\r\n   * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.\r\n   *\r\n   * Be aware that you may get back an error message that will not distinguish\r\n   * between the cases where the account does not exist or, that the account\r\n   * can only be accessed via social login.\r\n   *\r\n   * Do note that you will need to configure a Whatsapp sender on Twilio\r\n   * if you are using phone sign in with the 'whatsapp' channel. The whatsapp\r\n   * channel is not supported on other providers\r\n   * at this time.\r\n   */\r\n  async signInWithOtp(credentials: SignInWithPasswordlessCredentials): Promise<AuthResponse> {\r\n    try {\r\n      await this._removeSession()\r\n\r\n      if ('email' in credentials) {\r\n        const { email, options } = credentials\r\n        const { error } = await _request(this.fetch, 'POST', `${this.url}/otp`, {\r\n          headers: this.headers,\r\n          body: {\r\n            email,\r\n            data: options?.data ?? {},\r\n            create_user: options?.shouldCreateUser ?? true,\r\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\r\n          },\r\n          redirectTo: options?.emailRedirectTo,\r\n        })\r\n        return { data: { user: null, session: null }, error }\r\n      }\r\n      if ('phone' in credentials) {\r\n        const { phone, options } = credentials\r\n        const { error } = await _request(this.fetch, 'POST', `${this.url}/otp`, {\r\n          headers: this.headers,\r\n          body: {\r\n            phone,\r\n            data: options?.data ?? {},\r\n            create_user: options?.shouldCreateUser ?? true,\r\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\r\n            channel: options?.channel ?? 'sms',\r\n          },\r\n        })\r\n        return { data: { user: null, session: null }, error }\r\n      }\r\n      throw new AuthInvalidCredentialsError('You must provide either an email or phone number.')\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { user: null, session: null }, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Log in a user given a User supplied OTP received via mobile.\r\n   */\r\n  async verifyOtp(params: VerifyOtpParams): Promise<AuthResponse> {\r\n    try {\r\n      await this._removeSession()\r\n\r\n      const { data, error } = await _request(this.fetch, 'POST', `${this.url}/verify`, {\r\n        headers: this.headers,\r\n        body: {\r\n          ...params,\r\n          gotrue_meta_security: { captcha_token: params.options?.captchaToken },\r\n        },\r\n        redirectTo: params.options?.redirectTo,\r\n        xform: _sessionResponse,\r\n      })\r\n\r\n      if (error) {\r\n        throw error\r\n      }\r\n\r\n      if (!data) {\r\n        throw new Error('An error occurred on token verification.')\r\n      }\r\n\r\n      const session: Session | null = data.session\r\n      const user: User = data.user\r\n\r\n      if (session?.access_token) {\r\n        await this._saveSession(session as Session)\r\n        this._notifyAllSubscribers('SIGNED_IN', session)\r\n      }\r\n\r\n      return { data: { user, session }, error: null }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { user: null, session: null }, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Attempts a single-sign on using an enterprise Identity Provider. A\r\n   * successful SSO attempt will redirect the current page to the identity\r\n   * provider authorization page. The redirect URL is implementation and SSO\r\n   * protocol specific.\r\n   *\r\n   * You can use it by providing a SSO domain. Typically you can extract this\r\n   * domain by asking users for their email address. If this domain is\r\n   * registered on the Auth instance the redirect will use that organization's\r\n   * currently active SSO Identity Provider for the login.\r\n   *\r\n   * If you have built an organization-specific login page, you can use the\r\n   * organization's SSO Identity Provider UUID directly instead.\r\n   */\r\n  async signInWithSSO(params: SignInWithSSO): Promise<SSOResponse> {\r\n    try {\r\n      await this._removeSession()\r\n\r\n      return await _request(this.fetch, 'POST', `${this.url}/sso`, {\r\n        body: {\r\n          ...('providerId' in params ? { provider_id: params.providerId } : null),\r\n          ...('domain' in params ? { domain: params.domain } : null),\r\n          redirect_to: params.options?.redirectTo ?? undefined,\r\n          ...(params?.options?.captchaToken\r\n            ? { gotrue_meta_security: { captcha_token: params.options.captchaToken } }\r\n            : null),\r\n          skip_http_redirect: true, // fetch does not handle redirects\r\n        },\r\n        headers: this.headers,\r\n        xform: _ssoResponse,\r\n      })\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: null, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the session, refreshing it if necessary.\r\n   * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.\r\n   */\r\n  async getSession(): Promise<\r\n    | {\r\n        data: {\r\n          session: Session\r\n        }\r\n        error: null\r\n      }\r\n    | {\r\n        data: {\r\n          session: null\r\n        }\r\n        error: AuthError\r\n      }\r\n    | {\r\n        data: {\r\n          session: null\r\n        }\r\n        error: null\r\n      }\r\n  > {\r\n    // make sure we've read the session from the url if there is one\r\n    // save to just await, as long we make sure _initialize() never throws\r\n    await this.initializePromise\r\n\r\n    let currentSession: Session | null = null\r\n\r\n    if (this.persistSession) {\r\n      const maybeSession = await getItemAsync(this.storage, this.storageKey)\r\n\r\n      if (maybeSession !== null) {\r\n        if (this._isValidSession(maybeSession)) {\r\n          currentSession = maybeSession\r\n        } else {\r\n          await this._removeSession()\r\n        }\r\n      }\r\n    } else {\r\n      currentSession = this.inMemorySession\r\n    }\r\n\r\n    if (!currentSession) {\r\n      return { data: { session: null }, error: null }\r\n    }\r\n\r\n    const hasExpired = currentSession.expires_at\r\n      ? currentSession.expires_at <= Date.now() / 1000\r\n      : false\r\n    if (!hasExpired) {\r\n      return { data: { session: currentSession }, error: null }\r\n    }\r\n\r\n    const { session, error } = await this._callRefreshToken(currentSession.refresh_token)\r\n    if (error) {\r\n      return { data: { session: null }, error }\r\n    }\r\n\r\n    return { data: { session }, error: null }\r\n  }\r\n\r\n  /**\r\n   * Gets the current user details if there is an existing session.\r\n   * @param jwt Takes in an optional access token jwt. If no jwt is provided, getUser() will attempt to get the jwt from the current session.\r\n   */\r\n  async getUser(jwt?: string): Promise<UserResponse> {\r\n    try {\r\n      if (!jwt) {\r\n        const { data, error } = await this.getSession()\r\n        if (error) {\r\n          throw error\r\n        }\r\n\r\n        // Default to Authorization header if there is no existing session\r\n        jwt = data.session?.access_token ?? undefined\r\n      }\r\n\r\n      return await _request(this.fetch, 'GET', `${this.url}/user`, {\r\n        headers: this.headers,\r\n        jwt: jwt,\r\n        xform: _userResponse,\r\n      })\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { user: null }, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates user data for a logged in user.\r\n   */\r\n  async updateUser(\r\n    attributes: UserAttributes,\r\n    options: {\r\n      emailRedirectTo?: string | undefined\r\n    } = {}\r\n  ): Promise<UserResponse> {\r\n    try {\r\n      const { data: sessionData, error: sessionError } = await this.getSession()\r\n      if (sessionError) {\r\n        throw sessionError\r\n      }\r\n      if (!sessionData.session) {\r\n        throw new AuthSessionMissingError()\r\n      }\r\n      const session: Session = sessionData.session\r\n      const { data, error: userError } = await _request(this.fetch, 'PUT', `${this.url}/user`, {\r\n        headers: this.headers,\r\n        redirectTo: options?.emailRedirectTo,\r\n        body: attributes,\r\n        jwt: session.access_token,\r\n        xform: _userResponse,\r\n      })\r\n      if (userError) throw userError\r\n      session.user = data.user as User\r\n      await this._saveSession(session)\r\n      this._notifyAllSubscribers('USER_UPDATED', session)\r\n\r\n      return { data: { user: session.user }, error: null }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { user: null }, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Decodes a JWT (without performing any validation).\r\n   */\r\n  private _decodeJWT(jwt: string): {\r\n    exp?: number\r\n    aal?: AuthenticatorAssuranceLevels | null\r\n    amr?: AMREntry[] | null\r\n  } {\r\n    return decodeJWTPayload(jwt)\r\n  }\r\n\r\n  /**\r\n   * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.\r\n   * If the refresh token or access token in the current session is invalid, an error will be thrown.\r\n   * @param currentSession The current session that minimally contains an access token and refresh token.\r\n   */\r\n  async setSession(currentSession: {\r\n    access_token: string\r\n    refresh_token: string\r\n  }): Promise<AuthResponse> {\r\n    try {\r\n      if (!currentSession.access_token || !currentSession.refresh_token) {\r\n        throw new AuthSessionMissingError()\r\n      }\r\n\r\n      const timeNow = Date.now() / 1000\r\n      let expiresAt = timeNow\r\n      let hasExpired = true\r\n      let session: Session | null = null\r\n      const payload = decodeJWTPayload(currentSession.access_token)\r\n      if (payload.exp) {\r\n        expiresAt = payload.exp\r\n        hasExpired = expiresAt <= timeNow\r\n      }\r\n\r\n      if (hasExpired) {\r\n        const { session: refreshedSession, error } = await this._callRefreshToken(\r\n          currentSession.refresh_token\r\n        )\r\n        if (error) {\r\n          return { data: { user: null, session: null }, error: error }\r\n        }\r\n\r\n        if (!refreshedSession) {\r\n          return { data: { user: null, session: null }, error: null }\r\n        }\r\n        session = refreshedSession\r\n      } else {\r\n        const { data, error } = await this.getUser(currentSession.access_token)\r\n        if (error) {\r\n          throw error\r\n        }\r\n        session = {\r\n          access_token: currentSession.access_token,\r\n          refresh_token: currentSession.refresh_token,\r\n          user: data.user,\r\n          token_type: 'bearer',\r\n          expires_in: expiresAt - timeNow,\r\n          expires_at: expiresAt,\r\n        }\r\n        await this._saveSession(session)\r\n        this._notifyAllSubscribers('SIGNED_IN', session)\r\n      }\r\n\r\n      return { data: { user: session.user, session }, error: null }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { session: null, user: null }, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns a new session, regardless of expiry status.\r\n   * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().\r\n   * If the current session's refresh token is invalid, an error will be thrown.\r\n   * @param currentSession The current session. If passed in, it must contain a refresh token.\r\n   */\r\n  async refreshSession(currentSession?: { refresh_token: string }): Promise<AuthResponse> {\r\n    try {\r\n      if (!currentSession) {\r\n        const { data, error } = await this.getSession()\r\n        if (error) {\r\n          throw error\r\n        }\r\n\r\n        currentSession = data.session ?? undefined\r\n      }\r\n\r\n      if (!currentSession?.refresh_token) {\r\n        throw new AuthSessionMissingError()\r\n      }\r\n\r\n      const { session, error } = await this._callRefreshToken(currentSession.refresh_token)\r\n      if (error) {\r\n        return { data: { user: null, session: null }, error: error }\r\n      }\r\n\r\n      if (!session) {\r\n        return { data: { user: null, session: null }, error: null }\r\n      }\r\n\r\n      return { data: { user: session.user, session }, error: null }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { user: null, session: null }, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the session data from a URL string\r\n   */\r\n  private async _getSessionFromUrl(isPKCEFlow: boolean): Promise<\r\n    | {\r\n        data: { session: Session; redirectType: string | null }\r\n        error: null\r\n      }\r\n    | { data: { session: null; redirectType: null }; error: AuthError }\r\n  > {\r\n    try {\r\n      if (!isBrowser()) throw new AuthImplicitGrantRedirectError('No browser detected.')\r\n      if (this.flowType == 'implicit' && !this._isImplicitGrantFlow()) {\r\n        throw new AuthImplicitGrantRedirectError('Not a valid implicit grant flow url.')\r\n      } else if (this.flowType == 'pkce' && !isPKCEFlow) {\r\n        throw new AuthPKCEGrantCodeExchangeError('Not a valid PKCE flow url.')\r\n      }\r\n      if (isPKCEFlow) {\r\n        const authCode = getParameterByName('code')\r\n        if (!authCode) throw new AuthPKCEGrantCodeExchangeError('No code detected.')\r\n        const { data, error } = await this.exchangeCodeForSession(authCode)\r\n        if (error) throw error\r\n        if (!data.session) throw new AuthPKCEGrantCodeExchangeError('No session detected.')\r\n        return { data: { session: data.session, redirectType: null }, error: null }\r\n      }\r\n\r\n      const error_description = getParameterByName('error_description')\r\n      if (error_description) {\r\n        const error_code = getParameterByName('error_code')\r\n        if (!error_code) throw new AuthImplicitGrantRedirectError('No error_code detected.')\r\n        const error = getParameterByName('error')\r\n        if (!error) throw new AuthImplicitGrantRedirectError('No error detected.')\r\n\r\n        throw new AuthImplicitGrantRedirectError(error_description, { error, code: error_code })\r\n      }\r\n\r\n      const provider_token = getParameterByName('provider_token')\r\n      const provider_refresh_token = getParameterByName('provider_refresh_token')\r\n      const access_token = getParameterByName('access_token')\r\n      if (!access_token) throw new AuthImplicitGrantRedirectError('No access_token detected.')\r\n      const expires_in = getParameterByName('expires_in')\r\n      if (!expires_in) throw new AuthImplicitGrantRedirectError('No expires_in detected.')\r\n      const refresh_token = getParameterByName('refresh_token')\r\n      if (!refresh_token) throw new AuthImplicitGrantRedirectError('No refresh_token detected.')\r\n      const token_type = getParameterByName('token_type')\r\n      if (!token_type) throw new AuthImplicitGrantRedirectError('No token_type detected.')\r\n\r\n      const timeNow = Math.round(Date.now() / 1000)\r\n      const expires_at = timeNow + parseInt(expires_in)\r\n\r\n      const { data, error } = await this.getUser(access_token)\r\n      if (error) throw error\r\n      const user: User = data.user\r\n      const session: Session = {\r\n        provider_token,\r\n        provider_refresh_token,\r\n        access_token,\r\n        expires_in: parseInt(expires_in),\r\n        expires_at,\r\n        refresh_token,\r\n        token_type,\r\n        user,\r\n      }\r\n      const redirectType = getParameterByName('type')\r\n\r\n      // Remove tokens from URL\r\n      window.location.hash = ''\r\n\r\n      return { data: { session, redirectType }, error: null }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { session: null, redirectType: null }, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)\r\n   */\r\n  private _isImplicitGrantFlow(): boolean {\r\n    return (\r\n      isBrowser() &&\r\n      (Boolean(getParameterByName('access_token')) ||\r\n        Boolean(getParameterByName('error_description')))\r\n    )\r\n  }\r\n  /**\r\n   * Checks if the current URL and backing storage contain parameters given by a PKCE flow\r\n   */\r\n  private async _isPKCEFlow(): Promise<boolean> {\r\n    const currentStorageContent = await getItemAsync(\r\n      this.storage,\r\n      `${this.storageKey}-code-verifier`\r\n    )\r\n    return isBrowser() && Boolean(getParameterByName('code')) && Boolean(currentStorageContent)\r\n  }\r\n\r\n  /**\r\n   * Inside a browser context, `signOut()` will remove the logged in user from the browser session\r\n   * and log them out - removing all items from localstorage and then trigger a `\"SIGNED_OUT\"` event.\r\n   *\r\n   * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.\r\n   * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.\r\n   */\r\n  async signOut(): Promise<{ error: AuthError | null }> {\r\n    const { data, error: sessionError } = await this.getSession()\r\n    if (sessionError) {\r\n      return { error: sessionError }\r\n    }\r\n    const accessToken = data.session?.access_token\r\n    if (accessToken) {\r\n      const { error } = await this.admin.signOut(accessToken)\r\n      if (error) {\r\n        // ignore 404s since user might not exist anymore\r\n        // ignore 401s since an invalid or expired JWT should sign out the current session\r\n        if (!(isAuthApiError(error) && (error.status === 404 || error.status === 401))) {\r\n          return { error }\r\n        }\r\n      }\r\n    }\r\n    await this._removeSession()\r\n    this._notifyAllSubscribers('SIGNED_OUT', null)\r\n    return { error: null }\r\n  }\r\n\r\n  /**\r\n   * Receive a notification every time an auth event happens.\r\n   * @param callback A callback function to be invoked when an auth event happens.\r\n   */\r\n  onAuthStateChange(callback: (event: AuthChangeEvent, session: Session | null) => void): {\r\n    data: { subscription: Subscription }\r\n  } {\r\n    const id: string = uuid()\r\n    const subscription: Subscription = {\r\n      id,\r\n      callback,\r\n      unsubscribe: () => {\r\n        this.stateChangeEmitters.delete(id)\r\n      },\r\n    }\r\n\r\n    this.stateChangeEmitters.set(id, subscription)\r\n\r\n    this.emitInitialSession(id)\r\n\r\n    return { data: { subscription } }\r\n  }\r\n\r\n  private async emitInitialSession(id: string): Promise<void> {\r\n    try {\r\n      const {\r\n        data: { session },\r\n        error,\r\n      } = await this.getSession()\r\n      if (error) throw error\r\n\r\n      this.stateChangeEmitters.get(id)?.callback('INITIAL_SESSION', session)\r\n    } catch (err) {\r\n      this.stateChangeEmitters.get(id)?.callback('INITIAL_SESSION', null)\r\n      console.error(err)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sends a password reset request to an email address.\r\n   * @param email The email address of the user.\r\n   * @param options.redirectTo The URL to send the user to after they click the password reset link.\r\n   * @param options.captchaToken Verification token received when the user completes the captcha on the site.\r\n   */\r\n  async resetPasswordForEmail(\r\n    email: string,\r\n    options: {\r\n      redirectTo?: string\r\n      captchaToken?: string\r\n    } = {}\r\n  ): Promise<\r\n    | {\r\n        data: {}\r\n        error: null\r\n      }\r\n    | { data: null; error: AuthError }\r\n  > {\r\n    try {\r\n      return await _request(this.fetch, 'POST', `${this.url}/recover`, {\r\n        body: { email, gotrue_meta_security: { captcha_token: options.captchaToken } },\r\n        headers: this.headers,\r\n        redirectTo: options.redirectTo,\r\n      })\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: null, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generates a new JWT.\r\n   * @param refreshToken A valid refresh token that was returned on login.\r\n   */\r\n  private async _refreshAccessToken(refreshToken: string): Promise<AuthResponse> {\r\n    try {\r\n      const startedAt = Date.now()\r\n\r\n      // will attempt to refresh the token with exponential backoff\r\n      return await retryable(\r\n        async (attempt) => {\r\n          await sleep(attempt * 200) // 0, 200, 400, 800, ...\r\n\r\n          return await _request(this.fetch, 'POST', `${this.url}/token?grant_type=refresh_token`, {\r\n            body: { refresh_token: refreshToken },\r\n            headers: this.headers,\r\n            xform: _sessionResponse,\r\n          })\r\n        },\r\n        (attempt, _, result) =>\r\n          result &&\r\n          result.error &&\r\n          result.error instanceof AuthRetryableFetchError &&\r\n          // retryable only if the request can be sent before the backoff overflows the tick duration\r\n          Date.now() + (attempt + 1) * 200 - startedAt < AUTO_REFRESH_TICK_DURATION\r\n      )\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { session: null, user: null }, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  private _isValidSession(maybeSession: unknown): maybeSession is Session {\r\n    const isValidSession =\r\n      typeof maybeSession === 'object' &&\r\n      maybeSession !== null &&\r\n      'access_token' in maybeSession &&\r\n      'refresh_token' in maybeSession &&\r\n      'expires_at' in maybeSession\r\n\r\n    return isValidSession\r\n  }\r\n\r\n  private async _handleProviderSignIn(\r\n    provider: Provider,\r\n    options: {\r\n      redirectTo?: string\r\n      scopes?: string\r\n      queryParams?: { [key: string]: string }\r\n      skipBrowserRedirect?: boolean\r\n      flowType: AuthFlowType\r\n    }\r\n  ) {\r\n    const url: string = await this._getUrlForProvider(provider, {\r\n      redirectTo: options.redirectTo,\r\n      scopes: options.scopes,\r\n      queryParams: options.queryParams,\r\n      flowType: options.flowType,\r\n    })\r\n    // try to open on the browser\r\n    if (isBrowser() && !options.skipBrowserRedirect) {\r\n      window.location.assign(url)\r\n    }\r\n\r\n    return { data: { provider, url }, error: null }\r\n  }\r\n\r\n  /**\r\n   * Recovers the session from LocalStorage and refreshes\r\n   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\r\n   */\r\n  private async _recoverAndRefresh() {\r\n    try {\r\n      const currentSession = await getItemAsync(this.storage, this.storageKey)\r\n      if (!this._isValidSession(currentSession)) {\r\n        if (currentSession !== null) {\r\n          await this._removeSession()\r\n        }\r\n\r\n        return\r\n      }\r\n\r\n      const timeNow = Math.round(Date.now() / 1000)\r\n\r\n      if ((currentSession.expires_at ?? Infinity) < timeNow + EXPIRY_MARGIN) {\r\n        if (this.autoRefreshToken && currentSession.refresh_token) {\r\n          const { error } = await this._callRefreshToken(currentSession.refresh_token)\r\n\r\n          if (error) {\r\n            console.log(error.message)\r\n            await this._removeSession()\r\n          }\r\n        } else {\r\n          await this._removeSession()\r\n        }\r\n      } else {\r\n        if (this.persistSession) {\r\n          await this._saveSession(currentSession)\r\n        }\r\n        this._notifyAllSubscribers('SIGNED_IN', currentSession)\r\n      }\r\n    } catch (err) {\r\n      console.error(err)\r\n      return\r\n    }\r\n  }\r\n\r\n  private async _callRefreshToken(refreshToken: string): Promise<CallRefreshTokenResult> {\r\n    // refreshing is already in progress\r\n    if (this.refreshingDeferred) {\r\n      return this.refreshingDeferred.promise\r\n    }\r\n\r\n    try {\r\n      this.refreshingDeferred = new Deferred<CallRefreshTokenResult>()\r\n\r\n      if (!refreshToken) {\r\n        throw new AuthSessionMissingError()\r\n      }\r\n      const { data, error } = await this._refreshAccessToken(refreshToken)\r\n      if (error) throw error\r\n      if (!data.session) throw new AuthSessionMissingError()\r\n\r\n      await this._saveSession(data.session)\r\n      this._notifyAllSubscribers('TOKEN_REFRESHED', data.session)\r\n\r\n      const result = { session: data.session, error: null }\r\n\r\n      this.refreshingDeferred.resolve(result)\r\n\r\n      return result\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        const result = { session: null, error }\r\n\r\n        this.refreshingDeferred?.resolve(result)\r\n\r\n        return result\r\n      }\r\n\r\n      this.refreshingDeferred?.reject(error)\r\n      throw error\r\n    } finally {\r\n      this.refreshingDeferred = null\r\n    }\r\n  }\r\n\r\n  private _notifyAllSubscribers(event: AuthChangeEvent, session: Session | null, broadcast = true) {\r\n    if (this.broadcastChannel && broadcast) {\r\n      this.broadcastChannel.postMessage({ event, session })\r\n    }\r\n\r\n    this.stateChangeEmitters.forEach((x) => x.callback(event, session))\r\n  }\r\n\r\n  /**\r\n   * set currentSession and currentUser\r\n   * process to _startAutoRefreshToken if possible\r\n   */\r\n  private async _saveSession(session: Session) {\r\n    if (!this.persistSession) {\r\n      this.inMemorySession = session\r\n    }\r\n\r\n    if (this.persistSession && session.expires_at) {\r\n      await this._persistSession(session)\r\n    }\r\n  }\r\n\r\n  private _persistSession(currentSession: Session) {\r\n    return setItemAsync(this.storage, this.storageKey, currentSession)\r\n  }\r\n\r\n  private async _removeSession() {\r\n    if (this.persistSession) {\r\n      await removeItemAsync(this.storage, this.storageKey)\r\n    } else {\r\n      this.inMemorySession = null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes any registered visibilitychange callback.\r\n   *\r\n   * {@see #startAutoRefresh}\r\n   * {@see #stopAutoRefresh}\r\n   */\r\n  private _removeVisibilityChangedCallback() {\r\n    const callback = this.visibilityChangedCallback\r\n    this.visibilityChangedCallback = null\r\n\r\n    try {\r\n      if (callback && isBrowser() && window?.removeEventListener) {\r\n        window.removeEventListener('visibilitychange', callback)\r\n      }\r\n    } catch (e) {\r\n      console.error('removing visibilitychange callback failed', e)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This is the private implementation of {@link #startAutoRefresh}. Use this\r\n   * within the library.\r\n   */\r\n  private async _startAutoRefresh() {\r\n    await this._stopAutoRefresh()\r\n\r\n    const ticker = setInterval(() => this._autoRefreshTokenTick(), AUTO_REFRESH_TICK_DURATION)\r\n    this.autoRefreshTicker = ticker\r\n\r\n    if (ticker && typeof ticker === 'object' && typeof ticker.unref === 'function') {\r\n      // ticker is a NodeJS Timeout object that has an `unref` method\r\n      // https://nodejs.org/api/timers.html#timeoutunref\r\n      // When auto refresh is used in NodeJS (like for testing) the\r\n      // `setInterval` is preventing the process from being marked as\r\n      // finished and tests run endlessly. This can be prevented by calling\r\n      // `unref()` on the returned object.\r\n      ticker.unref()\r\n    }\r\n\r\n    // run the tick immediately\r\n    await this._autoRefreshTokenTick()\r\n  }\r\n\r\n  /**\r\n   * This is the private implementation of {@link #stopAutoRefresh}. Use this\r\n   * within the library.\r\n   */\r\n  private async _stopAutoRefresh() {\r\n    const ticker = this.autoRefreshTicker\r\n    this.autoRefreshTicker = null\r\n\r\n    if (ticker) {\r\n      clearInterval(ticker)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Starts an auto-refresh process in the background. The session is checked\r\n   * every few seconds. Close to the time of expiration a process is started to\r\n   * refresh the session. If refreshing fails it will be retried for as long as\r\n   * necessary.\r\n   *\r\n   * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need\r\n   * to call this function, it will be called for you.\r\n   *\r\n   * On browsers the refresh process works only when the tab/window is in the\r\n   * foreground to conserve resources as well as prevent race conditions and\r\n   * flooding auth with requests. If you call this method any managed\r\n   * visibility change callback will be removed and you must manage visibility\r\n   * changes on your own.\r\n   *\r\n   * On non-browser platforms the refresh process works *continuously* in the\r\n   * background, which may not be desireable. You should hook into your\r\n   * platform's foreground indication mechanism and call these methods\r\n   * appropriately to conserve resources.\r\n   *\r\n   * {@see #stopAutoRefresh}\r\n   */\r\n  async startAutoRefresh() {\r\n    this._removeVisibilityChangedCallback()\r\n    await this._startAutoRefresh()\r\n  }\r\n\r\n  /**\r\n   * Stops an active auto refresh process running in the background (if any).\r\n   *\r\n   * If you call this method any managed visibility change callback will be\r\n   * removed and you must manage visibility changes on your own.\r\n   *\r\n   * See {@link #startAutoRefresh} for more details.\r\n   */\r\n  async stopAutoRefresh() {\r\n    this._removeVisibilityChangedCallback()\r\n    await this._stopAutoRefresh()\r\n  }\r\n\r\n  /**\r\n   * Runs the auto refresh token tick.\r\n   */\r\n  private async _autoRefreshTokenTick() {\r\n    const now = Date.now()\r\n\r\n    try {\r\n      const {\r\n        data: { session },\r\n      } = await this.getSession()\r\n\r\n      if (!session || !session.refresh_token || !session.expires_at) {\r\n        return\r\n      }\r\n\r\n      // session will expire in this many ticks (or has already expired if <= 0)\r\n      const expiresInTicks = Math.floor(\r\n        (session.expires_at * 1000 - now) / AUTO_REFRESH_TICK_DURATION\r\n      )\r\n\r\n      if (expiresInTicks < AUTO_REFRESH_TICK_THRESHOLD) {\r\n        await this._callRefreshToken(session.refresh_token)\r\n      }\r\n    } catch (e: any) {\r\n      console.error('Auto refresh tick failed with error. This is likely a transient error.', e)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Registers callbacks on the browser / platform, which in-turn run\r\n   * algorithms when the browser window/tab are in foreground. On non-browser\r\n   * platforms it assumes always foreground.\r\n   */\r\n  private async _handleVisibilityChange() {\r\n    if (!isBrowser() || !window?.addEventListener) {\r\n      if (this.autoRefreshToken) {\r\n        // in non-browser environments the refresh token ticker runs always\r\n        this.startAutoRefresh()\r\n      }\r\n\r\n      return false\r\n    }\r\n\r\n    try {\r\n      this.visibilityChangedCallback = async () => await this._onVisibilityChanged(false)\r\n\r\n      window?.addEventListener('visibilitychange', this.visibilityChangedCallback)\r\n\r\n      // now immediately call the visbility changed callback to setup with the\r\n      // current visbility state\r\n      await this._onVisibilityChanged(true) // initial call\r\n    } catch (error) {\r\n      console.error('_handleVisibilityChange', error)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Callback registered with `window.addEventListener('visibilitychange')`.\r\n   */\r\n  private async _onVisibilityChanged(isInitial: boolean) {\r\n    if (document.visibilityState === 'visible') {\r\n      if (!isInitial) {\r\n        // initial visibility change setup is handled in another flow under #initialize()\r\n        await this.initializePromise\r\n        await this._recoverAndRefresh()\r\n      }\r\n\r\n      if (this.autoRefreshToken) {\r\n        // in browser environments the refresh token ticker runs only on focused tabs\r\n        // which prevents race conditions\r\n        this._startAutoRefresh()\r\n      }\r\n    } else if (document.visibilityState === 'hidden') {\r\n      if (this.autoRefreshToken) {\r\n        this._stopAutoRefresh()\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generates the relevant login URL for a third-party provider.\r\n   * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.\r\n   * @param options.scopes A space-separated list of scopes granted to the OAuth application.\r\n   * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.\r\n   * @param options.flowType OAuth flow to use - defaults to implicit flow. PKCE is recommended for mobile and server-side applications.\r\n   */\r\n  private async _getUrlForProvider(\r\n    provider: Provider,\r\n    options: {\r\n      redirectTo?: string\r\n      scopes?: string\r\n      queryParams?: { [key: string]: string }\r\n      flowType: AuthFlowType\r\n    }\r\n  ) {\r\n    const urlParams: string[] = [`provider=${encodeURIComponent(provider)}`]\r\n    if (options?.redirectTo) {\r\n      urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`)\r\n    }\r\n    if (options?.scopes) {\r\n      urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`)\r\n    }\r\n    if (options?.flowType === 'pkce') {\r\n      const codeVerifier = generatePKCEVerifier()\r\n      await setItemAsync(this.storage, `${this.storageKey}-code-verifier`, codeVerifier)\r\n      const codeChallenge = await generatePKCEChallenge(codeVerifier)\r\n      const flowParams = new URLSearchParams({\r\n        flow_type: `${encodeURIComponent(options.flowType)}`,\r\n        code_challenge: `${encodeURIComponent(codeChallenge)}`,\r\n        code_challenge_method: `${encodeURIComponent('s256')}`,\r\n      })\r\n      urlParams.push(flowParams.toString())\r\n    }\r\n    if (options?.queryParams) {\r\n      const query = new URLSearchParams(options.queryParams)\r\n      urlParams.push(query.toString())\r\n    }\r\n\r\n    return `${this.url}/authorize?${urlParams.join('&')}`\r\n  }\r\n\r\n  private async _unenroll(params: MFAUnenrollParams): Promise<AuthMFAUnenrollResponse> {\r\n    try {\r\n      const { data: sessionData, error: sessionError } = await this.getSession()\r\n      if (sessionError) {\r\n        return { data: null, error: sessionError }\r\n      }\r\n\r\n      return await _request(this.fetch, 'DELETE', `${this.url}/factors/${params.factorId}`, {\r\n        headers: this.headers,\r\n        jwt: sessionData?.session?.access_token,\r\n      })\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: null, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * {@see GoTrueMFAApi#enroll}\r\n   */\r\n  private async _enroll(params: MFAEnrollParams): Promise<AuthMFAEnrollResponse> {\r\n    try {\r\n      const { data: sessionData, error: sessionError } = await this.getSession()\r\n      if (sessionError) {\r\n        return { data: null, error: sessionError }\r\n      }\r\n\r\n      const { data, error } = await _request(this.fetch, 'POST', `${this.url}/factors`, {\r\n        body: {\r\n          friendly_name: params.friendlyName,\r\n          factor_type: params.factorType,\r\n          issuer: params.issuer,\r\n        },\r\n        headers: this.headers,\r\n        jwt: sessionData?.session?.access_token,\r\n      })\r\n\r\n      if (error) {\r\n        return { data: null, error }\r\n      }\r\n\r\n      if (data?.totp?.qr_code) {\r\n        data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`\r\n      }\r\n\r\n      return { data, error: null }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: null, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * {@see GoTrueMFAApi#verify}\r\n   */\r\n  private async _verify(params: MFAVerifyParams): Promise<AuthMFAVerifyResponse> {\r\n    try {\r\n      const { data: sessionData, error: sessionError } = await this.getSession()\r\n      if (sessionError) {\r\n        return { data: null, error: sessionError }\r\n      }\r\n\r\n      const { data, error } = await _request(\r\n        this.fetch,\r\n        'POST',\r\n        `${this.url}/factors/${params.factorId}/verify`,\r\n        {\r\n          body: { code: params.code, challenge_id: params.challengeId },\r\n          headers: this.headers,\r\n          jwt: sessionData?.session?.access_token,\r\n        }\r\n      )\r\n      if (error) {\r\n        return { data: null, error }\r\n      }\r\n\r\n      await this._saveSession({\r\n        expires_at: Math.round(Date.now() / 1000) + data.expires_in,\r\n        ...data,\r\n      })\r\n      this._notifyAllSubscribers('MFA_CHALLENGE_VERIFIED', data)\r\n\r\n      return { data, error }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: null, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * {@see GoTrueMFAApi#challenge}\r\n   */\r\n  private async _challenge(params: MFAChallengeParams): Promise<AuthMFAChallengeResponse> {\r\n    try {\r\n      const { data: sessionData, error: sessionError } = await this.getSession()\r\n      if (sessionError) {\r\n        return { data: null, error: sessionError }\r\n      }\r\n\r\n      return await _request(\r\n        this.fetch,\r\n        'POST',\r\n        `${this.url}/factors/${params.factorId}/challenge`,\r\n        {\r\n          headers: this.headers,\r\n          jwt: sessionData?.session?.access_token,\r\n        }\r\n      )\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: null, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * {@see GoTrueMFAApi#challengeAndVerify}\r\n   */\r\n  private async _challengeAndVerify(\r\n    params: MFAChallengeAndVerifyParams\r\n  ): Promise<AuthMFAVerifyResponse> {\r\n    const { data: challengeData, error: challengeError } = await this._challenge({\r\n      factorId: params.factorId,\r\n    })\r\n    if (challengeError) {\r\n      return { data: null, error: challengeError }\r\n    }\r\n    return await this._verify({\r\n      factorId: params.factorId,\r\n      challengeId: challengeData.id,\r\n      code: params.code,\r\n    })\r\n  }\r\n\r\n  /**\r\n   * {@see GoTrueMFAApi#listFactors}\r\n   */\r\n  private async _listFactors(): Promise<AuthMFAListFactorsResponse> {\r\n    const {\r\n      data: { user },\r\n      error: userError,\r\n    } = await this.getUser()\r\n    if (userError) {\r\n      return { data: null, error: userError }\r\n    }\r\n\r\n    const factors = user?.factors || []\r\n    const totp = factors.filter(\r\n      (factor) => factor.factor_type === 'totp' && factor.status === 'verified'\r\n    )\r\n\r\n    return {\r\n      data: {\r\n        all: factors,\r\n        totp,\r\n      },\r\n      error: null,\r\n    }\r\n  }\r\n\r\n  /**\r\n   * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}\r\n   */\r\n  private async _getAuthenticatorAssuranceLevel(): Promise<AuthMFAGetAuthenticatorAssuranceLevelResponse> {\r\n    const {\r\n      data: { session },\r\n      error: sessionError,\r\n    } = await this.getSession()\r\n    if (sessionError) {\r\n      return { data: null, error: sessionError }\r\n    }\r\n    if (!session) {\r\n      return {\r\n        data: { currentLevel: null, nextLevel: null, currentAuthenticationMethods: [] },\r\n        error: null,\r\n      }\r\n    }\r\n\r\n    const payload = this._decodeJWT(session.access_token)\r\n\r\n    let currentLevel: AuthenticatorAssuranceLevels | null = null\r\n\r\n    if (payload.aal) {\r\n      currentLevel = payload.aal\r\n    }\r\n\r\n    let nextLevel: AuthenticatorAssuranceLevels | null = currentLevel\r\n\r\n    const verifiedFactors =\r\n      session.user.factors?.filter((factor: Factor) => factor.status === 'verified') ?? []\r\n\r\n    if (verifiedFactors.length > 0) {\r\n      nextLevel = 'aal2'\r\n    }\r\n\r\n    const currentAuthenticationMethods = payload.amr || []\r\n\r\n    return { data: { currentLevel, nextLevel, currentAuthenticationMethods }, error: null }\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}