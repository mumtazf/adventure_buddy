{"ast":null,"code":"import _slicedToArray from \"C:/Users/mumta/crewmates/client/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"C:/Users/mumta/crewmates/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/mumta/crewmates/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport PostgrestQueryBuilder from './PostgrestQueryBuilder';\nimport PostgrestFilterBuilder from './PostgrestFilterBuilder';\nimport { DEFAULT_HEADERS } from './constants';\n/**\r\n * PostgREST client.\r\n *\r\n * @typeParam Database - Types for the schema from the [type\r\n * generator](https://supabase.com/docs/reference/javascript/next/typescript-support)\r\n *\r\n * @typeParam SchemaName - Postgres schema to switch to. Must be a string\r\n * literal, the same one passed to the constructor. If the schema is not\r\n * `\"public\"`, this must be supplied manually.\r\n */\n\nvar PostgrestClient = /*#__PURE__*/function () {\n  // TODO: Add back shouldThrowOnError once we figure out the typings\n\n  /**\r\n   * Creates a PostgREST client.\r\n   *\r\n   * @param url - URL of the PostgREST endpoint\r\n   * @param options - Named parameters\r\n   * @param options.headers - Custom headers\r\n   * @param options.schema - Postgres schema to switch to\r\n   * @param options.fetch - Custom fetch\r\n   */\n  function PostgrestClient(url) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$headers = _ref.headers,\n        headers = _ref$headers === void 0 ? {} : _ref$headers,\n        schema = _ref.schema,\n        fetch = _ref.fetch;\n\n    _classCallCheck(this, PostgrestClient);\n\n    this.url = url;\n    this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS), headers);\n    this.schema = schema;\n    this.fetch = fetch;\n  }\n  /**\r\n   * Perform a query on a table or a view.\r\n   *\r\n   * @param relation - The table or view name to query\r\n   */\n\n\n  _createClass(PostgrestClient, [{\n    key: \"from\",\n    value: function from(relation) {\n      var url = new URL(\"\".concat(this.url, \"/\").concat(relation));\n      return new PostgrestQueryBuilder(url, {\n        headers: Object.assign({}, this.headers),\n        schema: this.schema,\n        fetch: this.fetch\n      });\n    }\n    /**\r\n     * Perform a function call.\r\n     *\r\n     * @param fn - The function name to call\r\n     * @param args - The arguments to pass to the function call\r\n     * @param options - Named parameters\r\n     * @param options.head - When set to `true`, `data` will not be returned.\r\n     * Useful if you only need the count.\r\n     * @param options.count - Count algorithm to use to count rows returned by the\r\n     * function. Only applicable for [set-returning\r\n     * functions](https://www.postgresql.org/docs/current/functions-srf.html).\r\n     *\r\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\r\n     * hood.\r\n     *\r\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\r\n     * statistics under the hood.\r\n     *\r\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\r\n     * numbers.\r\n     */\n\n  }, {\n    key: \"rpc\",\n    value: function rpc(fn) {\n      var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n          _ref2$head = _ref2.head,\n          head = _ref2$head === void 0 ? false : _ref2$head,\n          count = _ref2.count;\n\n      var method;\n      var url = new URL(\"\".concat(this.url, \"/rpc/\").concat(fn));\n      var body;\n\n      if (head) {\n        method = 'HEAD';\n        Object.entries(args).forEach(function (_ref3) {\n          var _ref4 = _slicedToArray(_ref3, 2),\n              name = _ref4[0],\n              value = _ref4[1];\n\n          url.searchParams.append(name, \"\".concat(value));\n        });\n      } else {\n        method = 'POST';\n        body = args;\n      }\n\n      var headers = Object.assign({}, this.headers);\n\n      if (count) {\n        headers['Prefer'] = \"count=\".concat(count);\n      }\n\n      return new PostgrestFilterBuilder({\n        method: method,\n        url: url,\n        headers: headers,\n        schema: this.schema,\n        body: body,\n        fetch: this.fetch,\n        allowEmpty: false\n      });\n    }\n  }]);\n\n  return PostgrestClient;\n}();\n\nexport { PostgrestClient as default };","map":{"version":3,"mappings":";;;AAAA,OAAOA,qBAAP,MAAkC,yBAAlC;AACA,OAAOC,sBAAP,MAAmC,0BAAnC;AAEA,SAASC,eAAT,QAAgC,aAAhC;AAGA;;;;;;;;;;;IAUqBC,e;EAcnB;;EACA;;;;;;;;;EASA,yBACEC,GADF,EAUQ;IAAA,+EAAF,EAAE;IAAA,wBAPJC,OAOI;IAAA,IAPJA,OAOI,6BAPM,EAON;IAAA,IANJC,MAMI,QANJA,MAMI;IAAA,IALJC,KAKI,QALJA,KAKI;;IAAA;;IAEN,KAAKH,GAAL,GAAWA,GAAX;IACA,KAAKC,OAAL,GAAYG,gCAAQN,eAAR,GAA4BG,OAA5B,CAAZ;IACA,KAAKC,MAAL,GAAcA,MAAd;IACA,KAAKC,KAAL,GAAaA,KAAb;EACD;EAUD;;;;;;;;;WAKA,cAAKE,QAAL,EAAqB;MACnB,IAAML,GAAG,GAAG,IAAIM,GAAJ,WAAW,KAAKN,GAAhB,cAAuBK,QAAvB,EAAZ;MACA,OAAO,IAAIT,qBAAJ,CAAuCI,GAAvC,EAA4C;QACjDC,OAAO,oBAAO,KAAKA,OAAZ,CAD0C;QAEjDC,MAAM,EAAE,KAAKA,MAFoC;QAGjDC,KAAK,EAAE,KAAKA;MAHqC,CAA5C,CAAP;IAKD;IAED;;;;;;;;;;;;;;;;;;;;;;;;WAqBA,aAIEI,EAJF,EAYQ;MAAA,IAPNC,IAOM,uEAPoB,EAOpB;;MAAA,gFAAF,EAAE;MAAA,uBALJC,IAKI;MAAA,IALJA,IAKI,2BALG,KAKH;MAAA,IAJJC,KAII,SAJJA,KAII;;MAUN,IAAIC,MAAJ;MACA,IAAMX,GAAG,GAAG,IAAIM,GAAJ,WAAW,KAAKN,GAAhB,kBAA2BO,EAA3B,EAAZ;MACA,IAAIK,IAAJ;;MACA,IAAIH,IAAJ,EAAU;QACRE,MAAM,GAAG,MAAT;QACAP,MAAM,CAACS,OAAP,CAAeL,IAAf,EAAqBM,OAArB,CAA6B,iBAAkB;UAAA;UAAA,IAAhBC,IAAgB;UAAA,IAAVC,KAAU;;UAC7ChB,GAAG,CAACiB,YAAJ,CAAiBC,MAAjB,CAAwBH,IAAxB,YAAiCC,KAAjC;QACD,CAFD;MAGD,CALD,MAKO;QACLL,MAAM,GAAG,MAAT;QACAC,IAAI,GAAGJ,IAAP;MACD;;MAED,IAAMP,OAAO,qBAAQ,KAAKA,OAAb,CAAb;;MACA,IAAIS,KAAJ,EAAW;QACTT,OAAO,CAAC,QAAD,CAAP,mBAA6BS,KAA7B;MACD;;MAED,OAAO,IAAIb,sBAAJ,CAA2B;QAChCc,MAAM,EAANA,MADgC;QAEhCX,GAAG,EAAHA,GAFgC;QAGhCC,OAAO,EAAPA,OAHgC;QAIhCC,MAAM,EAAE,KAAKA,MAJmB;QAKhCU,IAAI,EAAJA,IALgC;QAMhCT,KAAK,EAAE,KAAKA,KANoB;QAOhCgB,UAAU,EAAE;MAPoB,CAA3B,CAAP;IASD;;;;;;SAtIkBpB,e","names":["PostgrestQueryBuilder","PostgrestFilterBuilder","DEFAULT_HEADERS","PostgrestClient","url","headers","schema","fetch","Object","relation","URL","fn","args","head","count","method","body","entries","forEach","name","value","searchParams","append","allowEmpty"],"sources":["C:\\Users\\mumta\\crewmates\\client\\node_modules\\@supabase\\postgrest-js\\src\\PostgrestClient.ts"],"sourcesContent":["import PostgrestQueryBuilder from './PostgrestQueryBuilder'\r\nimport PostgrestFilterBuilder from './PostgrestFilterBuilder'\r\nimport PostgrestBuilder from './PostgrestBuilder'\r\nimport { DEFAULT_HEADERS } from './constants'\r\nimport { Fetch, GenericSchema } from './types'\r\n\r\n/**\r\n * PostgREST client.\r\n *\r\n * @typeParam Database - Types for the schema from the [type\r\n * generator](https://supabase.com/docs/reference/javascript/next/typescript-support)\r\n *\r\n * @typeParam SchemaName - Postgres schema to switch to. Must be a string\r\n * literal, the same one passed to the constructor. If the schema is not\r\n * `\"public\"`, this must be supplied manually.\r\n */\r\nexport default class PostgrestClient<\r\n  Database = any,\r\n  SchemaName extends string & keyof Database = 'public' extends keyof Database\r\n    ? 'public'\r\n    : string & keyof Database,\r\n  Schema extends GenericSchema = Database[SchemaName] extends GenericSchema\r\n    ? Database[SchemaName]\r\n    : any\r\n> {\r\n  url: string\r\n  headers: Record<string, string>\r\n  schema?: SchemaName\r\n  fetch?: Fetch\r\n\r\n  // TODO: Add back shouldThrowOnError once we figure out the typings\r\n  /**\r\n   * Creates a PostgREST client.\r\n   *\r\n   * @param url - URL of the PostgREST endpoint\r\n   * @param options - Named parameters\r\n   * @param options.headers - Custom headers\r\n   * @param options.schema - Postgres schema to switch to\r\n   * @param options.fetch - Custom fetch\r\n   */\r\n  constructor(\r\n    url: string,\r\n    {\r\n      headers = {},\r\n      schema,\r\n      fetch,\r\n    }: {\r\n      headers?: Record<string, string>\r\n      schema?: SchemaName\r\n      fetch?: Fetch\r\n    } = {}\r\n  ) {\r\n    this.url = url\r\n    this.headers = { ...DEFAULT_HEADERS, ...headers }\r\n    this.schema = schema\r\n    this.fetch = fetch\r\n  }\r\n\r\n  from<\r\n    TableName extends string & keyof Schema['Tables'],\r\n    Table extends Schema['Tables'][TableName]\r\n  >(relation: TableName): PostgrestQueryBuilder<Schema, Table>\r\n  from<ViewName extends string & keyof Schema['Views'], View extends Schema['Views'][ViewName]>(\r\n    relation: ViewName\r\n  ): PostgrestQueryBuilder<Schema, View>\r\n  from(relation: string): PostgrestQueryBuilder<Schema, any>\r\n  /**\r\n   * Perform a query on a table or a view.\r\n   *\r\n   * @param relation - The table or view name to query\r\n   */\r\n  from(relation: string): PostgrestQueryBuilder<Schema, any> {\r\n    const url = new URL(`${this.url}/${relation}`)\r\n    return new PostgrestQueryBuilder<Schema, any>(url, {\r\n      headers: { ...this.headers },\r\n      schema: this.schema,\r\n      fetch: this.fetch,\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Perform a function call.\r\n   *\r\n   * @param fn - The function name to call\r\n   * @param args - The arguments to pass to the function call\r\n   * @param options - Named parameters\r\n   * @param options.head - When set to `true`, `data` will not be returned.\r\n   * Useful if you only need the count.\r\n   * @param options.count - Count algorithm to use to count rows returned by the\r\n   * function. Only applicable for [set-returning\r\n   * functions](https://www.postgresql.org/docs/current/functions-srf.html).\r\n   *\r\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\r\n   * hood.\r\n   *\r\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\r\n   * statistics under the hood.\r\n   *\r\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\r\n   * numbers.\r\n   */\r\n  rpc<\r\n    FunctionName extends string & keyof Schema['Functions'],\r\n    Function_ extends Schema['Functions'][FunctionName]\r\n  >(\r\n    fn: FunctionName,\r\n    args: Function_['Args'] = {},\r\n    {\r\n      head = false,\r\n      count,\r\n    }: {\r\n      head?: boolean\r\n      count?: 'exact' | 'planned' | 'estimated'\r\n    } = {}\r\n  ): PostgrestFilterBuilder<\r\n    Schema,\r\n    Function_['Returns'] extends any[]\r\n      ? Function_['Returns'][number] extends Record<string, unknown>\r\n        ? Function_['Returns'][number]\r\n        : never\r\n      : never,\r\n    Function_['Returns']\r\n  > {\r\n    let method: 'HEAD' | 'POST'\r\n    const url = new URL(`${this.url}/rpc/${fn}`)\r\n    let body: unknown | undefined\r\n    if (head) {\r\n      method = 'HEAD'\r\n      Object.entries(args).forEach(([name, value]) => {\r\n        url.searchParams.append(name, `${value}`)\r\n      })\r\n    } else {\r\n      method = 'POST'\r\n      body = args\r\n    }\r\n\r\n    const headers = { ...this.headers }\r\n    if (count) {\r\n      headers['Prefer'] = `count=${count}`\r\n    }\r\n\r\n    return new PostgrestFilterBuilder({\r\n      method,\r\n      url,\r\n      headers,\r\n      schema: this.schema,\r\n      body,\r\n      fetch: this.fetch,\r\n      allowEmpty: false,\r\n    } as unknown as PostgrestBuilder<Function_['Returns']>)\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}