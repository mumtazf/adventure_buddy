{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { w3cwebsocket } from 'websocket';\nimport { VSN, CHANNEL_EVENTS, TRANSPORTS, SOCKET_STATES, DEFAULT_TIMEOUT, WS_CLOSE_NORMAL, DEFAULT_HEADERS, CONNECTION_STATE } from './lib/constants';\nimport Timer from './lib/timer';\nimport Serializer from './lib/serializer';\nimport RealtimeChannel from './RealtimeChannel';\n\nconst noop = () => {};\n\nexport default class RealtimeClient {\n  /**\r\n   * Initializes the Socket.\r\n   *\r\n   * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\r\n   * @param options.transport The Websocket Transport, for example WebSocket.\r\n   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\r\n   * @param options.params The optional params to pass when connecting.\r\n   * @param options.headers The optional headers to pass when connecting.\r\n   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\r\n   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\r\n   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\r\n   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\r\n   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\r\n   */\n  constructor(endPoint, options) {\n    var _a;\n\n    this.accessToken = null;\n    this.channels = [];\n    this.endPoint = '';\n    this.headers = DEFAULT_HEADERS;\n    this.params = {};\n    this.timeout = DEFAULT_TIMEOUT;\n    this.transport = w3cwebsocket;\n    this.heartbeatIntervalMs = 30000;\n    this.heartbeatTimer = undefined;\n    this.pendingHeartbeatRef = null;\n    this.ref = 0;\n    this.logger = noop;\n    this.conn = null;\n    this.sendBuffer = [];\n    this.serializer = new Serializer();\n    this.stateChangeCallbacks = {\n      open: [],\n      close: [],\n      error: [],\n      message: []\n    };\n    this.eventsPerSecondLimitMs = 100;\n    this.inThrottle = false;\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;\n    if (options === null || options === void 0 ? void 0 : options.params) this.params = options.params;\n    if (options === null || options === void 0 ? void 0 : options.headers) this.headers = Object.assign(Object.assign({}, this.headers), options.headers);\n    if (options === null || options === void 0 ? void 0 : options.timeout) this.timeout = options.timeout;\n    if (options === null || options === void 0 ? void 0 : options.logger) this.logger = options.logger;\n    if (options === null || options === void 0 ? void 0 : options.transport) this.transport = options.transport;\n    if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) this.heartbeatIntervalMs = options.heartbeatIntervalMs;\n    const eventsPerSecond = (_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.eventsPerSecond;\n    if (eventsPerSecond) this.eventsPerSecondLimitMs = Math.floor(1000 / eventsPerSecond);\n    this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs) ? options.reconnectAfterMs : tries => {\n      return [1000, 2000, 5000, 10000][tries - 1] || 10000;\n    };\n    this.encode = (options === null || options === void 0 ? void 0 : options.encode) ? options.encode : (payload, callback) => {\n      return callback(JSON.stringify(payload));\n    };\n    this.decode = (options === null || options === void 0 ? void 0 : options.decode) ? options.decode : this.serializer.decode.bind(this.serializer);\n    this.reconnectTimer = new Timer(() => __awaiter(this, void 0, void 0, function* () {\n      this.disconnect();\n      this.connect();\n    }), this.reconnectAfterMs);\n  }\n  /**\r\n   * Connects the socket, unless already connected.\r\n   */\n\n\n  connect() {\n    if (this.conn) {\n      return;\n    }\n\n    this.conn = new this.transport(this._endPointURL(), [], null, this.headers);\n\n    if (this.conn) {\n      this.conn.binaryType = 'arraybuffer';\n\n      this.conn.onopen = () => this._onConnOpen();\n\n      this.conn.onerror = error => this._onConnError(error);\n\n      this.conn.onmessage = event => this._onConnMessage(event);\n\n      this.conn.onclose = event => this._onConnClose(event);\n    }\n  }\n  /**\r\n   * Disconnects the socket.\r\n   *\r\n   * @param code A numeric status code to send on disconnect.\r\n   * @param reason A custom reason for the disconnect.\r\n   */\n\n\n  disconnect(code, reason) {\n    if (this.conn) {\n      this.conn.onclose = function () {}; // noop\n\n\n      if (code) {\n        this.conn.close(code, reason !== null && reason !== void 0 ? reason : '');\n      } else {\n        this.conn.close();\n      }\n\n      this.conn = null; // remove open handles\n\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n      this.reconnectTimer.reset();\n    }\n  }\n  /**\r\n   * Returns all created channels\r\n   */\n\n\n  getChannels() {\n    return this.channels;\n  }\n  /**\r\n   * Unsubscribes and removes a single channel\r\n   * @param channel A RealtimeChannel instance\r\n   */\n\n\n  removeChannel(channel) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const status = yield channel.unsubscribe();\n\n      if (this.channels.length === 0) {\n        this.disconnect();\n      }\n\n      return status;\n    });\n  }\n  /**\r\n   * Unsubscribes and removes all channels\r\n   */\n\n\n  removeAllChannels() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const values_1 = yield Promise.all(this.channels.map(channel => channel.unsubscribe()));\n      this.disconnect();\n      return values_1;\n    });\n  }\n  /**\r\n   * Logs the message.\r\n   *\r\n   * For customized logging, `this.logger` can be overridden.\r\n   */\n\n\n  log(kind, msg, data) {\n    this.logger(kind, msg, data);\n  }\n  /**\r\n   * Returns the current state of the socket.\r\n   */\n\n\n  connectionState() {\n    switch (this.conn && this.conn.readyState) {\n      case SOCKET_STATES.connecting:\n        return CONNECTION_STATE.Connecting;\n\n      case SOCKET_STATES.open:\n        return CONNECTION_STATE.Open;\n\n      case SOCKET_STATES.closing:\n        return CONNECTION_STATE.Closing;\n\n      default:\n        return CONNECTION_STATE.Closed;\n    }\n  }\n  /**\r\n   * Returns `true` is the connection is open.\r\n   */\n\n\n  isConnected() {\n    return this.connectionState() === CONNECTION_STATE.Open;\n  }\n\n  channel(topic) {\n    let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      config: {}\n    };\n\n    if (!this.isConnected()) {\n      this.connect();\n    }\n\n    const chan = new RealtimeChannel(`realtime:${topic}`, params, this);\n    this.channels.push(chan);\n    return chan;\n  }\n  /**\r\n   * Push out a message if the socket is connected.\r\n   *\r\n   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\r\n   */\n\n\n  push(data) {\n    const {\n      topic,\n      event,\n      payload,\n      ref\n    } = data;\n\n    let callback = () => {\n      this.encode(data, result => {\n        var _a;\n\n        (_a = this.conn) === null || _a === void 0 ? void 0 : _a.send(result);\n      });\n    };\n\n    this.log('push', `${topic} ${event} (${ref})`, payload);\n\n    if (this.isConnected()) {\n      if (['broadcast', 'presence', 'postgres_changes'].includes(event)) {\n        const isThrottled = this._throttle(callback)();\n\n        if (isThrottled) {\n          return 'rate limited';\n        }\n      } else {\n        callback();\n      }\n    } else {\n      this.sendBuffer.push(callback);\n    }\n  }\n  /**\r\n   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\r\n   *\r\n   * @param token A JWT string.\r\n   */\n\n\n  setAuth(token) {\n    this.accessToken = token;\n    this.channels.forEach(channel => {\n      token && channel.updateJoinPayload({\n        access_token: token\n      });\n\n      if (channel.joinedOnce && channel._isJoined()) {\n        channel._push(CHANNEL_EVENTS.access_token, {\n          access_token: token\n        });\n      }\n    });\n  }\n  /**\r\n   * Return the next message ref, accounting for overflows\r\n   *\r\n   * @internal\r\n   */\n\n\n  _makeRef() {\n    let newRef = this.ref + 1;\n\n    if (newRef === this.ref) {\n      this.ref = 0;\n    } else {\n      this.ref = newRef;\n    }\n\n    return this.ref.toString();\n  }\n  /**\r\n   * Unsubscribe from channels with the specified topic.\r\n   *\r\n   * @internal\r\n   */\n\n\n  _leaveOpenTopic(topic) {\n    let dupChannel = this.channels.find(c => c.topic === topic && (c._isJoined() || c._isJoining()));\n\n    if (dupChannel) {\n      this.log('transport', `leaving duplicate topic \"${topic}\"`);\n      dupChannel.unsubscribe();\n    }\n  }\n  /**\r\n   * Removes a subscription from the socket.\r\n   *\r\n   * @param channel An open subscription.\r\n   *\r\n   * @internal\r\n   */\n\n\n  _remove(channel) {\n    this.channels = this.channels.filter(c => c._joinRef() !== channel._joinRef());\n  }\n  /**\r\n   * Returns the URL of the websocket.\r\n   *\r\n   * @internal\r\n   */\n\n\n  _endPointURL() {\n    return this._appendParams(this.endPoint, Object.assign({}, this.params, {\n      vsn: VSN\n    }));\n  }\n  /** @internal */\n\n\n  _onConnMessage(rawMessage) {\n    this.decode(rawMessage.data, msg => {\n      let {\n        topic,\n        event,\n        payload,\n        ref\n      } = msg;\n\n      if (ref && ref === this.pendingHeartbeatRef || event === (payload === null || payload === void 0 ? void 0 : payload.type)) {\n        this.pendingHeartbeatRef = null;\n      }\n\n      this.log('receive', `${payload.status || ''} ${topic} ${event} ${ref && '(' + ref + ')' || ''}`, payload);\n      this.channels.filter(channel => channel._isMember(topic)).forEach(channel => channel._trigger(event, payload, ref));\n      this.stateChangeCallbacks.message.forEach(callback => callback(msg));\n    });\n  }\n  /** @internal */\n\n\n  _onConnOpen() {\n    this.log('transport', `connected to ${this._endPointURL()}`);\n\n    this._flushSendBuffer();\n\n    this.reconnectTimer.reset();\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n    this.heartbeatTimer = setInterval(() => this._sendHeartbeat(), this.heartbeatIntervalMs);\n    this.stateChangeCallbacks.open.forEach(callback => callback());\n  }\n  /** @internal */\n\n\n  _onConnClose(event) {\n    this.log('transport', 'close', event);\n\n    this._triggerChanError();\n\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n    this.reconnectTimer.scheduleTimeout();\n    this.stateChangeCallbacks.close.forEach(callback => callback(event));\n  }\n  /** @internal */\n\n\n  _onConnError(error) {\n    this.log('transport', error.message);\n\n    this._triggerChanError();\n\n    this.stateChangeCallbacks.error.forEach(callback => callback(error));\n  }\n  /** @internal */\n\n\n  _triggerChanError() {\n    this.channels.forEach(channel => channel._trigger(CHANNEL_EVENTS.error));\n  }\n  /** @internal */\n\n\n  _appendParams(url, params) {\n    if (Object.keys(params).length === 0) {\n      return url;\n    }\n\n    const prefix = url.match(/\\?/) ? '&' : '?';\n    const query = new URLSearchParams(params);\n    return `${url}${prefix}${query}`;\n  }\n  /** @internal */\n\n\n  _flushSendBuffer() {\n    if (this.isConnected() && this.sendBuffer.length > 0) {\n      this.sendBuffer.forEach(callback => callback());\n      this.sendBuffer = [];\n    }\n  }\n  /** @internal */\n\n\n  _sendHeartbeat() {\n    var _a;\n\n    if (!this.isConnected()) {\n      return;\n    }\n\n    if (this.pendingHeartbeatRef) {\n      this.pendingHeartbeatRef = null;\n      this.log('transport', 'heartbeat timeout. Attempting to re-establish connection');\n      (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(WS_CLOSE_NORMAL, 'hearbeat timeout');\n      return;\n    }\n\n    this.pendingHeartbeatRef = this._makeRef();\n    this.push({\n      topic: 'phoenix',\n      event: 'heartbeat',\n      payload: {},\n      ref: this.pendingHeartbeatRef\n    });\n    this.setAuth(this.accessToken);\n  }\n  /** @internal */\n\n\n  _throttle(callback) {\n    let eventsPerSecondLimitMs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.eventsPerSecondLimitMs;\n    return () => {\n      if (this.inThrottle) return true;\n      callback();\n\n      if (eventsPerSecondLimitMs > 0) {\n        this.inThrottle = true;\n        setTimeout(() => {\n          this.inThrottle = false;\n        }, eventsPerSecondLimitMs);\n      }\n\n      return false;\n    };\n  }\n\n}","map":{"version":3,"mappings":"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","names":["w3cwebsocket","VSN","CHANNEL_EVENTS","TRANSPORTS","SOCKET_STATES","DEFAULT_TIMEOUT","WS_CLOSE_NORMAL","DEFAULT_HEADERS","CONNECTION_STATE","Timer","Serializer","RealtimeChannel","noop","RealtimeClient","constructor","endPoint","options","undefined","open","close","error","message","websocket","params","headers","Object","timeout","logger","transport","heartbeatIntervalMs","eventsPerSecond","_a","eventsPerSecondLimitMs","Math","floor","reconnectAfterMs","tries","encode","payload","callback","JSON","stringify","decode","serializer","bind","reconnectTimer","__awaiter","disconnect","connect","conn","_endPointURL","binaryType","onopen","_onConnOpen","onerror","_onConnError","onmessage","event","_onConnMessage","onclose","_onConnClose","code","reason","heartbeatTimer","clearInterval","reset","getChannels","channels","removeChannel","channel","status","unsubscribe","length","removeAllChannels","values_1","Promise","all","map","log","kind","msg","data","connectionState","readyState","connecting","Connecting","Open","closing","Closing","Closed","isConnected","topic","config","chan","push","ref","result","send","includes","isThrottled","_throttle","sendBuffer","setAuth","token","accessToken","forEach","updateJoinPayload","access_token","joinedOnce","_isJoined","_push","_makeRef","newRef","toString","_leaveOpenTopic","dupChannel","find","c","_isJoining","_remove","filter","_joinRef","_appendParams","assign","vsn","rawMessage","pendingHeartbeatRef","type","_isMember","_trigger","stateChangeCallbacks","_flushSendBuffer","setInterval","_sendHeartbeat","_triggerChanError","scheduleTimeout","url","keys","prefix","match","query","URLSearchParams","inThrottle","setTimeout"],"sources":["C:\\Users\\mumta\\crewmates\\client\\node_modules\\@supabase\\realtime-js\\src\\RealtimeClient.ts"],"sourcesContent":["import { w3cwebsocket } from 'websocket'\r\nimport {\r\n  VSN,\r\n  CHANNEL_EVENTS,\r\n  TRANSPORTS,\r\n  SOCKET_STATES,\r\n  DEFAULT_TIMEOUT,\r\n  WS_CLOSE_NORMAL,\r\n  DEFAULT_HEADERS,\r\n  CONNECTION_STATE,\r\n} from './lib/constants'\r\nimport Timer from './lib/timer'\r\nimport Serializer from './lib/serializer'\r\nimport RealtimeChannel from './RealtimeChannel'\r\nimport type { RealtimeChannelOptions } from './RealtimeChannel'\r\n\r\nexport type RealtimeClientOptions = {\r\n  transport?: WebSocket\r\n  timeout?: number\r\n  heartbeatIntervalMs?: number\r\n  logger?: Function\r\n  encode?: Function\r\n  decode?: Function\r\n  reconnectAfterMs?: Function\r\n  headers?: { [key: string]: string }\r\n  params?: { [key: string]: any }\r\n}\r\n\r\nexport type RealtimeMessage = {\r\n  topic: string\r\n  event: string\r\n  payload: any\r\n  ref: string\r\n  join_ref?: string\r\n}\r\n\r\nexport type RealtimeRemoveChannelResponse = 'ok' | 'timed out' | 'error'\r\n\r\nconst noop = () => {}\r\n\r\nexport default class RealtimeClient {\r\n  accessToken: string | null = null\r\n  channels: RealtimeChannel[] = []\r\n  endPoint: string = ''\r\n  headers?: { [key: string]: string } = DEFAULT_HEADERS\r\n  params?: { [key: string]: string } = {}\r\n  timeout: number = DEFAULT_TIMEOUT\r\n  transport: any = w3cwebsocket\r\n  heartbeatIntervalMs: number = 30000\r\n  heartbeatTimer: ReturnType<typeof setInterval> | undefined = undefined\r\n  pendingHeartbeatRef: string | null = null\r\n  ref: number = 0\r\n  reconnectTimer: Timer\r\n  logger: Function = noop\r\n  encode: Function\r\n  decode: Function\r\n  reconnectAfterMs: Function\r\n  conn: WebSocket | null = null\r\n  sendBuffer: Function[] = []\r\n  serializer: Serializer = new Serializer()\r\n  stateChangeCallbacks: {\r\n    open: Function[]\r\n    close: Function[]\r\n    error: Function[]\r\n    message: Function[]\r\n  } = {\r\n    open: [],\r\n    close: [],\r\n    error: [],\r\n    message: [],\r\n  }\r\n  eventsPerSecondLimitMs: number = 100\r\n  inThrottle: boolean = false\r\n\r\n  /**\r\n   * Initializes the Socket.\r\n   *\r\n   * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\r\n   * @param options.transport The Websocket Transport, for example WebSocket.\r\n   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\r\n   * @param options.params The optional params to pass when connecting.\r\n   * @param options.headers The optional headers to pass when connecting.\r\n   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\r\n   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\r\n   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\r\n   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\r\n   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\r\n   */\r\n  constructor(endPoint: string, options?: RealtimeClientOptions) {\r\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`\r\n\r\n    if (options?.params) this.params = options.params\r\n    if (options?.headers) this.headers = { ...this.headers, ...options.headers }\r\n    if (options?.timeout) this.timeout = options.timeout\r\n    if (options?.logger) this.logger = options.logger\r\n    if (options?.transport) this.transport = options.transport\r\n    if (options?.heartbeatIntervalMs)\r\n      this.heartbeatIntervalMs = options.heartbeatIntervalMs\r\n\r\n    const eventsPerSecond = options?.params?.eventsPerSecond\r\n    if (eventsPerSecond)\r\n      this.eventsPerSecondLimitMs = Math.floor(1000 / eventsPerSecond)\r\n\r\n    this.reconnectAfterMs = options?.reconnectAfterMs\r\n      ? options.reconnectAfterMs\r\n      : (tries: number) => {\r\n          return [1000, 2000, 5000, 10000][tries - 1] || 10000\r\n        }\r\n    this.encode = options?.encode\r\n      ? options.encode\r\n      : (payload: JSON, callback: Function) => {\r\n          return callback(JSON.stringify(payload))\r\n        }\r\n    this.decode = options?.decode\r\n      ? options.decode\r\n      : this.serializer.decode.bind(this.serializer)\r\n    this.reconnectTimer = new Timer(async () => {\r\n      this.disconnect()\r\n      this.connect()\r\n    }, this.reconnectAfterMs)\r\n  }\r\n\r\n  /**\r\n   * Connects the socket, unless already connected.\r\n   */\r\n  connect(): void {\r\n    if (this.conn) {\r\n      return\r\n    }\r\n\r\n    this.conn = new this.transport(this._endPointURL(), [], null, this.headers)\r\n\r\n    if (this.conn) {\r\n      this.conn.binaryType = 'arraybuffer'\r\n      this.conn.onopen = () => this._onConnOpen()\r\n      this.conn.onerror = (error) => this._onConnError(error as ErrorEvent)\r\n      this.conn.onmessage = (event) => this._onConnMessage(event)\r\n      this.conn.onclose = (event) => this._onConnClose(event)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Disconnects the socket.\r\n   *\r\n   * @param code A numeric status code to send on disconnect.\r\n   * @param reason A custom reason for the disconnect.\r\n   */\r\n  disconnect(code?: number, reason?: string): void {\r\n    if (this.conn) {\r\n      this.conn.onclose = function () {} // noop\r\n      if (code) {\r\n        this.conn.close(code, reason ?? '')\r\n      } else {\r\n        this.conn.close()\r\n      }\r\n      this.conn = null\r\n      // remove open handles\r\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer)\r\n      this.reconnectTimer.reset()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns all created channels\r\n   */\r\n  getChannels(): RealtimeChannel[] {\r\n    return this.channels\r\n  }\r\n\r\n  /**\r\n   * Unsubscribes and removes a single channel\r\n   * @param channel A RealtimeChannel instance\r\n   */\r\n  async removeChannel(\r\n    channel: RealtimeChannel\r\n  ): Promise<RealtimeRemoveChannelResponse> {\r\n    const status = await channel.unsubscribe()\r\n    if (this.channels.length === 0) {\r\n      this.disconnect()\r\n    }\r\n    return status\r\n  }\r\n\r\n  /**\r\n   * Unsubscribes and removes all channels\r\n   */\r\n  async removeAllChannels(): Promise<RealtimeRemoveChannelResponse[]> {\r\n    const values_1 = await Promise.all(\r\n      this.channels.map((channel) => channel.unsubscribe())\r\n    )\r\n    this.disconnect()\r\n    return values_1\r\n  }\r\n\r\n  /**\r\n   * Logs the message.\r\n   *\r\n   * For customized logging, `this.logger` can be overridden.\r\n   */\r\n  log(kind: string, msg: string, data?: any) {\r\n    this.logger(kind, msg, data)\r\n  }\r\n\r\n  /**\r\n   * Returns the current state of the socket.\r\n   */\r\n  connectionState(): CONNECTION_STATE {\r\n    switch (this.conn && this.conn.readyState) {\r\n      case SOCKET_STATES.connecting:\r\n        return CONNECTION_STATE.Connecting\r\n      case SOCKET_STATES.open:\r\n        return CONNECTION_STATE.Open\r\n      case SOCKET_STATES.closing:\r\n        return CONNECTION_STATE.Closing\r\n      default:\r\n        return CONNECTION_STATE.Closed\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns `true` is the connection is open.\r\n   */\r\n  isConnected(): boolean {\r\n    return this.connectionState() === CONNECTION_STATE.Open\r\n  }\r\n\r\n  channel(\r\n    topic: string,\r\n    params: RealtimeChannelOptions = { config: {} }\r\n  ): RealtimeChannel {\r\n    if (!this.isConnected()) {\r\n      this.connect()\r\n    }\r\n\r\n    const chan = new RealtimeChannel(`realtime:${topic}`, params, this)\r\n    this.channels.push(chan)\r\n    return chan\r\n  }\r\n\r\n  /**\r\n   * Push out a message if the socket is connected.\r\n   *\r\n   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\r\n   */\r\n  push(data: RealtimeMessage): 'rate limited' | void {\r\n    const { topic, event, payload, ref } = data\r\n    let callback = () => {\r\n      this.encode(data, (result: any) => {\r\n        this.conn?.send(result)\r\n      })\r\n    }\r\n    this.log('push', `${topic} ${event} (${ref})`, payload)\r\n    if (this.isConnected()) {\r\n      if (['broadcast', 'presence', 'postgres_changes'].includes(event)) {\r\n        const isThrottled = this._throttle(callback)()\r\n        if (isThrottled) {\r\n          return 'rate limited'\r\n        }\r\n      } else {\r\n        callback()\r\n      }\r\n    } else {\r\n      this.sendBuffer.push(callback)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\r\n   *\r\n   * @param token A JWT string.\r\n   */\r\n  setAuth(token: string | null): void {\r\n    this.accessToken = token\r\n\r\n    this.channels.forEach((channel) => {\r\n      token && channel.updateJoinPayload({ access_token: token })\r\n\r\n      if (channel.joinedOnce && channel._isJoined()) {\r\n        channel._push(CHANNEL_EVENTS.access_token, { access_token: token })\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Return the next message ref, accounting for overflows\r\n   *\r\n   * @internal\r\n   */\r\n  _makeRef(): string {\r\n    let newRef = this.ref + 1\r\n    if (newRef === this.ref) {\r\n      this.ref = 0\r\n    } else {\r\n      this.ref = newRef\r\n    }\r\n\r\n    return this.ref.toString()\r\n  }\r\n\r\n  /**\r\n   * Unsubscribe from channels with the specified topic.\r\n   *\r\n   * @internal\r\n   */\r\n  _leaveOpenTopic(topic: string): void {\r\n    let dupChannel = this.channels.find(\r\n      (c) => c.topic === topic && (c._isJoined() || c._isJoining())\r\n    )\r\n    if (dupChannel) {\r\n      this.log('transport', `leaving duplicate topic \"${topic}\"`)\r\n      dupChannel.unsubscribe()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes a subscription from the socket.\r\n   *\r\n   * @param channel An open subscription.\r\n   *\r\n   * @internal\r\n   */\r\n  _remove(channel: RealtimeChannel) {\r\n    this.channels = this.channels.filter(\r\n      (c: RealtimeChannel) => c._joinRef() !== channel._joinRef()\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Returns the URL of the websocket.\r\n   *\r\n   * @internal\r\n   */\r\n  private _endPointURL(): string {\r\n    return this._appendParams(\r\n      this.endPoint,\r\n      Object.assign({}, this.params, { vsn: VSN })\r\n    )\r\n  }\r\n\r\n  /** @internal */\r\n  private _onConnMessage(rawMessage: { data: any }) {\r\n    this.decode(rawMessage.data, (msg: RealtimeMessage) => {\r\n      let { topic, event, payload, ref } = msg\r\n\r\n      if (\r\n        (ref && ref === this.pendingHeartbeatRef) ||\r\n        event === payload?.type\r\n      ) {\r\n        this.pendingHeartbeatRef = null\r\n      }\r\n\r\n      this.log(\r\n        'receive',\r\n        `${payload.status || ''} ${topic} ${event} ${\r\n          (ref && '(' + ref + ')') || ''\r\n        }`,\r\n        payload\r\n      )\r\n      this.channels\r\n        .filter((channel: RealtimeChannel) => channel._isMember(topic))\r\n        .forEach((channel: RealtimeChannel) =>\r\n          channel._trigger(event, payload, ref)\r\n        )\r\n      this.stateChangeCallbacks.message.forEach((callback) => callback(msg))\r\n    })\r\n  }\r\n\r\n  /** @internal */\r\n  private _onConnOpen() {\r\n    this.log('transport', `connected to ${this._endPointURL()}`)\r\n    this._flushSendBuffer()\r\n    this.reconnectTimer.reset()\r\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer)\r\n    this.heartbeatTimer = setInterval(\r\n      () => this._sendHeartbeat(),\r\n      this.heartbeatIntervalMs\r\n    )\r\n    this.stateChangeCallbacks.open.forEach((callback) => callback())!\r\n  }\r\n\r\n  /** @internal */\r\n  private _onConnClose(event: any) {\r\n    this.log('transport', 'close', event)\r\n    this._triggerChanError()\r\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer)\r\n    this.reconnectTimer.scheduleTimeout()\r\n    this.stateChangeCallbacks.close.forEach((callback) => callback(event))\r\n  }\r\n\r\n  /** @internal */\r\n  private _onConnError(error: ErrorEvent) {\r\n    this.log('transport', error.message)\r\n    this._triggerChanError()\r\n    this.stateChangeCallbacks.error.forEach((callback) => callback(error))\r\n  }\r\n\r\n  /** @internal */\r\n  private _triggerChanError() {\r\n    this.channels.forEach((channel: RealtimeChannel) =>\r\n      channel._trigger(CHANNEL_EVENTS.error)\r\n    )\r\n  }\r\n\r\n  /** @internal */\r\n  private _appendParams(\r\n    url: string,\r\n    params: { [key: string]: string }\r\n  ): string {\r\n    if (Object.keys(params).length === 0) {\r\n      return url\r\n    }\r\n    const prefix = url.match(/\\?/) ? '&' : '?'\r\n    const query = new URLSearchParams(params)\r\n\r\n    return `${url}${prefix}${query}`\r\n  }\r\n\r\n  /** @internal */\r\n  private _flushSendBuffer() {\r\n    if (this.isConnected() && this.sendBuffer.length > 0) {\r\n      this.sendBuffer.forEach((callback) => callback())\r\n      this.sendBuffer = []\r\n    }\r\n  }\r\n  /** @internal */\r\n  private _sendHeartbeat() {\r\n    if (!this.isConnected()) {\r\n      return\r\n    }\r\n    if (this.pendingHeartbeatRef) {\r\n      this.pendingHeartbeatRef = null\r\n      this.log(\r\n        'transport',\r\n        'heartbeat timeout. Attempting to re-establish connection'\r\n      )\r\n      this.conn?.close(WS_CLOSE_NORMAL, 'hearbeat timeout')\r\n      return\r\n    }\r\n    this.pendingHeartbeatRef = this._makeRef()\r\n    this.push({\r\n      topic: 'phoenix',\r\n      event: 'heartbeat',\r\n      payload: {},\r\n      ref: this.pendingHeartbeatRef,\r\n    })\r\n    this.setAuth(this.accessToken)\r\n  }\r\n\r\n  /** @internal */\r\n  private _throttle(\r\n    callback: Function,\r\n    eventsPerSecondLimitMs: number = this.eventsPerSecondLimitMs\r\n  ): () => boolean {\r\n    return () => {\r\n      if (this.inThrottle) return true\r\n\r\n      callback()\r\n\r\n      if (eventsPerSecondLimitMs > 0) {\r\n        this.inThrottle = true\r\n\r\n        setTimeout(() => {\r\n          this.inThrottle = false\r\n        }, eventsPerSecondLimitMs)\r\n      }\r\n\r\n      return false\r\n    }\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}