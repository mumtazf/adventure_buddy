{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/mumta/crewmates/client/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"C:/Users/mumta/crewmates/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/mumta/crewmates/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { CHANNEL_EVENTS, CHANNEL_STATES } from './lib/constants';\nimport Push from './lib/push';\nimport Timer from './lib/timer';\nimport RealtimePresence from './RealtimePresence';\nimport * as Transformers from './lib/transformers';\nexport var REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;\n\n(function (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT) {\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"ALL\"] = \"*\";\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"INSERT\"] = \"INSERT\";\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"UPDATE\"] = \"UPDATE\";\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"DELETE\"] = \"DELETE\";\n})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));\n\nexport var REALTIME_LISTEN_TYPES;\n\n(function (REALTIME_LISTEN_TYPES) {\n  REALTIME_LISTEN_TYPES[\"BROADCAST\"] = \"broadcast\";\n  REALTIME_LISTEN_TYPES[\"PRESENCE\"] = \"presence\";\n  /**\r\n   * listen to Postgres changes.\r\n   */\n\n  REALTIME_LISTEN_TYPES[\"POSTGRES_CHANGES\"] = \"postgres_changes\";\n})(REALTIME_LISTEN_TYPES || (REALTIME_LISTEN_TYPES = {}));\n\nexport var REALTIME_SUBSCRIBE_STATES;\n\n(function (REALTIME_SUBSCRIBE_STATES) {\n  REALTIME_SUBSCRIBE_STATES[\"SUBSCRIBED\"] = \"SUBSCRIBED\";\n  REALTIME_SUBSCRIBE_STATES[\"TIMED_OUT\"] = \"TIMED_OUT\";\n  REALTIME_SUBSCRIBE_STATES[\"CLOSED\"] = \"CLOSED\";\n  REALTIME_SUBSCRIBE_STATES[\"CHANNEL_ERROR\"] = \"CHANNEL_ERROR\";\n})(REALTIME_SUBSCRIBE_STATES || (REALTIME_SUBSCRIBE_STATES = {}));\n/** A channel is the basic building block of Realtime\r\n * and narrows the scope of data flow to subscribed clients.\r\n * You can think of a channel as a chatroom where participants are able to see who's online\r\n * and send and receive messages.\r\n **/\n\n\nvar RealtimeChannel = /*#__PURE__*/function () {\n  function RealtimeChannel(\n  /** Topic name can be any string. */\n  topic) {\n    var _this = this;\n\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      config: {}\n    };\n    var socket = arguments.length > 2 ? arguments[2] : undefined;\n\n    _classCallCheck(this, RealtimeChannel);\n\n    this.topic = topic;\n    this.params = params;\n    this.socket = socket;\n    this.bindings = {};\n    this.state = CHANNEL_STATES.closed;\n    this.joinedOnce = false;\n    this.pushBuffer = [];\n    this.params.config = Object.assign({\n      broadcast: {\n        ack: false,\n        self: false\n      },\n      presence: {\n        key: ''\n      }\n    }, params.config);\n    this.timeout = this.socket.timeout;\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n    this.rejoinTimer = new Timer(function () {\n      return _this._rejoinUntilConnected();\n    }, this.socket.reconnectAfterMs);\n    this.joinPush.receive('ok', function () {\n      _this.state = CHANNEL_STATES.joined;\n\n      _this.rejoinTimer.reset();\n\n      _this.pushBuffer.forEach(function (pushEvent) {\n        return pushEvent.send();\n      });\n\n      _this.pushBuffer = [];\n    });\n\n    this._onClose(function () {\n      _this.rejoinTimer.reset();\n\n      _this.socket.log('channel', \"close \".concat(_this.topic, \" \").concat(_this._joinRef()));\n\n      _this.state = CHANNEL_STATES.closed;\n\n      _this.socket._remove(_this);\n    });\n\n    this._onError(function (reason) {\n      if (_this._isLeaving() || _this._isClosed()) {\n        return;\n      }\n\n      _this.socket.log('channel', \"error \".concat(_this.topic), reason);\n\n      _this.state = CHANNEL_STATES.errored;\n\n      _this.rejoinTimer.scheduleTimeout();\n    });\n\n    this.joinPush.receive('timeout', function () {\n      if (!_this._isJoining()) {\n        return;\n      }\n\n      _this.socket.log('channel', \"timeout \".concat(_this.topic), _this.joinPush.timeout);\n\n      _this.state = CHANNEL_STATES.errored;\n\n      _this.rejoinTimer.scheduleTimeout();\n    });\n\n    this._on(CHANNEL_EVENTS.reply, {}, function (payload, ref) {\n      _this._trigger(_this._replyEventName(ref), payload);\n    });\n\n    this.presence = new RealtimePresence(this);\n  }\n  /** Subscribe registers your client with the server */\n\n\n  _createClass(RealtimeChannel, [{\n    key: \"subscribe\",\n    value: function subscribe(callback) {\n      var _this2 = this;\n\n      var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.timeout;\n\n      var _a, _b;\n\n      if (this.joinedOnce) {\n        throw \"tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance\";\n      } else {\n        var _this$params$config = this.params.config,\n            broadcast = _this$params$config.broadcast,\n            presence = _this$params$config.presence;\n\n        this._onError(function (e) {\n          return callback && callback('CHANNEL_ERROR', e);\n        });\n\n        this._onClose(function () {\n          return callback && callback('CLOSED');\n        });\n\n        var accessTokenPayload = {};\n        var config = {\n          broadcast: broadcast,\n          presence: presence,\n          postgres_changes: (_b = (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.map(function (r) {\n            return r.filter;\n          })) !== null && _b !== void 0 ? _b : []\n        };\n\n        if (this.socket.accessToken) {\n          accessTokenPayload.access_token = this.socket.accessToken;\n        }\n\n        this.updateJoinPayload(Object.assign({\n          config: config\n        }, accessTokenPayload));\n        this.joinedOnce = true;\n\n        this._rejoin(timeout);\n\n        this.joinPush.receive('ok', function (_ref2) {\n          var serverPostgresFilters = _ref2.postgres_changes;\n\n          var _a;\n\n          _this2.socket.accessToken && _this2.socket.setAuth(_this2.socket.accessToken);\n\n          if (serverPostgresFilters === undefined) {\n            callback && callback('SUBSCRIBED');\n            return;\n          } else {\n            var clientPostgresBindings = _this2.bindings.postgres_changes;\n            var bindingsLen = (_a = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a !== void 0 ? _a : 0;\n            var newPostgresBindings = [];\n\n            for (var i = 0; i < bindingsLen; i++) {\n              var clientPostgresBinding = clientPostgresBindings[i];\n              var _clientPostgresBindin = clientPostgresBinding.filter,\n                  event = _clientPostgresBindin.event,\n                  schema = _clientPostgresBindin.schema,\n                  table = _clientPostgresBindin.table,\n                  filter = _clientPostgresBindin.filter;\n              var serverPostgresFilter = serverPostgresFilters && serverPostgresFilters[i];\n\n              if (serverPostgresFilter && serverPostgresFilter.event === event && serverPostgresFilter.schema === schema && serverPostgresFilter.table === table && serverPostgresFilter.filter === filter) {\n                newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), {\n                  id: serverPostgresFilter.id\n                }));\n              } else {\n                _this2.unsubscribe();\n\n                callback && callback('CHANNEL_ERROR', new Error('mismatch between server and client bindings for postgres changes'));\n                return;\n              }\n            }\n\n            _this2.bindings.postgres_changes = newPostgresBindings;\n            callback && callback('SUBSCRIBED');\n            return;\n          }\n        }).receive('error', function (error) {\n          callback && callback('CHANNEL_ERROR', new Error(JSON.stringify(Object.values(error).join(', ') || 'error')));\n          return;\n        }).receive('timeout', function () {\n          callback && callback('TIMED_OUT');\n          return;\n        });\n      }\n\n      return this;\n    }\n  }, {\n    key: \"presenceState\",\n    value: function presenceState() {\n      return this.presence.state;\n    }\n  }, {\n    key: \"track\",\n    value: function track(payload) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.send({\n                  type: 'presence',\n                  event: 'track',\n                  payload: payload\n                }, opts.timeout || this.timeout);\n\n              case 2:\n                return _context.abrupt(\"return\", _context.sent);\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n  }, {\n    key: \"untrack\",\n    value: function untrack() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.send({\n                  type: 'presence',\n                  event: 'untrack'\n                }, opts);\n\n              case 2:\n                return _context2.abrupt(\"return\", _context2.sent);\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n  }, {\n    key: \"on\",\n    value: function on(type, filter, callback) {\n      return this._on(type, filter, callback);\n    }\n  }, {\n    key: \"send\",\n    value: function send(payload) {\n      var _this3 = this;\n\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return new Promise(function (resolve) {\n        var _a, _b, _c;\n\n        var push = _this3._push(payload.type, payload, opts.timeout || _this3.timeout);\n\n        if (push.rateLimited) {\n          resolve('rate limited');\n        }\n\n        if (payload.type === 'broadcast' && !((_c = (_b = (_a = _this3.params) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {\n          resolve('ok');\n        }\n\n        push.receive('ok', function () {\n          return resolve('ok');\n        });\n        push.receive('timeout', function () {\n          return resolve('timed out');\n        });\n      });\n    }\n  }, {\n    key: \"updateJoinPayload\",\n    value: function updateJoinPayload(payload) {\n      this.joinPush.updatePayload(payload);\n    }\n    /**\r\n     * Leaves the channel.\r\n     *\r\n     * Unsubscribes from server events, and instructs channel to terminate on server.\r\n     * Triggers onClose() hooks.\r\n     *\r\n     * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\r\n     * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\r\n     */\n\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe() {\n      var _this4 = this;\n\n      var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n      this.state = CHANNEL_STATES.leaving;\n\n      var onClose = function onClose() {\n        _this4.socket.log('channel', \"leave \".concat(_this4.topic));\n\n        _this4._trigger(CHANNEL_EVENTS.close, 'leave', _this4._joinRef());\n      };\n\n      this.rejoinTimer.reset(); // Destroy joinPush to avoid connection timeouts during unscription phase\n\n      this.joinPush.destroy();\n      return new Promise(function (resolve) {\n        var leavePush = new Push(_this4, CHANNEL_EVENTS.leave, {}, timeout);\n        leavePush.receive('ok', function () {\n          onClose();\n          resolve('ok');\n        }).receive('timeout', function () {\n          onClose();\n          resolve('timed out');\n        }).receive('error', function () {\n          resolve('error');\n        });\n        leavePush.send();\n\n        if (!_this4._canPush()) {\n          leavePush.trigger('ok', {});\n        }\n      });\n    }\n    /** @internal */\n\n  }, {\n    key: \"_push\",\n    value: function _push(event, payload) {\n      var timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.timeout;\n\n      if (!this.joinedOnce) {\n        throw \"tried to push '\".concat(event, \"' to '\").concat(this.topic, \"' before joining. Use channel.subscribe() before pushing events\");\n      }\n\n      var pushEvent = new Push(this, event, payload, timeout);\n\n      if (this._canPush()) {\n        pushEvent.send();\n      } else {\n        pushEvent.startTimeout();\n        this.pushBuffer.push(pushEvent);\n      }\n\n      return pushEvent;\n    }\n    /**\r\n     * Overridable message hook\r\n     *\r\n     * Receives all events for specialized message handling before dispatching to the channel callbacks.\r\n     * Must return the payload, modified or unmodified.\r\n     *\r\n     * @internal\r\n     */\n\n  }, {\n    key: \"_onMessage\",\n    value: function _onMessage(_event, payload, _ref) {\n      return payload;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_isMember\",\n    value: function _isMember(topic) {\n      return this.topic === topic;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_joinRef\",\n    value: function _joinRef() {\n      return this.joinPush.ref;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_trigger\",\n    value: function _trigger(type, payload, ref) {\n      var _this5 = this;\n\n      var _a, _b;\n\n      var typeLower = type.toLocaleLowerCase();\n      var close = CHANNEL_EVENTS.close,\n          error = CHANNEL_EVENTS.error,\n          leave = CHANNEL_EVENTS.leave,\n          join = CHANNEL_EVENTS.join;\n      var events = [close, error, leave, join];\n\n      if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\n        return;\n      }\n\n      var handledPayload = this._onMessage(typeLower, payload, ref);\n\n      if (payload && !handledPayload) {\n        throw 'channel onMessage callbacks must return the payload, modified or unmodified';\n      }\n\n      if (['insert', 'update', 'delete'].includes(typeLower)) {\n        (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.filter(function (bind) {\n          var _a, _b, _c;\n\n          return ((_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event) === '*' || ((_c = (_b = bind.filter) === null || _b === void 0 ? void 0 : _b.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower;\n        }).map(function (bind) {\n          return bind.callback(handledPayload, ref);\n        });\n      } else {\n        (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter(function (bind) {\n          var _a, _b, _c, _d, _e, _f;\n\n          if (['broadcast', 'presence', 'postgres_changes'].includes(typeLower)) {\n            if ('id' in bind) {\n              var bindId = bind.id;\n              var bindEvent = (_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event;\n              return bindId && ((_b = payload.ids) === null || _b === void 0 ? void 0 : _b.includes(bindId)) && (bindEvent === '*' || (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) === ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase()));\n            } else {\n              var _bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();\n\n              return _bindEvent === '*' || _bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase());\n            }\n          } else {\n            return bind.type.toLocaleLowerCase() === typeLower;\n          }\n        }).map(function (bind) {\n          if (typeof handledPayload === 'object' && 'ids' in handledPayload) {\n            var postgresChanges = handledPayload.data;\n            var schema = postgresChanges.schema,\n                table = postgresChanges.table,\n                commit_timestamp = postgresChanges.commit_timestamp,\n                _type = postgresChanges.type,\n                errors = postgresChanges.errors;\n            var enrichedPayload = {\n              schema: schema,\n              table: table,\n              commit_timestamp: commit_timestamp,\n              eventType: _type,\n              new: {},\n              old: {},\n              errors: errors\n            };\n            handledPayload = Object.assign(Object.assign({}, enrichedPayload), _this5._getPayloadRecords(postgresChanges));\n          }\n\n          bind.callback(handledPayload, ref);\n        });\n      }\n    }\n    /** @internal */\n\n  }, {\n    key: \"_isClosed\",\n    value: function _isClosed() {\n      return this.state === CHANNEL_STATES.closed;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_isJoined\",\n    value: function _isJoined() {\n      return this.state === CHANNEL_STATES.joined;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_isJoining\",\n    value: function _isJoining() {\n      return this.state === CHANNEL_STATES.joining;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_isLeaving\",\n    value: function _isLeaving() {\n      return this.state === CHANNEL_STATES.leaving;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_replyEventName\",\n    value: function _replyEventName(ref) {\n      return \"chan_reply_\".concat(ref);\n    }\n    /** @internal */\n\n  }, {\n    key: \"_on\",\n    value: function _on(type, filter, callback) {\n      var typeLower = type.toLocaleLowerCase();\n      var binding = {\n        type: typeLower,\n        filter: filter,\n        callback: callback\n      };\n\n      if (this.bindings[typeLower]) {\n        this.bindings[typeLower].push(binding);\n      } else {\n        this.bindings[typeLower] = [binding];\n      }\n\n      return this;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_off\",\n    value: function _off(type, filter) {\n      var typeLower = type.toLocaleLowerCase();\n      this.bindings[typeLower] = this.bindings[typeLower].filter(function (bind) {\n        var _a;\n\n        return !(((_a = bind.type) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === typeLower && RealtimeChannel.isEqual(bind.filter, filter));\n      });\n      return this;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_rejoinUntilConnected\",\n    value:\n    /** @internal */\n    function _rejoinUntilConnected() {\n      this.rejoinTimer.scheduleTimeout();\n\n      if (this.socket.isConnected()) {\n        this._rejoin();\n      }\n    }\n    /**\r\n     * Registers a callback that will be executed when the channel closes.\r\n     *\r\n     * @internal\r\n     */\n\n  }, {\n    key: \"_onClose\",\n    value: function _onClose(callback) {\n      this._on(CHANNEL_EVENTS.close, {}, callback);\n    }\n    /**\r\n     * Registers a callback that will be executed when the channel encounteres an error.\r\n     *\r\n     * @internal\r\n     */\n\n  }, {\n    key: \"_onError\",\n    value: function _onError(callback) {\n      this._on(CHANNEL_EVENTS.error, {}, function (reason) {\n        return callback(reason);\n      });\n    }\n    /**\r\n     * Returns `true` if the socket is connected and the channel has been joined.\r\n     *\r\n     * @internal\r\n     */\n\n  }, {\n    key: \"_canPush\",\n    value: function _canPush() {\n      return this.socket.isConnected() && this._isJoined();\n    }\n    /** @internal */\n\n  }, {\n    key: \"_rejoin\",\n    value: function _rejoin() {\n      var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n\n      if (this._isLeaving()) {\n        return;\n      }\n\n      this.socket._leaveOpenTopic(this.topic);\n\n      this.state = CHANNEL_STATES.joining;\n      this.joinPush.resend(timeout);\n    }\n    /** @internal */\n\n  }, {\n    key: \"_getPayloadRecords\",\n    value: function _getPayloadRecords(payload) {\n      var records = {\n        new: {},\n        old: {}\n      };\n\n      if (payload.type === 'INSERT' || payload.type === 'UPDATE') {\n        records.new = Transformers.convertChangeData(payload.columns, payload.record);\n      }\n\n      if (payload.type === 'UPDATE' || payload.type === 'DELETE') {\n        records.old = Transformers.convertChangeData(payload.columns, payload.old_record);\n      }\n\n      return records;\n    }\n  }], [{\n    key: \"isEqual\",\n    value: function isEqual(obj1, obj2) {\n      if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n        return false;\n      }\n\n      for (var k in obj1) {\n        if (obj1[k] !== obj2[k]) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }]);\n\n  return RealtimeChannel;\n}();\n\nexport { RealtimeChannel as default };","map":{"version":3,"mappings":"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","names":["CHANNEL_EVENTS","CHANNEL_STATES","Push","Timer","RealtimePresence","Transformers","REALTIME_POSTGRES_CHANGES_LISTEN_EVENT","REALTIME_LISTEN_TYPES","REALTIME_SUBSCRIBE_STATES","RealtimeChannel","topic","params","config","socket","closed","Object","broadcast","ack","self","presence","key","timeout","joinPush","join","rejoinTimer","_rejoinUntilConnected","reconnectAfterMs","receive","state","joined","reset","pushBuffer","forEach","pushEvent","send","_onClose","log","_joinRef","_remove","_onError","reason","_isLeaving","_isClosed","errored","scheduleTimeout","_isJoining","_on","reply","payload","ref","_trigger","_replyEventName","callback","joinedOnce","e","accessTokenPayload","postgres_changes","bindings","_a","map","r","filter","_b","accessToken","access_token","updateJoinPayload","_rejoin","serverPostgresFilters","setAuth","undefined","clientPostgresBindings","bindingsLen","length","newPostgresBindings","i","clientPostgresBinding","event","schema","table","serverPostgresFilter","push","id","unsubscribe","Error","error","JSON","stringify","values","opts","type","Promise","resolve","_push","rateLimited","_c","updatePayload","leaving","onClose","close","destroy","leavePush","leave","_canPush","trigger","startTimeout","_event","_ref","typeLower","toLocaleLowerCase","events","indexOf","handledPayload","_onMessage","includes","bind","bindId","bindEvent","ids","data","_d","_e","_f","postgresChanges","commit_timestamp","errors","enrichedPayload","eventType","new","old","_getPayloadRecords","joining","binding","isEqual","isConnected","_isJoined","_leaveOpenTopic","resend","records","convertChangeData","columns","record","old_record","obj1","obj2","keys","k"],"sources":["C:\\Users\\mumta\\crewmates\\client\\node_modules\\@supabase\\realtime-js\\src\\RealtimeChannel.ts"],"sourcesContent":["import { CHANNEL_EVENTS, CHANNEL_STATES } from './lib/constants'\r\nimport Push from './lib/push'\r\nimport type RealtimeClient from './RealtimeClient'\r\nimport Timer from './lib/timer'\r\nimport RealtimePresence, {\r\n  REALTIME_PRESENCE_LISTEN_EVENTS,\r\n} from './RealtimePresence'\r\nimport type {\r\n  RealtimePresenceJoinPayload,\r\n  RealtimePresenceLeavePayload,\r\n  RealtimePresenceState,\r\n} from './RealtimePresence'\r\nimport * as Transformers from './lib/transformers'\r\n\r\nexport type RealtimeChannelOptions = {\r\n  config: {\r\n    /**\r\n     * self option enables client to receive message it broadcast\r\n     * ack option instructs server to acknowledge that broadcast message was received\r\n     */\r\n    broadcast?: { self?: boolean; ack?: boolean }\r\n    /**\r\n     * key option is used to track presence payload across clients\r\n     */\r\n    presence?: { key?: string }\r\n  }\r\n}\r\n\r\ntype RealtimePostgresChangesPayloadBase = {\r\n  schema: string\r\n  table: string\r\n  commit_timestamp: string\r\n  errors: string[]\r\n}\r\n\r\nexport type RealtimePostgresInsertPayload<T extends { [key: string]: any }> =\r\n  RealtimePostgresChangesPayloadBase & {\r\n    eventType: `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.INSERT}`\r\n    new: T\r\n    old: {}\r\n  }\r\n\r\nexport type RealtimePostgresUpdatePayload<T extends { [key: string]: any }> =\r\n  RealtimePostgresChangesPayloadBase & {\r\n    eventType: `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.UPDATE}`\r\n    new: T\r\n    old: Partial<T>\r\n  }\r\n\r\nexport type RealtimePostgresDeletePayload<T extends { [key: string]: any }> =\r\n  RealtimePostgresChangesPayloadBase & {\r\n    eventType: `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.DELETE}`\r\n    new: {}\r\n    old: Partial<T>\r\n  }\r\n\r\nexport type RealtimePostgresChangesPayload<T extends { [key: string]: any }> =\r\n  | RealtimePostgresInsertPayload<T>\r\n  | RealtimePostgresUpdatePayload<T>\r\n  | RealtimePostgresDeletePayload<T>\r\n\r\nexport type RealtimePostgresChangesFilter<\r\n  T extends `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT}`\r\n> = {\r\n  /**\r\n   * The type of database change to listen to.\r\n   */\r\n  event: T\r\n  /**\r\n   * The database schema to listen to.\r\n   */\r\n  schema: string\r\n  /**\r\n   * The database table to listen to.\r\n   */\r\n  table?: string\r\n  /**\r\n   * Receive database changes when filter is matched.\r\n   */\r\n  filter?: string\r\n}\r\n\r\nexport type RealtimeChannelSendResponse = 'ok' | 'timed out' | 'rate limited'\r\n\r\nexport enum REALTIME_POSTGRES_CHANGES_LISTEN_EVENT {\r\n  ALL = '*',\r\n  INSERT = 'INSERT',\r\n  UPDATE = 'UPDATE',\r\n  DELETE = 'DELETE',\r\n}\r\n\r\nexport enum REALTIME_LISTEN_TYPES {\r\n  BROADCAST = 'broadcast',\r\n  PRESENCE = 'presence',\r\n  /**\r\n   * listen to Postgres changes.\r\n   */\r\n  POSTGRES_CHANGES = 'postgres_changes',\r\n}\r\n\r\nexport enum REALTIME_SUBSCRIBE_STATES {\r\n  SUBSCRIBED = 'SUBSCRIBED',\r\n  TIMED_OUT = 'TIMED_OUT',\r\n  CLOSED = 'CLOSED',\r\n  CHANNEL_ERROR = 'CHANNEL_ERROR',\r\n}\r\n\r\n/** A channel is the basic building block of Realtime\r\n * and narrows the scope of data flow to subscribed clients.\r\n * You can think of a channel as a chatroom where participants are able to see who's online\r\n * and send and receive messages.\r\n **/\r\nexport default class RealtimeChannel {\r\n  bindings: {\r\n    [key: string]: {\r\n      type: string\r\n      filter: { [key: string]: any }\r\n      callback: Function\r\n      id?: string\r\n    }[]\r\n  } = {}\r\n  timeout: number\r\n  state = CHANNEL_STATES.closed\r\n  joinedOnce = false\r\n  joinPush: Push\r\n  rejoinTimer: Timer\r\n  pushBuffer: Push[] = []\r\n  presence: RealtimePresence\r\n\r\n  constructor(\r\n    /** Topic name can be any string. */\r\n    public topic: string,\r\n    public params: RealtimeChannelOptions = { config: {} },\r\n    public socket: RealtimeClient\r\n  ) {\r\n    this.params.config = {\r\n      ...{\r\n        broadcast: { ack: false, self: false },\r\n        presence: { key: '' },\r\n      },\r\n      ...params.config,\r\n    }\r\n    this.timeout = this.socket.timeout\r\n    this.joinPush = new Push(\r\n      this,\r\n      CHANNEL_EVENTS.join,\r\n      this.params,\r\n      this.timeout\r\n    )\r\n    this.rejoinTimer = new Timer(\r\n      () => this._rejoinUntilConnected(),\r\n      this.socket.reconnectAfterMs\r\n    )\r\n    this.joinPush.receive('ok', () => {\r\n      this.state = CHANNEL_STATES.joined\r\n      this.rejoinTimer.reset()\r\n      this.pushBuffer.forEach((pushEvent: Push) => pushEvent.send())\r\n      this.pushBuffer = []\r\n    })\r\n    this._onClose(() => {\r\n      this.rejoinTimer.reset()\r\n      this.socket.log('channel', `close ${this.topic} ${this._joinRef()}`)\r\n      this.state = CHANNEL_STATES.closed\r\n      this.socket._remove(this)\r\n    })\r\n    this._onError((reason: string) => {\r\n      if (this._isLeaving() || this._isClosed()) {\r\n        return\r\n      }\r\n      this.socket.log('channel', `error ${this.topic}`, reason)\r\n      this.state = CHANNEL_STATES.errored\r\n      this.rejoinTimer.scheduleTimeout()\r\n    })\r\n    this.joinPush.receive('timeout', () => {\r\n      if (!this._isJoining()) {\r\n        return\r\n      }\r\n      this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout)\r\n      this.state = CHANNEL_STATES.errored\r\n      this.rejoinTimer.scheduleTimeout()\r\n    })\r\n    this._on(CHANNEL_EVENTS.reply, {}, (payload: any, ref: string) => {\r\n      this._trigger(this._replyEventName(ref), payload)\r\n    })\r\n\r\n    this.presence = new RealtimePresence(this)\r\n  }\r\n\r\n  /** Subscribe registers your client with the server */\r\n  subscribe(\r\n    callback?: (status: `${REALTIME_SUBSCRIBE_STATES}`, err?: Error) => void,\r\n    timeout = this.timeout\r\n  ): RealtimeChannel {\r\n    if (this.joinedOnce) {\r\n      throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`\r\n    } else {\r\n      const {\r\n        config: { broadcast, presence },\r\n      } = this.params\r\n      this._onError((e: Error) => callback && callback('CHANNEL_ERROR', e))\r\n      this._onClose(() => callback && callback('CLOSED'))\r\n\r\n      const accessTokenPayload: { access_token?: string } = {}\r\n      const config = {\r\n        broadcast,\r\n        presence,\r\n        postgres_changes:\r\n          this.bindings.postgres_changes?.map((r) => r.filter) ?? [],\r\n      }\r\n\r\n      if (this.socket.accessToken) {\r\n        accessTokenPayload.access_token = this.socket.accessToken\r\n      }\r\n\r\n      this.updateJoinPayload({ ...{ config }, ...accessTokenPayload })\r\n\r\n      this.joinedOnce = true\r\n      this._rejoin(timeout)\r\n\r\n      this.joinPush\r\n        .receive(\r\n          'ok',\r\n          ({\r\n            postgres_changes: serverPostgresFilters,\r\n          }: {\r\n            postgres_changes: {\r\n              id: string\r\n              event: string\r\n              schema?: string\r\n              table?: string\r\n              filter?: string\r\n            }[]\r\n          }) => {\r\n            this.socket.accessToken &&\r\n              this.socket.setAuth(this.socket.accessToken)\r\n\r\n            if (serverPostgresFilters === undefined) {\r\n              callback && callback('SUBSCRIBED')\r\n              return\r\n            } else {\r\n              const clientPostgresBindings = this.bindings.postgres_changes\r\n              const bindingsLen = clientPostgresBindings?.length ?? 0\r\n              const newPostgresBindings = []\r\n\r\n              for (let i = 0; i < bindingsLen; i++) {\r\n                const clientPostgresBinding = clientPostgresBindings[i]\r\n                const {\r\n                  filter: { event, schema, table, filter },\r\n                } = clientPostgresBinding\r\n                const serverPostgresFilter =\r\n                  serverPostgresFilters && serverPostgresFilters[i]\r\n\r\n                if (\r\n                  serverPostgresFilter &&\r\n                  serverPostgresFilter.event === event &&\r\n                  serverPostgresFilter.schema === schema &&\r\n                  serverPostgresFilter.table === table &&\r\n                  serverPostgresFilter.filter === filter\r\n                ) {\r\n                  newPostgresBindings.push({\r\n                    ...clientPostgresBinding,\r\n                    id: serverPostgresFilter.id,\r\n                  })\r\n                } else {\r\n                  this.unsubscribe()\r\n                  callback &&\r\n                    callback(\r\n                      'CHANNEL_ERROR',\r\n                      new Error(\r\n                        'mismatch between server and client bindings for postgres changes'\r\n                      )\r\n                    )\r\n                  return\r\n                }\r\n              }\r\n\r\n              this.bindings.postgres_changes = newPostgresBindings\r\n\r\n              callback && callback('SUBSCRIBED')\r\n              return\r\n            }\r\n          }\r\n        )\r\n        .receive('error', (error: { [key: string]: any }) => {\r\n          callback &&\r\n            callback(\r\n              'CHANNEL_ERROR',\r\n              new Error(\r\n                JSON.stringify(Object.values(error).join(', ') || 'error')\r\n              )\r\n            )\r\n          return\r\n        })\r\n        .receive('timeout', () => {\r\n          callback && callback('TIMED_OUT')\r\n          return\r\n        })\r\n    }\r\n\r\n    return this\r\n  }\r\n\r\n  presenceState<\r\n    T extends { [key: string]: any } = {}\r\n  >(): RealtimePresenceState<T> {\r\n    return this.presence.state as RealtimePresenceState<T>\r\n  }\r\n\r\n  async track(\r\n    payload: { [key: string]: any },\r\n    opts: { [key: string]: any } = {}\r\n  ): Promise<RealtimeChannelSendResponse> {\r\n    return await this.send(\r\n      {\r\n        type: 'presence',\r\n        event: 'track',\r\n        payload,\r\n      },\r\n      opts.timeout || this.timeout\r\n    )\r\n  }\r\n\r\n  async untrack(\r\n    opts: { [key: string]: any } = {}\r\n  ): Promise<RealtimeChannelSendResponse> {\r\n    return await this.send(\r\n      {\r\n        type: 'presence',\r\n        event: 'untrack',\r\n      },\r\n      opts\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Creates an event handler that listens to changes.\r\n   */\r\n  on(\r\n    type: `${REALTIME_LISTEN_TYPES.PRESENCE}`,\r\n    filter: { event: `${REALTIME_PRESENCE_LISTEN_EVENTS.SYNC}` },\r\n    callback: () => void\r\n  ): RealtimeChannel\r\n  on<T extends { [key: string]: any }>(\r\n    type: `${REALTIME_LISTEN_TYPES.PRESENCE}`,\r\n    filter: { event: `${REALTIME_PRESENCE_LISTEN_EVENTS.JOIN}` },\r\n    callback: (payload: RealtimePresenceJoinPayload<T>) => void\r\n  ): RealtimeChannel\r\n  on<T extends { [key: string]: any }>(\r\n    type: `${REALTIME_LISTEN_TYPES.PRESENCE}`,\r\n    filter: { event: `${REALTIME_PRESENCE_LISTEN_EVENTS.LEAVE}` },\r\n    callback: (payload: RealtimePresenceLeavePayload<T>) => void\r\n  ): RealtimeChannel\r\n  on<T extends { [key: string]: any }>(\r\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\r\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.ALL}`>,\r\n    callback: (payload: RealtimePostgresChangesPayload<T>) => void\r\n  ): RealtimeChannel\r\n  on<T extends { [key: string]: any }>(\r\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\r\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.INSERT}`>,\r\n    callback: (payload: RealtimePostgresInsertPayload<T>) => void\r\n  ): RealtimeChannel\r\n  on<T extends { [key: string]: any }>(\r\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\r\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.UPDATE}`>,\r\n    callback: (payload: RealtimePostgresUpdatePayload<T>) => void\r\n  ): RealtimeChannel\r\n  on<T extends { [key: string]: any }>(\r\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\r\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.DELETE}`>,\r\n    callback: (payload: RealtimePostgresDeletePayload<T>) => void\r\n  ): RealtimeChannel\r\n  /**\r\n   * The following is placed here to display on supabase.com/docs/reference/javascript/subscribe.\r\n   * @param type One of \"broadcast\", \"presence\", or \"postgres_changes\".\r\n   * @param filter Custom object specific to the Realtime feature detailing which payloads to receive.\r\n   * @param callback Function to be invoked when event handler is triggered.\r\n   */\r\n  on(\r\n    type: `${REALTIME_LISTEN_TYPES.BROADCAST}`,\r\n    filter: { event: string },\r\n    callback: (payload: {\r\n      type: `${REALTIME_LISTEN_TYPES.BROADCAST}`\r\n      event: string\r\n      [key: string]: any\r\n    }) => void\r\n  ): RealtimeChannel\r\n  on(\r\n    type: `${REALTIME_LISTEN_TYPES}`,\r\n    filter: { event: string; [key: string]: string },\r\n    callback: (payload: any) => void\r\n  ): RealtimeChannel {\r\n    return this._on(type, filter, callback)\r\n  }\r\n\r\n  send(\r\n    payload: { type: string; [key: string]: any },\r\n    opts: { [key: string]: any } = {}\r\n  ): Promise<RealtimeChannelSendResponse> {\r\n    return new Promise((resolve) => {\r\n      const push = this._push(\r\n        payload.type,\r\n        payload,\r\n        opts.timeout || this.timeout\r\n      )\r\n\r\n      if (push.rateLimited) {\r\n        resolve('rate limited')\r\n      }\r\n\r\n      if (\r\n        payload.type === 'broadcast' &&\r\n        !this.params?.config?.broadcast?.ack\r\n      ) {\r\n        resolve('ok')\r\n      }\r\n\r\n      push.receive('ok', () => resolve('ok'))\r\n      push.receive('timeout', () => resolve('timed out'))\r\n    })\r\n  }\r\n\r\n  updateJoinPayload(payload: { [key: string]: any }): void {\r\n    this.joinPush.updatePayload(payload)\r\n  }\r\n\r\n  /**\r\n   * Leaves the channel.\r\n   *\r\n   * Unsubscribes from server events, and instructs channel to terminate on server.\r\n   * Triggers onClose() hooks.\r\n   *\r\n   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\r\n   * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\r\n   */\r\n  unsubscribe(timeout = this.timeout): Promise<'ok' | 'timed out' | 'error'> {\r\n    this.state = CHANNEL_STATES.leaving\r\n    const onClose = () => {\r\n      this.socket.log('channel', `leave ${this.topic}`)\r\n      this._trigger(CHANNEL_EVENTS.close, 'leave', this._joinRef())\r\n    }\r\n\r\n    this.rejoinTimer.reset()\r\n    // Destroy joinPush to avoid connection timeouts during unscription phase\r\n    this.joinPush.destroy()\r\n\r\n    return new Promise((resolve) => {\r\n      const leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout)\r\n\r\n      leavePush\r\n        .receive('ok', () => {\r\n          onClose()\r\n          resolve('ok')\r\n        })\r\n        .receive('timeout', () => {\r\n          onClose()\r\n          resolve('timed out')\r\n        })\r\n        .receive('error', () => {\r\n          resolve('error')\r\n        })\r\n\r\n      leavePush.send()\r\n\r\n      if (!this._canPush()) {\r\n        leavePush.trigger('ok', {})\r\n      }\r\n    })\r\n  }\r\n\r\n  /** @internal */\r\n  _push(\r\n    event: string,\r\n    payload: { [key: string]: any },\r\n    timeout = this.timeout\r\n  ) {\r\n    if (!this.joinedOnce) {\r\n      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`\r\n    }\r\n    let pushEvent = new Push(this, event, payload, timeout)\r\n    if (this._canPush()) {\r\n      pushEvent.send()\r\n    } else {\r\n      pushEvent.startTimeout()\r\n      this.pushBuffer.push(pushEvent)\r\n    }\r\n\r\n    return pushEvent\r\n  }\r\n\r\n  /**\r\n   * Overridable message hook\r\n   *\r\n   * Receives all events for specialized message handling before dispatching to the channel callbacks.\r\n   * Must return the payload, modified or unmodified.\r\n   *\r\n   * @internal\r\n   */\r\n  _onMessage(_event: string, payload: any, _ref?: string) {\r\n    return payload\r\n  }\r\n\r\n  /** @internal */\r\n  _isMember(topic: string): boolean {\r\n    return this.topic === topic\r\n  }\r\n\r\n  /** @internal */\r\n  _joinRef(): string {\r\n    return this.joinPush.ref\r\n  }\r\n\r\n  /** @internal */\r\n  _trigger(type: string, payload?: any, ref?: string) {\r\n    const typeLower = type.toLocaleLowerCase()\r\n    const { close, error, leave, join } = CHANNEL_EVENTS\r\n    const events: string[] = [close, error, leave, join]\r\n    if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\r\n      return\r\n    }\r\n    let handledPayload = this._onMessage(typeLower, payload, ref)\r\n    if (payload && !handledPayload) {\r\n      throw 'channel onMessage callbacks must return the payload, modified or unmodified'\r\n    }\r\n\r\n    if (['insert', 'update', 'delete'].includes(typeLower)) {\r\n      this.bindings.postgres_changes\r\n        ?.filter((bind) => {\r\n          return (\r\n            bind.filter?.event === '*' ||\r\n            bind.filter?.event?.toLocaleLowerCase() === typeLower\r\n          )\r\n        })\r\n        .map((bind) => bind.callback(handledPayload, ref))\r\n    } else {\r\n      this.bindings[typeLower]\r\n        ?.filter((bind) => {\r\n          if (\r\n            ['broadcast', 'presence', 'postgres_changes'].includes(typeLower)\r\n          ) {\r\n            if ('id' in bind) {\r\n              const bindId = bind.id\r\n              const bindEvent = bind.filter?.event\r\n              return (\r\n                bindId &&\r\n                payload.ids?.includes(bindId) &&\r\n                (bindEvent === '*' ||\r\n                  bindEvent?.toLocaleLowerCase() ===\r\n                    payload.data?.type.toLocaleLowerCase())\r\n              )\r\n            } else {\r\n              const bindEvent = bind?.filter?.event?.toLocaleLowerCase()\r\n              return (\r\n                bindEvent === '*' ||\r\n                bindEvent === payload?.event?.toLocaleLowerCase()\r\n              )\r\n            }\r\n          } else {\r\n            return bind.type.toLocaleLowerCase() === typeLower\r\n          }\r\n        })\r\n        .map((bind) => {\r\n          if (typeof handledPayload === 'object' && 'ids' in handledPayload) {\r\n            const postgresChanges = handledPayload.data\r\n            const { schema, table, commit_timestamp, type, errors } =\r\n              postgresChanges\r\n            const enrichedPayload = {\r\n              schema: schema,\r\n              table: table,\r\n              commit_timestamp: commit_timestamp,\r\n              eventType: type,\r\n              new: {},\r\n              old: {},\r\n              errors: errors,\r\n            }\r\n            handledPayload = {\r\n              ...enrichedPayload,\r\n              ...this._getPayloadRecords(postgresChanges),\r\n            }\r\n          }\r\n          bind.callback(handledPayload, ref)\r\n        })\r\n    }\r\n  }\r\n\r\n  /** @internal */\r\n  _isClosed(): boolean {\r\n    return this.state === CHANNEL_STATES.closed\r\n  }\r\n\r\n  /** @internal */\r\n  _isJoined(): boolean {\r\n    return this.state === CHANNEL_STATES.joined\r\n  }\r\n\r\n  /** @internal */\r\n  _isJoining(): boolean {\r\n    return this.state === CHANNEL_STATES.joining\r\n  }\r\n\r\n  /** @internal */\r\n  _isLeaving(): boolean {\r\n    return this.state === CHANNEL_STATES.leaving\r\n  }\r\n\r\n  /** @internal */\r\n  _replyEventName(ref: string): string {\r\n    return `chan_reply_${ref}`\r\n  }\r\n\r\n  /** @internal */\r\n  _on(type: string, filter: { [key: string]: any }, callback: Function) {\r\n    const typeLower = type.toLocaleLowerCase()\r\n\r\n    const binding = {\r\n      type: typeLower,\r\n      filter: filter,\r\n      callback: callback,\r\n    }\r\n\r\n    if (this.bindings[typeLower]) {\r\n      this.bindings[typeLower].push(binding)\r\n    } else {\r\n      this.bindings[typeLower] = [binding]\r\n    }\r\n\r\n    return this\r\n  }\r\n\r\n  /** @internal */\r\n  _off(type: string, filter: { [key: string]: any }) {\r\n    const typeLower = type.toLocaleLowerCase()\r\n\r\n    this.bindings[typeLower] = this.bindings[typeLower].filter((bind) => {\r\n      return !(\r\n        bind.type?.toLocaleLowerCase() === typeLower &&\r\n        RealtimeChannel.isEqual(bind.filter, filter)\r\n      )\r\n    })\r\n    return this\r\n  }\r\n\r\n  /** @internal */\r\n  private static isEqual(\r\n    obj1: { [key: string]: string },\r\n    obj2: { [key: string]: string }\r\n  ) {\r\n    if (Object.keys(obj1).length !== Object.keys(obj2).length) {\r\n      return false\r\n    }\r\n\r\n    for (const k in obj1) {\r\n      if (obj1[k] !== obj2[k]) {\r\n        return false\r\n      }\r\n    }\r\n\r\n    return true\r\n  }\r\n\r\n  /** @internal */\r\n  private _rejoinUntilConnected() {\r\n    this.rejoinTimer.scheduleTimeout()\r\n    if (this.socket.isConnected()) {\r\n      this._rejoin()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Registers a callback that will be executed when the channel closes.\r\n   *\r\n   * @internal\r\n   */\r\n  private _onClose(callback: Function) {\r\n    this._on(CHANNEL_EVENTS.close, {}, callback)\r\n  }\r\n\r\n  /**\r\n   * Registers a callback that will be executed when the channel encounteres an error.\r\n   *\r\n   * @internal\r\n   */\r\n  private _onError(callback: Function) {\r\n    this._on(CHANNEL_EVENTS.error, {}, (reason: string) => callback(reason))\r\n  }\r\n\r\n  /**\r\n   * Returns `true` if the socket is connected and the channel has been joined.\r\n   *\r\n   * @internal\r\n   */\r\n  private _canPush(): boolean {\r\n    return this.socket.isConnected() && this._isJoined()\r\n  }\r\n\r\n  /** @internal */\r\n  private _rejoin(timeout = this.timeout): void {\r\n    if (this._isLeaving()) {\r\n      return\r\n    }\r\n    this.socket._leaveOpenTopic(this.topic)\r\n    this.state = CHANNEL_STATES.joining\r\n    this.joinPush.resend(timeout)\r\n  }\r\n\r\n  /** @internal */\r\n  private _getPayloadRecords(payload: any) {\r\n    const records = {\r\n      new: {},\r\n      old: {},\r\n    }\r\n\r\n    if (payload.type === 'INSERT' || payload.type === 'UPDATE') {\r\n      records.new = Transformers.convertChangeData(\r\n        payload.columns,\r\n        payload.record\r\n      )\r\n    }\r\n\r\n    if (payload.type === 'UPDATE' || payload.type === 'DELETE') {\r\n      records.old = Transformers.convertChangeData(\r\n        payload.columns,\r\n        payload.old_record\r\n      )\r\n    }\r\n\r\n    return records\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}