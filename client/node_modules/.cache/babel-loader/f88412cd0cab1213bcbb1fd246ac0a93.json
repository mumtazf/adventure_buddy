{"ast":null,"code":"import _slicedToArray from \"C:/Users/mumta/crewmates/client/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"C:/Users/mumta/crewmates/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/mumta/crewmates/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/mumta/crewmates/client/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/mumta/crewmates/client/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport PostgrestTransformBuilder from './PostgrestTransformBuilder';\n\nvar PostgrestFilterBuilder = /*#__PURE__*/function (_PostgrestTransformBu) {\n  _inherits(PostgrestFilterBuilder, _PostgrestTransformBu);\n\n  var _super = _createSuper(PostgrestFilterBuilder);\n\n  function PostgrestFilterBuilder() {\n    _classCallCheck(this, PostgrestFilterBuilder);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(PostgrestFilterBuilder, [{\n    key: \"eq\",\n    value:\n    /**\r\n     * Match only rows where `column` is equal to `value`.\r\n     *\r\n     * To check if the value of `column` is NULL, you should use `.is()` instead.\r\n     *\r\n     * @param column - The column to filter on\r\n     * @param value - The value to filter with\r\n     */\n    function eq(column, value) {\n      this.url.searchParams.append(column, \"eq.\".concat(value));\n      return this;\n    }\n    /**\r\n     * Match only rows where `column` is not equal to `value`.\r\n     *\r\n     * @param column - The column to filter on\r\n     * @param value - The value to filter with\r\n     */\n\n  }, {\n    key: \"neq\",\n    value: function neq(column, value) {\n      this.url.searchParams.append(column, \"neq.\".concat(value));\n      return this;\n    }\n    /**\r\n     * Match only rows where `column` is greater than `value`.\r\n     *\r\n     * @param column - The column to filter on\r\n     * @param value - The value to filter with\r\n     */\n\n  }, {\n    key: \"gt\",\n    value: function gt(column, value) {\n      this.url.searchParams.append(column, \"gt.\".concat(value));\n      return this;\n    }\n    /**\r\n     * Match only rows where `column` is greater than or equal to `value`.\r\n     *\r\n     * @param column - The column to filter on\r\n     * @param value - The value to filter with\r\n     */\n\n  }, {\n    key: \"gte\",\n    value: function gte(column, value) {\n      this.url.searchParams.append(column, \"gte.\".concat(value));\n      return this;\n    }\n    /**\r\n     * Match only rows where `column` is less than `value`.\r\n     *\r\n     * @param column - The column to filter on\r\n     * @param value - The value to filter with\r\n     */\n\n  }, {\n    key: \"lt\",\n    value: function lt(column, value) {\n      this.url.searchParams.append(column, \"lt.\".concat(value));\n      return this;\n    }\n    /**\r\n     * Match only rows where `column` is less than or equal to `value`.\r\n     *\r\n     * @param column - The column to filter on\r\n     * @param value - The value to filter with\r\n     */\n\n  }, {\n    key: \"lte\",\n    value: function lte(column, value) {\n      this.url.searchParams.append(column, \"lte.\".concat(value));\n      return this;\n    }\n    /**\r\n     * Match only rows where `column` matches `pattern` case-sensitively.\r\n     *\r\n     * @param column - The column to filter on\r\n     * @param pattern - The pattern to match with\r\n     */\n\n  }, {\n    key: \"like\",\n    value: function like(column, pattern) {\n      this.url.searchParams.append(column, \"like.\".concat(pattern));\n      return this;\n    }\n    /**\r\n     * Match only rows where `column` matches `pattern` case-insensitively.\r\n     *\r\n     * @param column - The column to filter on\r\n     * @param pattern - The pattern to match with\r\n     */\n\n  }, {\n    key: \"ilike\",\n    value: function ilike(column, pattern) {\n      this.url.searchParams.append(column, \"ilike.\".concat(pattern));\n      return this;\n    }\n    /**\r\n     * Match only rows where `column` IS `value`.\r\n     *\r\n     * For non-boolean columns, this is only relevant for checking if the value of\r\n     * `column` is NULL by setting `value` to `null`.\r\n     *\r\n     * For boolean columns, you can also set `value` to `true` or `false` and it\r\n     * will behave the same way as `.eq()`.\r\n     *\r\n     * @param column - The column to filter on\r\n     * @param value - The value to filter with\r\n     */\n\n  }, {\n    key: \"is\",\n    value: function is(column, value) {\n      this.url.searchParams.append(column, \"is.\".concat(value));\n      return this;\n    }\n    /**\r\n     * Match only rows where `column` is included in the `values` array.\r\n     *\r\n     * @param column - The column to filter on\r\n     * @param values - The values array to filter with\r\n     */\n\n  }, {\n    key: \"in\",\n    value: function _in(column, values) {\n      var cleanedValues = values.map(function (s) {\n        // handle postgrest reserved characters\n        // https://postgrest.org/en/v7.0.0/api.html#reserved-characters\n        if (typeof s === 'string' && new RegExp('[,()]').test(s)) return \"\\\"\".concat(s, \"\\\"\");else return \"\".concat(s);\n      }).join(',');\n      this.url.searchParams.append(column, \"in.(\".concat(cleanedValues, \")\"));\n      return this;\n    }\n    /**\r\n     * Only relevant for jsonb, array, and range columns. Match only rows where\r\n     * `column` contains every element appearing in `value`.\r\n     *\r\n     * @param column - The jsonb, array, or range column to filter on\r\n     * @param value - The jsonb, array, or range value to filter with\r\n     */\n\n  }, {\n    key: \"contains\",\n    value: function contains(column, value) {\n      if (typeof value === 'string') {\n        // range types can be inclusive '[', ']' or exclusive '(', ')' so just\n        // keep it simple and accept a string\n        this.url.searchParams.append(column, \"cs.\".concat(value));\n      } else if (Array.isArray(value)) {\n        // array\n        this.url.searchParams.append(column, \"cs.{\".concat(value.join(','), \"}\"));\n      } else {\n        // json\n        this.url.searchParams.append(column, \"cs.\".concat(JSON.stringify(value)));\n      }\n\n      return this;\n    }\n    /**\r\n     * Only relevant for jsonb, array, and range columns. Match only rows where\r\n     * every element appearing in `column` is contained by `value`.\r\n     *\r\n     * @param column - The jsonb, array, or range column to filter on\r\n     * @param value - The jsonb, array, or range value to filter with\r\n     */\n\n  }, {\n    key: \"containedBy\",\n    value: function containedBy(column, value) {\n      if (typeof value === 'string') {\n        // range\n        this.url.searchParams.append(column, \"cd.\".concat(value));\n      } else if (Array.isArray(value)) {\n        // array\n        this.url.searchParams.append(column, \"cd.{\".concat(value.join(','), \"}\"));\n      } else {\n        // json\n        this.url.searchParams.append(column, \"cd.\".concat(JSON.stringify(value)));\n      }\n\n      return this;\n    }\n    /**\r\n     * Only relevant for range columns. Match only rows where every element in\r\n     * `column` is greater than any element in `range`.\r\n     *\r\n     * @param column - The range column to filter on\r\n     * @param range - The range to filter with\r\n     */\n\n  }, {\n    key: \"rangeGt\",\n    value: function rangeGt(column, range) {\n      this.url.searchParams.append(column, \"sr.\".concat(range));\n      return this;\n    }\n    /**\r\n     * Only relevant for range columns. Match only rows where every element in\r\n     * `column` is either contained in `range` or greater than any element in\r\n     * `range`.\r\n     *\r\n     * @param column - The range column to filter on\r\n     * @param range - The range to filter with\r\n     */\n\n  }, {\n    key: \"rangeGte\",\n    value: function rangeGte(column, range) {\n      this.url.searchParams.append(column, \"nxl.\".concat(range));\n      return this;\n    }\n    /**\r\n     * Only relevant for range columns. Match only rows where every element in\r\n     * `column` is less than any element in `range`.\r\n     *\r\n     * @param column - The range column to filter on\r\n     * @param range - The range to filter with\r\n     */\n\n  }, {\n    key: \"rangeLt\",\n    value: function rangeLt(column, range) {\n      this.url.searchParams.append(column, \"sl.\".concat(range));\n      return this;\n    }\n    /**\r\n     * Only relevant for range columns. Match only rows where every element in\r\n     * `column` is either contained in `range` or less than any element in\r\n     * `range`.\r\n     *\r\n     * @param column - The range column to filter on\r\n     * @param range - The range to filter with\r\n     */\n\n  }, {\n    key: \"rangeLte\",\n    value: function rangeLte(column, range) {\n      this.url.searchParams.append(column, \"nxr.\".concat(range));\n      return this;\n    }\n    /**\r\n     * Only relevant for range columns. Match only rows where `column` is\r\n     * mutually exclusive to `range` and there can be no element between the two\r\n     * ranges.\r\n     *\r\n     * @param column - The range column to filter on\r\n     * @param range - The range to filter with\r\n     */\n\n  }, {\n    key: \"rangeAdjacent\",\n    value: function rangeAdjacent(column, range) {\n      this.url.searchParams.append(column, \"adj.\".concat(range));\n      return this;\n    }\n    /**\r\n     * Only relevant for array and range columns. Match only rows where\r\n     * `column` and `value` have an element in common.\r\n     *\r\n     * @param column - The array or range column to filter on\r\n     * @param value - The array or range value to filter with\r\n     */\n\n  }, {\n    key: \"overlaps\",\n    value: function overlaps(column, value) {\n      if (typeof value === 'string') {\n        // range\n        this.url.searchParams.append(column, \"ov.\".concat(value));\n      } else {\n        // array\n        this.url.searchParams.append(column, \"ov.{\".concat(value.join(','), \"}\"));\n      }\n\n      return this;\n    }\n    /**\r\n     * Only relevant for text and tsvector columns. Match only rows where\r\n     * `column` matches the query string in `query`.\r\n     *\r\n     * @param column - The text or tsvector column to filter on\r\n     * @param query - The query text to match with\r\n     * @param options - Named parameters\r\n     * @param options.config - The text search configuration to use\r\n     * @param options.type - Change how the `query` text is interpreted\r\n     */\n\n  }, {\n    key: \"textSearch\",\n    value: function textSearch(column, query) {\n      var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n          config = _ref.config,\n          type = _ref.type;\n\n      var typePart = '';\n\n      if (type === 'plain') {\n        typePart = 'pl';\n      } else if (type === 'phrase') {\n        typePart = 'ph';\n      } else if (type === 'websearch') {\n        typePart = 'w';\n      }\n\n      var configPart = config === undefined ? '' : \"(\".concat(config, \")\");\n      this.url.searchParams.append(column, \"\".concat(typePart, \"fts\").concat(configPart, \".\").concat(query));\n      return this;\n    }\n    /**\r\n     * Match only rows where each column in `query` keys is equal to its\r\n     * associated value. Shorthand for multiple `.eq()`s.\r\n     *\r\n     * @param query - The object to filter with, with column names as keys mapped\r\n     * to their filter values\r\n     */\n\n  }, {\n    key: \"match\",\n    value: function match(query) {\n      var _this = this;\n\n      Object.entries(query).forEach(function (_ref2) {\n        var _ref3 = _slicedToArray(_ref2, 2),\n            column = _ref3[0],\n            value = _ref3[1];\n\n        _this.url.searchParams.append(column, \"eq.\".concat(value));\n      });\n      return this;\n    }\n    /**\r\n     * Match only rows which doesn't satisfy the filter.\r\n     *\r\n     * Unlike most filters, `opearator` and `value` are used as-is and need to\r\n     * follow [PostgREST\r\n     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\r\n     * to make sure they are properly sanitized.\r\n     *\r\n     * @param column - The column to filter on\r\n     * @param operator - The operator to be negated to filter with, following\r\n     * PostgREST syntax\r\n     * @param value - The value to filter with, following PostgREST syntax\r\n     */\n\n  }, {\n    key: \"not\",\n    value: function not(column, operator, value) {\n      this.url.searchParams.append(column, \"not.\".concat(operator, \".\").concat(value));\n      return this;\n    }\n    /**\r\n     * Match only rows which satisfy at least one of the filters.\r\n     *\r\n     * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST\r\n     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\r\n     * to make sure it's properly sanitized.\r\n     *\r\n     * It's currently not possible to do an `.or()` filter across multiple tables.\r\n     *\r\n     * @param filters - The filters to use, following PostgREST syntax\r\n     * @param foreignTable - Set this to filter on foreign tables instead of the\r\n     * current table\r\n     */\n\n  }, {\n    key: \"or\",\n    value: function or(filters) {\n      var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          foreignTable = _ref4.foreignTable;\n\n      var key = foreignTable ? \"\".concat(foreignTable, \".or\") : 'or';\n      this.url.searchParams.append(key, \"(\".concat(filters, \")\"));\n      return this;\n    }\n    /**\r\n     * Match only rows which satisfy the filter. This is an escape hatch - you\r\n     * should use the specific filter methods wherever possible.\r\n     *\r\n     * Unlike most filters, `opearator` and `value` are used as-is and need to\r\n     * follow [PostgREST\r\n     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\r\n     * to make sure they are properly sanitized.\r\n     *\r\n     * @param column - The column to filter on\r\n     * @param operator - The operator to filter with, following PostgREST syntax\r\n     * @param value - The value to filter with, following PostgREST syntax\r\n     */\n\n  }, {\n    key: \"filter\",\n    value: function filter(column, operator, value) {\n      this.url.searchParams.append(column, \"\".concat(operator, \".\").concat(value));\n      return this;\n    }\n  }]);\n\n  return PostgrestFilterBuilder;\n}(PostgrestTransformBuilder);\n\nexport { PostgrestFilterBuilder as default };","map":{"version":3,"mappings":"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","names":["PostgrestTransformBuilder","PostgrestFilterBuilder","column","value","url","searchParams","append","pattern","values","cleanedValues","map","s","RegExp","test","join","Array","isArray","JSON","stringify","range","query","config","type","typePart","configPart","undefined","Object","entries","forEach","operator","filters","foreignTable","key"],"sources":["C:\\Users\\mumta\\crewmates\\client\\node_modules\\@supabase\\postgrest-js\\src\\PostgrestFilterBuilder.ts"],"sourcesContent":["import PostgrestTransformBuilder from './PostgrestTransformBuilder'\r\nimport { GenericSchema } from './types'\r\n\r\ntype FilterOperator =\r\n  | 'eq'\r\n  | 'neq'\r\n  | 'gt'\r\n  | 'gte'\r\n  | 'lt'\r\n  | 'lte'\r\n  | 'like'\r\n  | 'ilike'\r\n  | 'is'\r\n  | 'in'\r\n  | 'cs'\r\n  | 'cd'\r\n  | 'sl'\r\n  | 'sr'\r\n  | 'nxl'\r\n  | 'nxr'\r\n  | 'adj'\r\n  | 'ov'\r\n  | 'fts'\r\n  | 'plfts'\r\n  | 'phfts'\r\n  | 'wfts'\r\n\r\nexport default class PostgrestFilterBuilder<\r\n  Schema extends GenericSchema,\r\n  Row extends Record<string, unknown>,\r\n  Result\r\n> extends PostgrestTransformBuilder<Schema, Row, Result> {\r\n  eq<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\r\n  eq(column: string, value: unknown): this\r\n  /**\r\n   * Match only rows where `column` is equal to `value`.\r\n   *\r\n   * To check if the value of `column` is NULL, you should use `.is()` instead.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param value - The value to filter with\r\n   */\r\n  eq(column: string, value: unknown): this {\r\n    this.url.searchParams.append(column, `eq.${value}`)\r\n    return this\r\n  }\r\n\r\n  neq<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\r\n  neq(column: string, value: unknown): this\r\n  /**\r\n   * Match only rows where `column` is not equal to `value`.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param value - The value to filter with\r\n   */\r\n  neq(column: string, value: unknown): this {\r\n    this.url.searchParams.append(column, `neq.${value}`)\r\n    return this\r\n  }\r\n\r\n  gt<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\r\n  gt(column: string, value: unknown): this\r\n  /**\r\n   * Match only rows where `column` is greater than `value`.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param value - The value to filter with\r\n   */\r\n  gt(column: string, value: unknown): this {\r\n    this.url.searchParams.append(column, `gt.${value}`)\r\n    return this\r\n  }\r\n\r\n  gte<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\r\n  gte(column: string, value: unknown): this\r\n  /**\r\n   * Match only rows where `column` is greater than or equal to `value`.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param value - The value to filter with\r\n   */\r\n  gte(column: string, value: unknown): this {\r\n    this.url.searchParams.append(column, `gte.${value}`)\r\n    return this\r\n  }\r\n\r\n  lt<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\r\n  lt(column: string, value: unknown): this\r\n  /**\r\n   * Match only rows where `column` is less than `value`.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param value - The value to filter with\r\n   */\r\n  lt(column: string, value: unknown): this {\r\n    this.url.searchParams.append(column, `lt.${value}`)\r\n    return this\r\n  }\r\n\r\n  lte<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\r\n  lte(column: string, value: unknown): this\r\n  /**\r\n   * Match only rows where `column` is less than or equal to `value`.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param value - The value to filter with\r\n   */\r\n  lte(column: string, value: unknown): this {\r\n    this.url.searchParams.append(column, `lte.${value}`)\r\n    return this\r\n  }\r\n\r\n  like<ColumnName extends string & keyof Row>(column: ColumnName, pattern: string): this\r\n  like(column: string, pattern: string): this\r\n  /**\r\n   * Match only rows where `column` matches `pattern` case-sensitively.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param pattern - The pattern to match with\r\n   */\r\n  like(column: string, pattern: string): this {\r\n    this.url.searchParams.append(column, `like.${pattern}`)\r\n    return this\r\n  }\r\n\r\n  ilike<ColumnName extends string & keyof Row>(column: ColumnName, pattern: string): this\r\n  ilike(column: string, pattern: string): this\r\n  /**\r\n   * Match only rows where `column` matches `pattern` case-insensitively.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param pattern - The pattern to match with\r\n   */\r\n  ilike(column: string, pattern: string): this {\r\n    this.url.searchParams.append(column, `ilike.${pattern}`)\r\n    return this\r\n  }\r\n\r\n  is<ColumnName extends string & keyof Row>(\r\n    column: ColumnName,\r\n    value: Row[ColumnName] & (boolean | null)\r\n  ): this\r\n  is(column: string, value: boolean | null): this\r\n  /**\r\n   * Match only rows where `column` IS `value`.\r\n   *\r\n   * For non-boolean columns, this is only relevant for checking if the value of\r\n   * `column` is NULL by setting `value` to `null`.\r\n   *\r\n   * For boolean columns, you can also set `value` to `true` or `false` and it\r\n   * will behave the same way as `.eq()`.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param value - The value to filter with\r\n   */\r\n  is(column: string, value: boolean | null): this {\r\n    this.url.searchParams.append(column, `is.${value}`)\r\n    return this\r\n  }\r\n\r\n  in<ColumnName extends string & keyof Row>(column: ColumnName, values: Row[ColumnName][]): this\r\n  in(column: string, values: unknown[]): this\r\n  /**\r\n   * Match only rows where `column` is included in the `values` array.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param values - The values array to filter with\r\n   */\r\n  in(column: string, values: unknown[]): this {\r\n    const cleanedValues = values\r\n      .map((s) => {\r\n        // handle postgrest reserved characters\r\n        // https://postgrest.org/en/v7.0.0/api.html#reserved-characters\r\n        if (typeof s === 'string' && new RegExp('[,()]').test(s)) return `\"${s}\"`\r\n        else return `${s}`\r\n      })\r\n      .join(',')\r\n    this.url.searchParams.append(column, `in.(${cleanedValues})`)\r\n    return this\r\n  }\r\n\r\n  contains<ColumnName extends string & keyof Row>(\r\n    column: ColumnName,\r\n    value: string | Row[ColumnName][] | Record<string, unknown>\r\n  ): this\r\n  contains(column: string, value: string | unknown[] | Record<string, unknown>): this\r\n  /**\r\n   * Only relevant for jsonb, array, and range columns. Match only rows where\r\n   * `column` contains every element appearing in `value`.\r\n   *\r\n   * @param column - The jsonb, array, or range column to filter on\r\n   * @param value - The jsonb, array, or range value to filter with\r\n   */\r\n  contains(column: string, value: string | unknown[] | Record<string, unknown>): this {\r\n    if (typeof value === 'string') {\r\n      // range types can be inclusive '[', ']' or exclusive '(', ')' so just\r\n      // keep it simple and accept a string\r\n      this.url.searchParams.append(column, `cs.${value}`)\r\n    } else if (Array.isArray(value)) {\r\n      // array\r\n      this.url.searchParams.append(column, `cs.{${value.join(',')}}`)\r\n    } else {\r\n      // json\r\n      this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`)\r\n    }\r\n    return this\r\n  }\r\n\r\n  containedBy<ColumnName extends string & keyof Row>(\r\n    column: ColumnName,\r\n    value: string | Row[ColumnName][] | Record<string, unknown>\r\n  ): this\r\n  containedBy(column: string, value: string | unknown[] | Record<string, unknown>): this\r\n  /**\r\n   * Only relevant for jsonb, array, and range columns. Match only rows where\r\n   * every element appearing in `column` is contained by `value`.\r\n   *\r\n   * @param column - The jsonb, array, or range column to filter on\r\n   * @param value - The jsonb, array, or range value to filter with\r\n   */\r\n  containedBy(column: string, value: string | unknown[] | Record<string, unknown>): this {\r\n    if (typeof value === 'string') {\r\n      // range\r\n      this.url.searchParams.append(column, `cd.${value}`)\r\n    } else if (Array.isArray(value)) {\r\n      // array\r\n      this.url.searchParams.append(column, `cd.{${value.join(',')}}`)\r\n    } else {\r\n      // json\r\n      this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`)\r\n    }\r\n    return this\r\n  }\r\n\r\n  rangeGt<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\r\n  rangeGt(column: string, range: string): this\r\n  /**\r\n   * Only relevant for range columns. Match only rows where every element in\r\n   * `column` is greater than any element in `range`.\r\n   *\r\n   * @param column - The range column to filter on\r\n   * @param range - The range to filter with\r\n   */\r\n  rangeGt(column: string, range: string): this {\r\n    this.url.searchParams.append(column, `sr.${range}`)\r\n    return this\r\n  }\r\n\r\n  rangeGte<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\r\n  rangeGte(column: string, range: string): this\r\n  /**\r\n   * Only relevant for range columns. Match only rows where every element in\r\n   * `column` is either contained in `range` or greater than any element in\r\n   * `range`.\r\n   *\r\n   * @param column - The range column to filter on\r\n   * @param range - The range to filter with\r\n   */\r\n  rangeGte(column: string, range: string): this {\r\n    this.url.searchParams.append(column, `nxl.${range}`)\r\n    return this\r\n  }\r\n\r\n  rangeLt<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\r\n  rangeLt(column: string, range: string): this\r\n  /**\r\n   * Only relevant for range columns. Match only rows where every element in\r\n   * `column` is less than any element in `range`.\r\n   *\r\n   * @param column - The range column to filter on\r\n   * @param range - The range to filter with\r\n   */\r\n  rangeLt(column: string, range: string): this {\r\n    this.url.searchParams.append(column, `sl.${range}`)\r\n    return this\r\n  }\r\n\r\n  rangeLte<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\r\n  rangeLte(column: string, range: string): this\r\n  /**\r\n   * Only relevant for range columns. Match only rows where every element in\r\n   * `column` is either contained in `range` or less than any element in\r\n   * `range`.\r\n   *\r\n   * @param column - The range column to filter on\r\n   * @param range - The range to filter with\r\n   */\r\n  rangeLte(column: string, range: string): this {\r\n    this.url.searchParams.append(column, `nxr.${range}`)\r\n    return this\r\n  }\r\n\r\n  rangeAdjacent<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\r\n  rangeAdjacent(column: string, range: string): this\r\n  /**\r\n   * Only relevant for range columns. Match only rows where `column` is\r\n   * mutually exclusive to `range` and there can be no element between the two\r\n   * ranges.\r\n   *\r\n   * @param column - The range column to filter on\r\n   * @param range - The range to filter with\r\n   */\r\n  rangeAdjacent(column: string, range: string): this {\r\n    this.url.searchParams.append(column, `adj.${range}`)\r\n    return this\r\n  }\r\n\r\n  overlaps<ColumnName extends string & keyof Row>(\r\n    column: ColumnName,\r\n    value: string | Row[ColumnName][]\r\n  ): this\r\n  overlaps(column: string, value: string | unknown[]): this\r\n  /**\r\n   * Only relevant for array and range columns. Match only rows where\r\n   * `column` and `value` have an element in common.\r\n   *\r\n   * @param column - The array or range column to filter on\r\n   * @param value - The array or range value to filter with\r\n   */\r\n  overlaps(column: string, value: string | unknown[]): this {\r\n    if (typeof value === 'string') {\r\n      // range\r\n      this.url.searchParams.append(column, `ov.${value}`)\r\n    } else {\r\n      // array\r\n      this.url.searchParams.append(column, `ov.{${value.join(',')}}`)\r\n    }\r\n    return this\r\n  }\r\n\r\n  textSearch<ColumnName extends string & keyof Row>(\r\n    column: ColumnName,\r\n    query: string,\r\n    options?: { config?: string; type?: 'plain' | 'phrase' | 'websearch' }\r\n  ): this\r\n  textSearch(\r\n    column: string,\r\n    query: string,\r\n    options?: { config?: string; type?: 'plain' | 'phrase' | 'websearch' }\r\n  ): this\r\n  /**\r\n   * Only relevant for text and tsvector columns. Match only rows where\r\n   * `column` matches the query string in `query`.\r\n   *\r\n   * @param column - The text or tsvector column to filter on\r\n   * @param query - The query text to match with\r\n   * @param options - Named parameters\r\n   * @param options.config - The text search configuration to use\r\n   * @param options.type - Change how the `query` text is interpreted\r\n   */\r\n  textSearch(\r\n    column: string,\r\n    query: string,\r\n    { config, type }: { config?: string; type?: 'plain' | 'phrase' | 'websearch' } = {}\r\n  ): this {\r\n    let typePart = ''\r\n    if (type === 'plain') {\r\n      typePart = 'pl'\r\n    } else if (type === 'phrase') {\r\n      typePart = 'ph'\r\n    } else if (type === 'websearch') {\r\n      typePart = 'w'\r\n    }\r\n    const configPart = config === undefined ? '' : `(${config})`\r\n    this.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`)\r\n    return this\r\n  }\r\n\r\n  match<ColumnName extends string & keyof Row>(query: Record<ColumnName, Row[ColumnName]>): this\r\n  match(query: Record<string, unknown>): this\r\n  /**\r\n   * Match only rows where each column in `query` keys is equal to its\r\n   * associated value. Shorthand for multiple `.eq()`s.\r\n   *\r\n   * @param query - The object to filter with, with column names as keys mapped\r\n   * to their filter values\r\n   */\r\n  match(query: Record<string, unknown>): this {\r\n    Object.entries(query).forEach(([column, value]) => {\r\n      this.url.searchParams.append(column, `eq.${value}`)\r\n    })\r\n    return this\r\n  }\r\n\r\n  not<ColumnName extends string & keyof Row>(\r\n    column: ColumnName,\r\n    operator: FilterOperator,\r\n    value: Row[ColumnName]\r\n  ): this\r\n  not(column: string, operator: string, value: unknown): this\r\n  /**\r\n   * Match only rows which doesn't satisfy the filter.\r\n   *\r\n   * Unlike most filters, `opearator` and `value` are used as-is and need to\r\n   * follow [PostgREST\r\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\r\n   * to make sure they are properly sanitized.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param operator - The operator to be negated to filter with, following\r\n   * PostgREST syntax\r\n   * @param value - The value to filter with, following PostgREST syntax\r\n   */\r\n  not(column: string, operator: string, value: unknown): this {\r\n    this.url.searchParams.append(column, `not.${operator}.${value}`)\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Match only rows which satisfy at least one of the filters.\r\n   *\r\n   * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST\r\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\r\n   * to make sure it's properly sanitized.\r\n   *\r\n   * It's currently not possible to do an `.or()` filter across multiple tables.\r\n   *\r\n   * @param filters - The filters to use, following PostgREST syntax\r\n   * @param foreignTable - Set this to filter on foreign tables instead of the\r\n   * current table\r\n   */\r\n  or(filters: string, { foreignTable }: { foreignTable?: string } = {}): this {\r\n    const key = foreignTable ? `${foreignTable}.or` : 'or'\r\n    this.url.searchParams.append(key, `(${filters})`)\r\n    return this\r\n  }\r\n\r\n  filter<ColumnName extends string & keyof Row>(\r\n    column: ColumnName,\r\n    operator: `${'' | 'not.'}${FilterOperator}`,\r\n    value: unknown\r\n  ): this\r\n  filter(column: string, operator: string, value: unknown): this\r\n  /**\r\n   * Match only rows which satisfy the filter. This is an escape hatch - you\r\n   * should use the specific filter methods wherever possible.\r\n   *\r\n   * Unlike most filters, `opearator` and `value` are used as-is and need to\r\n   * follow [PostgREST\r\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\r\n   * to make sure they are properly sanitized.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param operator - The operator to filter with, following PostgREST syntax\r\n   * @param value - The value to filter with, following PostgREST syntax\r\n   */\r\n  filter(column: string, operator: string, value: unknown): this {\r\n    this.url.searchParams.append(column, `${operator}.${value}`)\r\n    return this\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}